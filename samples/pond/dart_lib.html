<html><head>
<script type="application//inert" id="frog_dom_frog_dart">
#library('dom');

#native('dom_frog.js');
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// DO NOT EDIT
// Auto-generated Dart DOM library.



// #source('src/_FactoryProviders.dart');

// TODO(jmesserly): 'native' here is aWork-around for Frog bug.  Frog needs to
// be smarter about inheriting from a hidden native type (in this case
// DOMWindow)
class Window extends DOMWindow native "*Window" {}
DOMWindow get window() native "return window;";
// TODO(vsm): Revert to Dart method when 508 is fixed.
HTMLDocument get document() native "return window.document;";

class AbstractWorker native "*AbstractWorker" {

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  bool dispatchEvent(Event evt) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class ArrayBuffer native "*ArrayBuffer" {

  int byteLength;

  ArrayBuffer slice(int begin, [int end = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class ArrayBufferView native "*ArrayBufferView" {

  ArrayBuffer buffer;

  int byteLength;

  int byteOffset;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Attr extends Node native "*Attr" {

  bool isId;

  String name;

  Element ownerElement;

  bool specified;

  String value;
}

class AudioBuffer native "*AudioBuffer" {

  num duration;

  num gain;

  int length;

  int numberOfChannels;

  num sampleRate;

  Float32Array getChannelData(int channelIndex) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class AudioBufferSourceNode extends AudioSourceNode native "*AudioBufferSourceNode" {

  AudioBuffer buffer;

  AudioGain gain;

  bool loop;

  bool looping;

  AudioParam playbackRate;

  void noteGrainOn(num when, num grainOffset, num grainDuration) native;

  void noteOff(num when) native;

  void noteOn(num when) native;
}

class AudioChannelMerger extends AudioNode native "*AudioChannelMerger" {
}

class AudioChannelSplitter extends AudioNode native "*AudioChannelSplitter" {
}

class AudioContext native "*AudioContext" {
  AudioContext() native;


  num currentTime;

  AudioDestinationNode destination;

  AudioListener listener;

  EventListener oncomplete;

  num sampleRate;

  RealtimeAnalyserNode createAnalyser() native;

  BiquadFilterNode createBiquadFilter() native;

  AudioBuffer createBuffer() native;

  AudioBufferSourceNode createBufferSource() native;

  AudioChannelMerger createChannelMerger() native;

  AudioChannelSplitter createChannelSplitter() native;

  ConvolverNode createConvolver() native;

  DelayNode createDelayNode() native;

  DynamicsCompressorNode createDynamicsCompressor() native;

  AudioGainNode createGainNode() native;

  HighPass2FilterNode createHighPass2Filter() native;

  JavaScriptAudioNode createJavaScriptNode(int bufferSize) native;

  LowPass2FilterNode createLowPass2Filter() native;

  MediaElementAudioSourceNode createMediaElementSource(HTMLMediaElement mediaElement) native;

  AudioPannerNode createPanner() native;

  WaveShaperNode createWaveShaper() native;

  void decodeAudioData(ArrayBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback = null]) native;

  void startRendering() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class AudioDestinationNode extends AudioNode native "*AudioDestinationNode" {

  int numberOfChannels;
}

class AudioGain extends AudioParam native "*AudioGain" {
}

class AudioGainNode extends AudioNode native "*AudioGainNode" {

  AudioGain gain;
}

class AudioListener native "*AudioListener" {

  num dopplerFactor;

  num speedOfSound;

  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp) native;

  void setPosition(num x, num y, num z) native;

  void setVelocity(num x, num y, num z) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class AudioNode native "*AudioNode" {

  AudioContext context;

  int numberOfInputs;

  int numberOfOutputs;

  void connect(AudioNode destination, [int output = null, int input = null]) native;

  void disconnect([int output = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class AudioPannerNode extends AudioNode native "*AudioPannerNode" {

  static final int EQUALPOWER = 0;

  static final int HRTF = 1;

  static final int SOUNDFIELD = 2;

  AudioGain coneGain;

  num coneInnerAngle;

  num coneOuterAngle;

  num coneOuterGain;

  AudioGain distanceGain;

  int distanceModel;

  num maxDistance;

  int panningModel;

  num refDistance;

  num rolloffFactor;

  void setOrientation(num x, num y, num z) native;

  void setPosition(num x, num y, num z) native;

  void setVelocity(num x, num y, num z) native;
}

class AudioParam native "*AudioParam" {

  num defaultValue;

  num maxValue;

  num minValue;

  String name;

  int units;

  num value;

  void cancelScheduledValues(num startTime) native;

  void exponentialRampToValueAtTime(num value, num time) native;

  void linearRampToValueAtTime(num value, num time) native;

  void setTargetValueAtTime(num targetValue, num time, num timeConstant) native;

  void setValueAtTime(num value, num time) native;

  void setValueCurveAtTime(Float32Array values, num time, num duration) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class AudioProcessingEvent extends Event native "*AudioProcessingEvent" {

  AudioBuffer inputBuffer;

  AudioBuffer outputBuffer;
}

class AudioSourceNode extends AudioNode native "*AudioSourceNode" {
}

class BarInfo native "*BarInfo" {

  bool visible;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class BeforeLoadEvent extends Event native "*BeforeLoadEvent" {

  String url;

  void initBeforeLoadEvent(String type, bool canBubble, bool cancelable, String url) native;
}

class BiquadFilterNode extends AudioNode native "*BiquadFilterNode" {

  static final int ALLPASS = 7;

  static final int BANDPASS = 2;

  static final int HIGHPASS = 1;

  static final int HIGHSHELF = 4;

  static final int LOWPASS = 0;

  static final int LOWSHELF = 3;

  static final int NOTCH = 6;

  static final int PEAKING = 5;

  AudioParam Q;

  AudioParam frequency;

  AudioParam gain;

  int type;
}

class Blob native "*Blob" {

  int size;

  String type;

  Blob webkitSlice([int start = null, int end = null, String contentType = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class CDATASection extends Text native "*CDATASection" {
}

class CSSCharsetRule extends CSSRule native "*CSSCharsetRule" {

  String encoding;
}

class CSSFontFaceRule extends CSSRule native "*CSSFontFaceRule" {

  CSSStyleDeclaration style;
}

class CSSImportRule extends CSSRule native "*CSSImportRule" {

  String href;

  MediaList media;

  CSSStyleSheet styleSheet;
}

class CSSMediaRule extends CSSRule native "*CSSMediaRule" {

  CSSRuleList cssRules;

  MediaList media;

  void deleteRule(int index) native;

  int insertRule(String rule, int index) native;
}

class CSSPageRule extends CSSRule native "*CSSPageRule" {

  String selectorText;

  CSSStyleDeclaration style;
}

class CSSPrimitiveValue extends CSSValue native "*CSSPrimitiveValue" {

  static final int CSS_ATTR = 22;

  static final int CSS_CM = 6;

  static final int CSS_COUNTER = 23;

  static final int CSS_DEG = 11;

  static final int CSS_DIMENSION = 18;

  static final int CSS_EMS = 3;

  static final int CSS_EXS = 4;

  static final int CSS_GRAD = 13;

  static final int CSS_HZ = 16;

  static final int CSS_IDENT = 21;

  static final int CSS_IN = 8;

  static final int CSS_KHZ = 17;

  static final int CSS_MM = 7;

  static final int CSS_MS = 14;

  static final int CSS_NUMBER = 1;

  static final int CSS_PC = 10;

  static final int CSS_PERCENTAGE = 2;

  static final int CSS_PT = 9;

  static final int CSS_PX = 5;

  static final int CSS_RAD = 12;

  static final int CSS_RECT = 24;

  static final int CSS_RGBCOLOR = 25;

  static final int CSS_S = 15;

  static final int CSS_STRING = 19;

  static final int CSS_UNKNOWN = 0;

  static final int CSS_URI = 20;

  int primitiveType;

  Counter getCounterValue() native;

  num getFloatValue(int unitType) native;

  RGBColor getRGBColorValue() native;

  Rect getRectValue() native;

  String getStringValue() native;

  void setFloatValue(int unitType, num floatValue) native;

  void setStringValue(int stringType, String stringValue) native;
}

class CSSRule native "CSSRule" {

  static final int CHARSET_RULE = 2;

  static final int FONT_FACE_RULE = 5;

  static final int IMPORT_RULE = 3;

  static final int MEDIA_RULE = 4;

  static final int PAGE_RULE = 6;

  static final int STYLE_RULE = 1;

  static final int UNKNOWN_RULE = 0;

  static final int WEBKIT_KEYFRAMES_RULE = 8;

  static final int WEBKIT_KEYFRAME_RULE = 9;

  static final int WEBKIT_REGION_STYLE_RULE = 10;

  String cssText;

  CSSRule parentRule;

  CSSStyleSheet parentStyleSheet;

  int type;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class CSSRuleList native "*CSSRuleList" {

  int length;

  CSSRule item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class CSSStyleDeclaration native "*CSSStyleDeclaration" {

  String cssText;

  int length;

  CSSRule parentRule;

  CSSValue getPropertyCSSValue(String propertyName) native;

  String getPropertyPriority(String propertyName) native;

  String getPropertyShorthand(String propertyName) native;

  String getPropertyValue(String propertyName) native;

  bool isPropertyImplicit(String propertyName) native;

  String item(int index) native;

  String removeProperty(String propertyName) native;

  void setProperty(String propertyName, String value, [String priority = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class CSSStyleRule extends CSSRule native "*CSSStyleRule" {

  String selectorText;

  CSSStyleDeclaration style;
}

class CSSStyleSheet extends StyleSheet native "*CSSStyleSheet" {

  CSSRuleList cssRules;

  CSSRule ownerRule;

  CSSRuleList rules;

  int addRule(String selector, String style, [int index = null]) native;

  void deleteRule(int index) native;

  int insertRule(String rule, int index) native;

  void removeRule(int index) native;
}

class CSSUnknownRule extends CSSRule native "*CSSUnknownRule" {
}

class CSSValue native "*CSSValue" {

  static final int CSS_CUSTOM = 3;

  static final int CSS_INHERIT = 0;

  static final int CSS_PRIMITIVE_VALUE = 1;

  static final int CSS_VALUE_LIST = 2;

  String cssText;

  int cssValueType;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class CSSValueList extends CSSValue native "*CSSValueList" {

  int length;

  CSSValue item(int index) native;
}

class CanvasGradient native "*CanvasGradient" {

  void addColorStop(num offset, String color) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class CanvasPattern native "*CanvasPattern" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class CanvasPixelArray native "*CanvasPixelArray" {

  int length;

  int operator[](int index) native;

  void operator[]=(int index, int value) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class CanvasRenderingContext native "*CanvasRenderingContext" {

  HTMLCanvasElement canvas;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class CanvasRenderingContext2D extends CanvasRenderingContext native "*CanvasRenderingContext2D" {

  Object fillStyle;

  String font;

  num globalAlpha;

  String globalCompositeOperation;

  String lineCap;

  String lineJoin;

  num lineWidth;

  num miterLimit;

  num shadowBlur;

  String shadowColor;

  num shadowOffsetX;

  num shadowOffsetY;

  Object strokeStyle;

  String textAlign;

  String textBaseline;

  List webkitLineDash;

  num webkitLineDashOffset;

  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) native;

  void arcTo(num x1, num y1, num x2, num y2, num radius) native;

  void beginPath() native;

  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) native;

  void clearRect(num x, num y, num width, num height) native;

  void clearShadow() native;

  void clip() native;

  void closePath() native;

  ImageData createImageData(var imagedata_OR_sw, [num sh = null]) native;

  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1) native;

  CanvasPattern createPattern(var canvas_OR_image, String repetitionType) native;

  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1) native;

  void drawImage(var canvas_OR_image_OR_video, num sx_OR_x, num sy_OR_y, [num sw_OR_width = null, num height_OR_sh = null, num dx = null, num dy = null, num dw = null, num dh = null]) native;

  void drawImageFromRect(HTMLImageElement image, [num sx = null, num sy = null, num sw = null, num sh = null, num dx = null, num dy = null, num dw = null, num dh = null, String compositeOperation = null]) native;

  void fill() native;

  void fillRect(num x, num y, num width, num height) native;

  void fillText(String text, num x, num y, [num maxWidth = null]) native;

  ImageData getImageData(num sx, num sy, num sw, num sh) native;

  bool isPointInPath(num x, num y) native;

  void lineTo(num x, num y) native;

  TextMetrics measureText(String text) native;

  void moveTo(num x, num y) native;

  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX = null, num dirtyY = null, num dirtyWidth = null, num dirtyHeight = null]) native;

  void quadraticCurveTo(num cpx, num cpy, num x, num y) native;

  void rect(num x, num y, num width, num height) native;

  void restore() native;

  void rotate(num angle) native;

  void save() native;

  void scale(num sx, num sy) native;

  void setAlpha(num alpha) native;

  void setCompositeOperation(String compositeOperation) native;

  void setFillColor(var c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) native;

  void setLineCap(String cap) native;

  void setLineJoin(String join) native;

  void setLineWidth(num width) native;

  void setMiterLimit(num limit) native;

  void setShadow(num width, num height, num blur, [var c_OR_color_OR_grayLevel_OR_r = null, num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) native;

  void setStrokeColor(var c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) native;

  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy) native;

  void stroke() native;

  void strokeRect(num x, num y, num width, num height, [num lineWidth = null]) native;

  void strokeText(String text, num x, num y, [num maxWidth = null]) native;

  void transform(num m11, num m12, num m21, num m22, num dx, num dy) native;

  void translate(num tx, num ty) native;
}

class CharacterData extends Node native "CharacterData" {

  String data;

  int length;

  void appendData(String data) native;

  void deleteData(int offset, int length) native;

  void insertData(int offset, String data) native;

  void replaceData(int offset, int length, String data) native;

  String substringData(int offset, int length) native;
}

class ClientRect native "*ClientRect" {

  num bottom;

  num height;

  num left;

  num right;

  num top;

  num width;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class ClientRectList native "*ClientRectList" {

  int length;

  ClientRect item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Clipboard native "*Clipboard" {

  String dropEffect;

  String effectAllowed;

  FileList files;

  DataTransferItemList items;

  List types;

  void clearData([String type = null]) native;

  void getData(String type) native;

  bool setData(String type, String data) native;

  void setDragImage(HTMLImageElement image, int x, int y) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class CloseEvent extends Event native "*CloseEvent" {

  int code;

  String reason;

  bool wasClean;

  void initCloseEvent(String typeArg, bool canBubbleArg, bool cancelableArg, bool wasCleanArg, int codeArg, String reasonArg) native;
}

class Comment extends CharacterData native "*Comment" {
}

class CompositionEvent extends UIEvent native "*CompositionEvent" {

  String data;

  void initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, DOMWindow viewArg, String dataArg) native;
}

class Console native "=(typeof console == 'undefined' ? {} : console)" {

  MemoryInfo memory;

  List profiles;

  void assert(bool condition) native;

  void count() native;

  void debug(Object arg) native;

  void dir() native;

  void dirxml() native;

  void error(Object arg) native;

  void group() native;

  void groupCollapsed() native;

  void groupEnd() native;

  void info(Object arg) native;

  void log(Object arg) native;

  void markTimeline() native;

  void profile(String title) native;

  void profileEnd(String title) native;

  void time(String title) native;

  void timeEnd(String title) native;

  void timeStamp() native;

  void trace(Object arg) native;

  void warn(Object arg) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class ConvolverNode extends AudioNode native "*ConvolverNode" {

  AudioBuffer buffer;
}

class Coordinates native "*Coordinates" {

  num accuracy;

  num altitude;

  num altitudeAccuracy;

  num heading;

  num latitude;

  num longitude;

  num speed;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Counter native "*Counter" {

  String identifier;

  String listStyle;

  String separator;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Crypto native "*Crypto" {

  void getRandomValues(ArrayBufferView array) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class CustomEvent extends Event native "*CustomEvent" {

  Object detail;

  void initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg) native;
}

class DOMApplicationCache native "*DOMApplicationCache" {

  static final int CHECKING = 2;

  static final int DOWNLOADING = 3;

  static final int IDLE = 1;

  static final int OBSOLETE = 5;

  static final int UNCACHED = 0;

  static final int UPDATEREADY = 4;

  int status;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  bool dispatchEvent(Event evt) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void swapCache() native;

  void update() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMException native "*DOMException" {

  static final int ABORT_ERR = 20;

  static final int DATA_CLONE_ERR = 25;

  static final int DOMSTRING_SIZE_ERR = 2;

  static final int HIERARCHY_REQUEST_ERR = 3;

  static final int INDEX_SIZE_ERR = 1;

  static final int INUSE_ATTRIBUTE_ERR = 10;

  static final int INVALID_ACCESS_ERR = 15;

  static final int INVALID_CHARACTER_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 13;

  static final int INVALID_NODE_TYPE_ERR = 24;

  static final int INVALID_STATE_ERR = 11;

  static final int NAMESPACE_ERR = 14;

  static final int NETWORK_ERR = 19;

  static final int NOT_FOUND_ERR = 8;

  static final int NOT_SUPPORTED_ERR = 9;

  static final int NO_DATA_ALLOWED_ERR = 6;

  static final int NO_MODIFICATION_ALLOWED_ERR = 7;

  static final int QUOTA_EXCEEDED_ERR = 22;

  static final int SECURITY_ERR = 18;

  static final int SYNTAX_ERR = 12;

  static final int TIMEOUT_ERR = 23;

  static final int TYPE_MISMATCH_ERR = 17;

  static final int URL_MISMATCH_ERR = 21;

  static final int VALIDATION_ERR = 16;

  static final int WRONG_DOCUMENT_ERR = 4;

  int code;

  String message;

  String name;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMFileSystem native "*DOMFileSystem" {

  String name;

  DirectoryEntry root;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMFileSystemSync native "*DOMFileSystemSync" {

  String name;

  DirectoryEntrySync root;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMFormData native "*DOMFormData" {

  void append(String name, String value, String filename) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMImplementation native "*DOMImplementation" {

  CSSStyleSheet createCSSStyleSheet(String title, String media) native;

  Document createDocument(String namespaceURI, String qualifiedName, DocumentType doctype) native;

  DocumentType createDocumentType(String qualifiedName, String publicId, String systemId) native;

  HTMLDocument createHTMLDocument(String title) native;

  bool hasFeature(String feature, String version) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMMimeType native "*DOMMimeType" {

  String description;

  DOMPlugin enabledPlugin;

  String suffixes;

  String type;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMMimeTypeArray native "*DOMMimeTypeArray" {

  int length;

  DOMMimeType item(int index) native;

  DOMMimeType namedItem(String name) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMParser native "*DOMParser" {

  Document parseFromString(String str, String contentType) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMPlugin native "*DOMPlugin" {

  String description;

  String filename;

  int length;

  String name;

  DOMMimeType item(int index) native;

  DOMMimeType namedItem(String name) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMPluginArray native "*DOMPluginArray" {

  int length;

  DOMPlugin item(int index) native;

  DOMPlugin namedItem(String name) native;

  void refresh(bool reload) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMSelection native "*DOMSelection" {

  Node anchorNode;

  int anchorOffset;

  Node baseNode;

  int baseOffset;

  Node extentNode;

  int extentOffset;

  Node focusNode;

  int focusOffset;

  bool isCollapsed;

  int rangeCount;

  String type;

  void addRange(Range range) native;

  void collapse(Node node, int index) native;

  void collapseToEnd() native;

  void collapseToStart() native;

  bool containsNode(Node node, bool allowPartial) native;

  void deleteFromDocument() native;

  void empty() native;

  void extend(Node node, int offset) native;

  Range getRangeAt(int index) native;

  void modify(String alter, String direction, String granularity) native;

  void removeAllRanges() native;

  void selectAllChildren(Node node) native;

  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset) native;

  void setPosition(Node node, int offset) native;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMSettableTokenList extends DOMTokenList native "*DOMSettableTokenList" {

  String value;
}

class DOMTokenList native "*DOMTokenList" {

  int length;

  void add(String token) native;

  bool contains(String token) native;

  String item(int index) native;

  void remove(String token) native;

  String toString() native;

  bool toggle(String token) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMURL native "*DOMURL" {

  String createObjectURL(Blob blob) native;

  void revokeObjectURL(String url) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DOMWindow native "@*DOMWindow" {

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  DOMApplicationCache applicationCache;

  Navigator clientInformation;

  bool closed;

  Console console;

  Crypto crypto;

  String defaultStatus;

  String defaultstatus;

  num devicePixelRatio;

  Document document;

  Event event;

  Element frameElement;

  DOMWindow frames;

  History history;

  int innerHeight;

  int innerWidth;

  int length;

  Storage localStorage;

  Location location;

  BarInfo locationbar;

  BarInfo menubar;

  String name;

  Navigator navigator;

  bool offscreenBuffering;

  DOMWindow opener;

  int outerHeight;

  int outerWidth;

  int pageXOffset;

  int pageYOffset;

  DOMWindow parent;

  Performance performance;

  BarInfo personalbar;

  Screen screen;

  int screenLeft;

  int screenTop;

  int screenX;

  int screenY;

  int scrollX;

  int scrollY;

  BarInfo scrollbars;

  DOMWindow self;

  Storage sessionStorage;

  String status;

  BarInfo statusbar;

  StyleMedia styleMedia;

  BarInfo toolbar;

  DOMWindow top;

  IDBFactory webkitIndexedDB;

  NotificationCenter webkitNotifications;

  StorageInfo webkitStorageInfo;

  DOMURL webkitURL;

  DOMWindow window;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void alert(String message) native;

  String atob(String string) native;

  void blur() native;

  String btoa(String string) native;

  void captureEvents() native;

  void clearInterval(int handle) native;

  void clearTimeout(int handle) native;

  void close() native;

  bool confirm(String message) native;

  bool dispatchEvent(Event evt) native;

  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) native;

  void focus() native;

  CSSStyleDeclaration getComputedStyle(Element element, String pseudoElement) native;

  CSSRuleList getMatchedCSSRules(Element element, String pseudoElement) native;

  DOMSelection getSelection() native;

  MediaQueryList matchMedia(String query) native;

  void moveBy(num x, num y) native;

  void moveTo(num x, num y) native;

  DOMWindow open(String url, String name, [String options = null]) native;

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) native;

  void postMessage(String message, var messagePorts_OR_targetOrigin, [String targetOrigin = null]) native;

  void print() native;

  String prompt(String message, String defaultValue) native;

  void releaseEvents() native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void resizeBy(num x, num y) native;

  void resizeTo(num width, num height) native;

  void scroll(int x, int y) native;

  void scrollBy(int x, int y) native;

  void scrollTo(int x, int y) native;

  int setInterval(TimeoutHandler handler, int timeout) native;

  int setTimeout(TimeoutHandler handler, int timeout) native;

  Object showModalDialog(String url, [Object dialogArgs = null, String featureArgs = null]) native;

  void stop() native;

  void webkitCancelRequestAnimationFrame(int id) native;

  WebKitPoint webkitConvertPointFromNodeToPage(Node node, WebKitPoint p) native;

  WebKitPoint webkitConvertPointFromPageToNode(Node node, WebKitPoint p) native;

  void webkitPostMessage(String message, var targetOrigin_OR_transferList, [String targetOrigin = null]) native;

  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback, Element element) native;

  void webkitRequestFileSystem(int type, int size, [FileSystemCallback successCallback = null, ErrorCallback errorCallback = null]) native;

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback = null, ErrorCallback errorCallback = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DataTransferItem native "*DataTransferItem" {

  String kind;

  String type;

  Blob getAsFile() native;

  void getAsString(StringCallback callback) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DataTransferItemList native "*DataTransferItemList" {

  int length;

  void add(String data, String type) native;

  void clear() native;

  DataTransferItem item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DataView extends ArrayBufferView native "*DataView" {

  num getFloat32(int byteOffset, [bool littleEndian = null]) native;

  num getFloat64(int byteOffset, [bool littleEndian = null]) native;

  int getInt16(int byteOffset, [bool littleEndian = null]) native;

  int getInt32(int byteOffset, [bool littleEndian = null]) native;

  Object getInt8() native;

  int getUint16(int byteOffset, [bool littleEndian = null]) native;

  int getUint32(int byteOffset, [bool littleEndian = null]) native;

  Object getUint8() native;

  void setFloat32(int byteOffset, num value, [bool littleEndian = null]) native;

  void setFloat64(int byteOffset, num value, [bool littleEndian = null]) native;

  void setInt16(int byteOffset, int value, [bool littleEndian = null]) native;

  void setInt32(int byteOffset, int value, [bool littleEndian = null]) native;

  void setInt8() native;

  void setUint16(int byteOffset, int value, [bool littleEndian = null]) native;

  void setUint32(int byteOffset, int value, [bool littleEndian = null]) native;

  void setUint8() native;
}

class Database native "*Database" {

  String version;

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionCallback callback = null, SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) native;

  void readTransaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) native;

  void transaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DatabaseSync native "*DatabaseSync" {

  String version;

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionSyncCallback callback = null]) native;

  void readTransaction(SQLTransactionSyncCallback callback) native;

  void transaction(SQLTransactionSyncCallback callback) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DedicatedWorkerContext extends WorkerContext native "*DedicatedWorkerContext" {

  EventListener onmessage;

  void postMessage(Object message, [List messagePorts = null]) native;

  void webkitPostMessage(Object message, [List transferList = null]) native;
}

class DelayNode extends AudioNode native "*DelayNode" {

  AudioParam delayTime;
}

class DeviceMotionEvent extends Event native "*DeviceMotionEvent" {

  num interval;
}

class DeviceOrientationEvent extends Event native "*DeviceOrientationEvent" {

  num alpha;

  num beta;

  num gamma;

  void initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma) native;
}

class DirectoryEntry extends Entry native "*DirectoryEntry" {

  DirectoryReader createReader() native;

  void getDirectory(String path, [WebKitFlags flags = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) native;

  void getFile(String path, [WebKitFlags flags = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) native;

  void removeRecursively([VoidCallback successCallback = null, ErrorCallback errorCallback = null]) native;
}

class DirectoryEntrySync extends EntrySync native "*DirectoryEntrySync" {

  DirectoryReaderSync createReader() native;

  DirectoryEntrySync getDirectory(String path, WebKitFlags flags) native;

  FileEntrySync getFile(String path, WebKitFlags flags) native;

  void removeRecursively() native;
}

class DirectoryReader native "*DirectoryReader" {

  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class DirectoryReaderSync native "*DirectoryReaderSync" {

  EntryArraySync readEntries() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Document extends Node native "Document" {

  String URL;

  HTMLCollection anchors;

  HTMLCollection applets;

  HTMLElement body;

  String characterSet;

  String charset;

  String compatMode;

  String cookie;

  String defaultCharset;

  DOMWindow defaultView;

  DocumentType doctype;

  Element documentElement;

  String documentURI;

  String domain;

  HTMLCollection forms;

  HTMLHeadElement head;

  HTMLCollection images;

  DOMImplementation implementation;

  String inputEncoding;

  String lastModified;

  HTMLCollection links;

  Location location;

  String preferredStylesheetSet;

  String readyState;

  String referrer;

  String selectedStylesheetSet;

  StyleSheetList styleSheets;

  String title;

  Element webkitCurrentFullScreenElement;

  bool webkitFullScreenKeyboardInputAllowed;

  bool webkitHidden;

  bool webkitIsFullScreen;

  String webkitVisibilityState;

  String xmlEncoding;

  bool xmlStandalone;

  String xmlVersion;

  Node adoptNode(Node source) native;

  Range caretRangeFromPoint(int x, int y) native;

  Attr createAttribute(String name) native;

  Attr createAttributeNS(String namespaceURI, String qualifiedName) native;

  CDATASection createCDATASection(String data) native;

  Comment createComment(String data) native;

  DocumentFragment createDocumentFragment() native;

  Element createElement(String tagName) native;

  Element createElementNS(String namespaceURI, String qualifiedName) native;

  EntityReference createEntityReference(String name) native;

  Event createEvent(String eventType) native;

  XPathExpression createExpression(String expression, XPathNSResolver resolver) native;

  XPathNSResolver createNSResolver(Node nodeResolver) native;

  NodeIterator createNodeIterator(Node root, int whatToShow, NodeFilter filter, bool expandEntityReferences) native;

  ProcessingInstruction createProcessingInstruction(String target, String data) native;

  Range createRange() native;

  Text createTextNode(String data) native;

  Touch createTouch(DOMWindow window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce) native;

  TouchList createTouchList() native;

  TreeWalker createTreeWalker(Node root, int whatToShow, NodeFilter filter, bool expandEntityReferences) native;

  Element elementFromPoint(int x, int y) native;

  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult) native;

  bool execCommand(String command, bool userInterface, String value) native;

  Object getCSSCanvasContext(String contextId, String name, int width, int height) native;

  Element getElementById(String elementId) native;

  NodeList getElementsByClassName(String tagname) native;

  NodeList getElementsByName(String elementName) native;

  NodeList getElementsByTagName(String tagname) native;

  NodeList getElementsByTagNameNS(String namespaceURI, String localName) native;

  CSSStyleDeclaration getOverrideStyle(Element element, String pseudoElement) native;

  DOMSelection getSelection() native;

  Node importNode(Node importedNode, bool deep) native;

  bool queryCommandEnabled(String command) native;

  bool queryCommandIndeterm(String command) native;

  bool queryCommandState(String command) native;

  bool queryCommandSupported(String command) native;

  String queryCommandValue(String command) native;

  Element querySelector(String selectors) native;

  NodeList querySelectorAll(String selectors) native;

  void webkitCancelFullScreen() native;
}

class DocumentFragment extends Node native "*DocumentFragment" {

  Element querySelector(String selectors) native;

  NodeList querySelectorAll(String selectors) native;
}

class DocumentType extends Node native "*DocumentType" {

  NamedNodeMap entities;

  String internalSubset;

  String name;

  NamedNodeMap notations;

  String publicId;

  String systemId;
}

class DynamicsCompressorNode extends AudioNode native "*DynamicsCompressorNode" {
}

class Element extends Node native "Element" {

  static final int ALLOW_KEYBOARD_INPUT = 1;

  int childElementCount;

  int clientHeight;

  int clientLeft;

  int clientTop;

  int clientWidth;

  Element firstElementChild;

  Element lastElementChild;

  Element nextElementSibling;

  int offsetHeight;

  int offsetLeft;

  Element offsetParent;

  int offsetTop;

  int offsetWidth;

  Element previousElementSibling;

  int scrollHeight;

  int scrollLeft;

  int scrollTop;

  int scrollWidth;

  CSSStyleDeclaration style;

  String tagName;

  void blur() native;

  void focus() native;

  String getAttribute(String name) native;

  String getAttributeNS(String namespaceURI, String localName) native;

  Attr getAttributeNode(String name) native;

  Attr getAttributeNodeNS(String namespaceURI, String localName) native;

  ClientRect getBoundingClientRect() native;

  ClientRectList getClientRects() native;

  NodeList getElementsByClassName(String name) native;

  NodeList getElementsByTagName(String name) native;

  NodeList getElementsByTagNameNS(String namespaceURI, String localName) native;

  bool hasAttribute(String name) native;

  bool hasAttributeNS(String namespaceURI, String localName) native;

  Element querySelector(String selectors) native;

  NodeList querySelectorAll(String selectors) native;

  void removeAttribute(String name) native;

  void removeAttributeNS(String namespaceURI, String localName) native;

  Attr removeAttributeNode(Attr oldAttr) native;

  void scrollByLines(int lines) native;

  void scrollByPages(int pages) native;

  void scrollIntoView([bool alignWithTop = null]) native;

  void scrollIntoViewIfNeeded([bool centerIfNeeded = null]) native;

  void setAttribute(String name, String value) native;

  void setAttributeNS(String namespaceURI, String qualifiedName, String value) native;

  Attr setAttributeNode(Attr newAttr) native;

  Attr setAttributeNodeNS(Attr newAttr) native;

  bool webkitMatchesSelector(String selectors) native;

  void webkitRequestFullScreen(int flags) native;
}

class ElementTimeControl native "*ElementTimeControl" {

  void beginElement() native;

  void beginElementAt(num offset) native;

  void endElement() native;

  void endElementAt(num offset) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class ElementTraversal native "*ElementTraversal" {

  int childElementCount;

  Element firstElementChild;

  Element lastElementChild;

  Element nextElementSibling;

  Element previousElementSibling;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Entity extends Node native "*Entity" {

  String notationName;

  String publicId;

  String systemId;
}

class EntityReference extends Node native "*EntityReference" {
}

class Entry native "*Entry" {

  DOMFileSystem filesystem;

  String fullPath;

  bool isDirectory;

  bool isFile;

  String name;

  void copyTo(DirectoryEntry parent, [String name = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) native;

  void getMetadata([MetadataCallback successCallback = null, ErrorCallback errorCallback = null]) native;

  void getParent([EntryCallback successCallback = null, ErrorCallback errorCallback = null]) native;

  void moveTo(DirectoryEntry parent, [String name = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) native;

  void remove([VoidCallback successCallback = null, ErrorCallback errorCallback = null]) native;

  String toURL() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class EntryArray native "*EntryArray" {

  int length;

  Entry item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class EntryArraySync native "*EntryArraySync" {

  int length;

  EntrySync item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class EntrySync native "*EntrySync" {

  DOMFileSystemSync filesystem;

  String fullPath;

  bool isDirectory;

  bool isFile;

  String name;

  EntrySync copyTo(DirectoryEntrySync parent, String name) native;

  Metadata getMetadata() native;

  DirectoryEntrySync getParent() native;

  EntrySync moveTo(DirectoryEntrySync parent, String name) native;

  void remove() native;

  String toURL() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class ErrorEvent extends Event native "*ErrorEvent" {

  String filename;

  int lineno;

  String message;

  void initErrorEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String messageArg, String filenameArg, int linenoArg) native;
}

class Event native "Event" {

  static final int AT_TARGET = 2;

  static final int BLUR = 8192;

  static final int BUBBLING_PHASE = 3;

  static final int CAPTURING_PHASE = 1;

  static final int CHANGE = 32768;

  static final int CLICK = 64;

  static final int DBLCLICK = 128;

  static final int DRAGDROP = 2048;

  static final int FOCUS = 4096;

  static final int KEYDOWN = 256;

  static final int KEYPRESS = 1024;

  static final int KEYUP = 512;

  static final int MOUSEDOWN = 1;

  static final int MOUSEDRAG = 32;

  static final int MOUSEMOVE = 16;

  static final int MOUSEOUT = 8;

  static final int MOUSEOVER = 4;

  static final int MOUSEUP = 2;

  static final int SELECT = 16384;

  bool bubbles;

  bool cancelBubble;

  bool cancelable;

  Clipboard clipboardData;

  EventTarget currentTarget;

  bool defaultPrevented;

  int eventPhase;

  bool returnValue;

  EventTarget srcElement;

  EventTarget target;

  int timeStamp;

  String type;

  void initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg) native;

  void preventDefault() native;

  void stopImmediatePropagation() native;

  void stopPropagation() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class EventException native "*EventException" {

  static final int DISPATCH_REQUEST_ERR = 1;

  static final int UNSPECIFIED_EVENT_TYPE_ERR = 0;

  int code;

  String message;

  String name;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class EventSource native "*EventSource" {

  static final int CLOSED = 2;

  static final int CONNECTING = 0;

  static final int OPEN = 1;

  String URL;

  int readyState;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void close() native;

  bool dispatchEvent(Event evt) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class EventTarget native "*EventTarget" {

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  bool dispatchEvent(Event event) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class File extends Blob native "*File" {

  String fileName;

  int fileSize;

  Date lastModifiedDate;

  String name;

  String webkitRelativePath;
}

class FileEntry extends Entry native "*FileEntry" {

  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback = null]) native;

  void file(FileCallback successCallback, [ErrorCallback errorCallback = null]) native;
}

class FileEntrySync extends EntrySync native "*FileEntrySync" {

  FileWriterSync createWriter() native;

  File file() native;
}

class FileError native "*FileError" {

  static final int ABORT_ERR = 3;

  static final int ENCODING_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 9;

  static final int INVALID_STATE_ERR = 7;

  static final int NOT_FOUND_ERR = 1;

  static final int NOT_READABLE_ERR = 4;

  static final int NO_MODIFICATION_ALLOWED_ERR = 6;

  static final int PATH_EXISTS_ERR = 12;

  static final int QUOTA_EXCEEDED_ERR = 10;

  static final int SECURITY_ERR = 2;

  static final int SYNTAX_ERR = 8;

  static final int TYPE_MISMATCH_ERR = 11;

  int code;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class FileException native "*FileException" {

  static final int ABORT_ERR = 3;

  static final int ENCODING_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 9;

  static final int INVALID_STATE_ERR = 7;

  static final int NOT_FOUND_ERR = 1;

  static final int NOT_READABLE_ERR = 4;

  static final int NO_MODIFICATION_ALLOWED_ERR = 6;

  static final int PATH_EXISTS_ERR = 12;

  static final int QUOTA_EXCEEDED_ERR = 10;

  static final int SECURITY_ERR = 2;

  static final int SYNTAX_ERR = 8;

  static final int TYPE_MISMATCH_ERR = 11;

  int code;

  String message;

  String name;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class FileList native "*FileList" {

  int length;

  File item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class FileReader native "*FileReader" {
  FileReader() native;


  static final int DONE = 2;

  static final int EMPTY = 0;

  static final int LOADING = 1;

  FileError error;

  EventListener onabort;

  EventListener onerror;

  EventListener onload;

  EventListener onloadend;

  EventListener onloadstart;

  EventListener onprogress;

  int readyState;

  Object result;

  void abort() native;

  void readAsArrayBuffer(Blob blob) native;

  void readAsBinaryString(Blob blob) native;

  void readAsDataURL(Blob blob) native;

  void readAsText(Blob blob, [String encoding = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class FileReaderSync native "*FileReaderSync" {

  ArrayBuffer readAsArrayBuffer(Blob blob) native;

  String readAsBinaryString(Blob blob) native;

  String readAsDataURL(Blob blob) native;

  String readAsText(Blob blob, [String encoding = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class FileWriter native "*FileWriter" {

  static final int DONE = 2;

  static final int INIT = 0;

  static final int WRITING = 1;

  FileError error;

  int length;

  EventListener onabort;

  EventListener onerror;

  EventListener onprogress;

  EventListener onwrite;

  EventListener onwriteend;

  EventListener onwritestart;

  int position;

  int readyState;

  void abort() native;

  void seek(int position) native;

  void truncate(int size) native;

  void write(Blob data) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class FileWriterSync native "*FileWriterSync" {

  int length;

  int position;

  void seek(int position) native;

  void truncate(int size) native;

  void write(Blob data) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Float32Array extends ArrayBufferView implements List<num> native "*Float32Array" {

  factory Float32Array(int length) =>  _construct(length);

  factory Float32Array.fromList(List<num> list) => _construct(list);

  factory Float32Array.fromBuffer(ArrayBuffer buffer) => _construct(buffer);

  static _construct(arg) native 'return new Float32Array(arg);';

  static final int BYTES_PER_ELEMENT = 4;

  int length;

  num operator[](int index) native;

  void operator[]=(int index, num value) native;

  Float32Array subarray(int start, [int end = null]) native;
}

class Float64Array extends ArrayBufferView implements List<num> native "*Float64Array" {

  factory Float64Array(int length) =>  _construct(length);

  factory Float64Array.fromList(List<num> list) => _construct(list);

  factory Float64Array.fromBuffer(ArrayBuffer buffer) => _construct(buffer);

  static _construct(arg) native 'return new Float64Array(arg);';

  static final int BYTES_PER_ELEMENT = 8;

  int length;

  num operator[](int index) native;

  void operator[]=(int index, num value) native;

  Float64Array subarray(int start, [int end = null]) native;
}

class Geolocation native "*Geolocation" {

  void clearWatch(int watchId) native;

  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback = null]) native;

  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Geoposition native "*Geoposition" {

  Coordinates coords;

  int timestamp;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class HTMLAllCollection native "*HTMLAllCollection" {

  int length;

  Node item(int index) native;

  Node namedItem(String name) native;

  NodeList tags(String name) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class HTMLAnchorElement extends HTMLElement native "*HTMLAnchorElement" {

  String accessKey;

  String charset;

  String coords;

  String download;

  String hash;

  String host;

  String hostname;

  String href;

  String hreflang;

  String name;

  String origin;

  String pathname;

  String ping;

  String port;

  String protocol;

  String rel;

  String rev;

  String search;

  String shape;

  String target;

  String text;

  String type;

  String getParameter(String name) native;

  String toString() native;
}

class HTMLAppletElement extends HTMLElement native "*HTMLAppletElement" {

  String align;

  String alt;

  String archive;

  String code;

  String codeBase;

  String height;

  String hspace;

  String name;

  String object;

  String vspace;

  String width;
}

class HTMLAreaElement extends HTMLElement native "*HTMLAreaElement" {

  String accessKey;

  String alt;

  String coords;

  String hash;

  String host;

  String hostname;

  String href;

  bool noHref;

  String pathname;

  String ping;

  String port;

  String protocol;

  String search;

  String shape;

  String target;
}

class HTMLAudioElement extends HTMLMediaElement native "*HTMLAudioElement" {
}

class HTMLBRElement extends HTMLElement native "*HTMLBRElement" {

  String clear;
}

class HTMLBaseElement extends HTMLElement native "*HTMLBaseElement" {

  String href;

  String target;
}

class HTMLBaseFontElement extends HTMLElement native "*HTMLBaseFontElement" {

  String color;

  String face;

  int size;
}

class HTMLBodyElement extends HTMLElement native "*HTMLBodyElement" {

  String aLink;

  String background;

  String bgColor;

  String link;

  String text;

  String vLink;
}

class HTMLButtonElement extends HTMLElement native "*HTMLButtonElement" {

  String accessKey;

  bool autofocus;

  bool disabled;

  HTMLFormElement form;

  String formAction;

  String formEnctype;

  String formMethod;

  bool formNoValidate;

  String formTarget;

  NodeList labels;

  String name;

  String type;

  String validationMessage;

  ValidityState validity;

  String value;

  bool willValidate;

  bool checkValidity() native;

  void click() native;

  void setCustomValidity(String error) native;
}

class HTMLCanvasElement extends HTMLElement native "*HTMLCanvasElement" {

  int height;

  int width;

  Object getContext(String contextId) native;

  String toDataURL(String type) native;
}

class HTMLCollection native "HTMLCollection" {

  int length;

  Node operator[](int index) native;

  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  Node item(int index) native;

  Node namedItem(String name) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class HTMLDListElement extends HTMLElement native "*HTMLDListElement" {

  bool compact;
}

class HTMLDataListElement extends HTMLElement native "*HTMLDataListElement" {

  HTMLCollection options;
}

class HTMLDetailsElement extends HTMLElement native "*HTMLDetailsElement" {

  bool open;
}

class HTMLDirectoryElement extends HTMLElement native "*HTMLDirectoryElement" {

  bool compact;
}

class HTMLDivElement extends HTMLElement native "*HTMLDivElement" {

  String align;
}

class HTMLDocument extends Document native "*HTMLDocument" {

  Element activeElement;

  String alinkColor;

  HTMLAllCollection all;

  String bgColor;

  String compatMode;

  String designMode;

  String dir;

  HTMLCollection embeds;

  String fgColor;

  int height;

  String linkColor;

  HTMLCollection plugins;

  HTMLCollection scripts;

  String vlinkColor;

  int width;

  void captureEvents() native;

  void clear() native;

  void close() native;

  bool hasFocus() native;

  void open() native;

  void releaseEvents() native;

  void write(String text) native;

  void writeln(String text) native;
}

class HTMLElement extends Element native "HTMLElement" {

  HTMLCollection children;

  DOMTokenList classList;

  String className;

  String contentEditable;

  String dir;

  bool draggable;

  bool hidden;

  String id;

  String innerHTML;

  String innerText;

  bool isContentEditable;

  String itemId;

  DOMSettableTokenList itemProp;

  DOMSettableTokenList itemRef;

  bool itemScope;

  DOMSettableTokenList itemType;

  Object itemValue;

  String lang;

  String outerHTML;

  String outerText;

  bool spellcheck;

  int tabIndex;

  String title;

  String webkitdropzone;

  Element insertAdjacentElement(String where, Element element) native;

  void insertAdjacentHTML(String where, String html) native;

  void insertAdjacentText(String where, String text) native;
}

class HTMLEmbedElement extends HTMLElement native "*HTMLEmbedElement" {

  String align;

  String height;

  String name;

  String src;

  String type;

  String width;

  SVGDocument getSVGDocument() native;
}

class HTMLFieldSetElement extends HTMLElement native "*HTMLFieldSetElement" {

  HTMLFormElement form;

  String validationMessage;

  ValidityState validity;

  bool willValidate;

  bool checkValidity() native;

  void setCustomValidity(String error) native;
}

class HTMLFontElement extends HTMLElement native "*HTMLFontElement" {

  String color;

  String face;

  String size;
}

class HTMLFormElement extends HTMLElement native "*HTMLFormElement" {

  String acceptCharset;

  String action;

  String autocomplete;

  HTMLCollection elements;

  String encoding;

  String enctype;

  int length;

  String method;

  String name;

  bool noValidate;

  String target;

  bool checkValidity() native;

  void reset() native;

  void submit() native;
}

class HTMLFrameElement extends HTMLElement native "*HTMLFrameElement" {

  Document contentDocument;

  DOMWindow contentWindow;

  String frameBorder;

  int height;

  String location;

  String longDesc;

  String marginHeight;

  String marginWidth;

  String name;

  bool noResize;

  String scrolling;

  String src;

  int width;

  SVGDocument getSVGDocument() native;
}

class HTMLFrameSetElement extends HTMLElement native "*HTMLFrameSetElement" {

  String cols;

  String rows;
}

class HTMLHRElement extends HTMLElement native "*HTMLHRElement" {

  String align;

  bool noShade;

  String size;

  String width;
}

class HTMLHeadElement extends HTMLElement native "*HTMLHeadElement" {

  String profile;
}

class HTMLHeadingElement extends HTMLElement native "*HTMLHeadingElement" {

  String align;
}

class HTMLHtmlElement extends HTMLElement native "*HTMLHtmlElement" {

  String manifest;

  String version;
}

class HTMLIFrameElement extends HTMLElement native "*HTMLIFrameElement" {

  String align;

  Document contentDocument;

  DOMWindow contentWindow;

  String frameBorder;

  String height;

  String longDesc;

  String marginHeight;

  String marginWidth;

  String name;

  String sandbox;

  String scrolling;

  String src;

  String width;

  SVGDocument getSVGDocument() native;
}

class HTMLImageElement extends HTMLElement native "*HTMLImageElement" {

  String align;

  String alt;

  String border;

  bool complete;

  String crossOrigin;

  int height;

  int hspace;

  bool isMap;

  String longDesc;

  String lowsrc;

  String name;

  int naturalHeight;

  int naturalWidth;

  String src;

  String useMap;

  int vspace;

  int width;

  int x;

  int y;
}

class HTMLInputElement extends HTMLElement native "HTMLInputElement" {

  String accept;

  String accessKey;

  String align;

  String alt;

  String autocomplete;

  bool autofocus;

  bool checked;

  bool defaultChecked;

  String defaultValue;

  bool disabled;

  FileList files;

  HTMLFormElement form;

  String formAction;

  String formEnctype;

  String formMethod;

  bool formNoValidate;

  String formTarget;

  bool incremental;

  bool indeterminate;

  NodeList labels;

  HTMLElement list;

  String max;

  int maxLength;

  String min;

  bool multiple;

  String name;

  String pattern;

  String placeholder;

  bool readOnly;

  bool required;

  HTMLOptionElement selectedOption;

  String selectionDirection;

  int selectionEnd;

  int selectionStart;

  int size;

  String src;

  String step;

  String type;

  String useMap;

  String validationMessage;

  ValidityState validity;

  String value;

  Date valueAsDate;

  num valueAsNumber;

  bool webkitGrammar;

  bool webkitSpeech;

  bool webkitdirectory;

  bool willValidate;

  bool checkValidity() native;

  void click() native;

  void select() native;

  void setCustomValidity(String error) native;

  void setSelectionRange(int start, int end, [String direction = null]) native;

  void stepDown([int n = null]) native;

  void stepUp([int n = null]) native;
}

class HTMLIsIndexElement extends HTMLInputElement native "*HTMLIsIndexElement" {

  HTMLFormElement form;

  String prompt;
}

class HTMLKeygenElement extends HTMLElement native "*HTMLKeygenElement" {

  bool autofocus;

  String challenge;

  bool disabled;

  HTMLFormElement form;

  String keytype;

  NodeList labels;

  String name;

  String type;

  String validationMessage;

  ValidityState validity;

  bool willValidate;

  bool checkValidity() native;

  void setCustomValidity(String error) native;
}

class HTMLLIElement extends HTMLElement native "*HTMLLIElement" {

  String type;

  int value;
}

class HTMLLabelElement extends HTMLElement native "*HTMLLabelElement" {

  String accessKey;

  HTMLElement control;

  HTMLFormElement form;

  String htmlFor;
}

class HTMLLegendElement extends HTMLElement native "*HTMLLegendElement" {

  String accessKey;

  String align;

  HTMLFormElement form;
}

class HTMLLinkElement extends HTMLElement native "*HTMLLinkElement" {

  String charset;

  bool disabled;

  String href;

  String hreflang;

  String media;

  String rel;

  String rev;

  StyleSheet sheet;

  DOMSettableTokenList sizes;

  String target;

  String type;
}

class HTMLMapElement extends HTMLElement native "*HTMLMapElement" {

  HTMLCollection areas;

  String name;
}

class HTMLMarqueeElement extends HTMLElement native "*HTMLMarqueeElement" {

  String behavior;

  String bgColor;

  String direction;

  String height;

  int hspace;

  int loop;

  int scrollAmount;

  int scrollDelay;

  bool trueSpeed;

  int vspace;

  String width;

  void start() native;

  void stop() native;
}

class HTMLMediaElement extends HTMLElement native "HTMLMediaElement" {

  static final int EOS_DECODE_ERR = 2;

  static final int EOS_NETWORK_ERR = 1;

  static final int EOS_NO_ERROR = 0;

  static final int HAVE_CURRENT_DATA = 2;

  static final int HAVE_ENOUGH_DATA = 4;

  static final int HAVE_FUTURE_DATA = 3;

  static final int HAVE_METADATA = 1;

  static final int HAVE_NOTHING = 0;

  static final int NETWORK_EMPTY = 0;

  static final int NETWORK_IDLE = 1;

  static final int NETWORK_LOADING = 2;

  static final int NETWORK_NO_SOURCE = 3;

  static final int SOURCE_CLOSED = 0;

  static final int SOURCE_ENDED = 2;

  static final int SOURCE_OPEN = 1;

  bool autoplay;

  TimeRanges buffered;

  bool controls;

  String currentSrc;

  num currentTime;

  bool defaultMuted;

  num defaultPlaybackRate;

  num duration;

  bool ended;

  MediaError error;

  num initialTime;

  bool loop;

  bool muted;

  int networkState;

  bool paused;

  num playbackRate;

  TimeRanges played;

  String preload;

  int readyState;

  TimeRanges seekable;

  bool seeking;

  String src;

  num startTime;

  num volume;

  int webkitAudioDecodedByteCount;

  bool webkitClosedCaptionsVisible;

  bool webkitHasClosedCaptions;

  String webkitMediaSourceURL;

  bool webkitPreservesPitch;

  int webkitSourceState;

  int webkitVideoDecodedByteCount;

  TextTrack addTrack(String kind, [String label = null, String language = null]) native;

  String canPlayType(String type) native;

  void load() native;

  void pause() native;

  void play() native;

  void webkitSourceAppend(Uint8Array data) native;

  void webkitSourceEndOfStream(int status) native;
}

class HTMLMenuElement extends HTMLElement native "*HTMLMenuElement" {

  bool compact;
}

class HTMLMetaElement extends HTMLElement native "*HTMLMetaElement" {

  String content;

  String httpEquiv;

  String name;

  String scheme;
}

class HTMLMeterElement extends HTMLElement native "*HTMLMeterElement" {

  HTMLFormElement form;

  num high;

  NodeList labels;

  num low;

  num max;

  num min;

  num optimum;

  num value;
}

class HTMLModElement extends HTMLElement native "*HTMLModElement" {

  String cite;

  String dateTime;
}

class HTMLOListElement extends HTMLElement native "*HTMLOListElement" {

  bool compact;

  int start;

  String type;
}

class HTMLObjectElement extends HTMLElement native "*HTMLObjectElement" {

  String align;

  String archive;

  String border;

  String code;

  String codeBase;

  String codeType;

  Document contentDocument;

  String data;

  bool declare;

  HTMLFormElement form;

  String height;

  int hspace;

  String name;

  String standby;

  String type;

  String useMap;

  String validationMessage;

  ValidityState validity;

  int vspace;

  String width;

  bool willValidate;

  bool checkValidity() native;

  SVGDocument getSVGDocument() native;

  void setCustomValidity(String error) native;
}

class HTMLOptGroupElement extends HTMLElement native "*HTMLOptGroupElement" {

  bool disabled;

  String label;
}

class HTMLOptionElement extends HTMLElement native "*HTMLOptionElement" {

  bool defaultSelected;

  bool disabled;

  HTMLFormElement form;

  int index;

  String label;

  bool selected;

  String text;

  String value;
}

class HTMLOptionsCollection extends HTMLCollection native "*HTMLOptionsCollection" {

  int length;

  int selectedIndex;

  void remove(int index) native;
}

class HTMLOutputElement extends HTMLElement native "*HTMLOutputElement" {

  String defaultValue;

  HTMLFormElement form;

  DOMSettableTokenList htmlFor;

  NodeList labels;

  String name;

  String type;

  String validationMessage;

  ValidityState validity;

  String value;

  bool willValidate;

  bool checkValidity() native;

  void setCustomValidity(String error) native;
}

class HTMLParagraphElement extends HTMLElement native "*HTMLParagraphElement" {

  String align;
}

class HTMLParamElement extends HTMLElement native "*HTMLParamElement" {

  String name;

  String type;

  String value;

  String valueType;
}

class HTMLPreElement extends HTMLElement native "*HTMLPreElement" {

  int width;

  bool wrap;
}

class HTMLProgressElement extends HTMLElement native "*HTMLProgressElement" {

  HTMLFormElement form;

  NodeList labels;

  num max;

  num position;

  num value;
}

class HTMLQuoteElement extends HTMLElement native "*HTMLQuoteElement" {

  String cite;
}

class HTMLScriptElement extends HTMLElement native "*HTMLScriptElement" {

  bool async;

  String charset;

  bool defer;

  String event;

  String htmlFor;

  String src;

  String text;

  String type;
}

class HTMLSelectElement extends HTMLElement native "*HTMLSelectElement" {

  bool autofocus;

  bool disabled;

  HTMLFormElement form;

  NodeList labels;

  int length;

  bool multiple;

  String name;

  HTMLOptionsCollection options;

  bool required;

  int selectedIndex;

  int size;

  String type;

  String validationMessage;

  ValidityState validity;

  String value;

  bool willValidate;

  void add(HTMLElement element, HTMLElement before) native;

  bool checkValidity() native;

  Node item(int index) native;

  Node namedItem(String name) native;

  void remove(var index_OR_option) native;

  void setCustomValidity(String error) native;
}

class HTMLSourceElement extends HTMLElement native "*HTMLSourceElement" {

  String media;

  String src;

  String type;
}

class HTMLSpanElement extends HTMLElement native "*HTMLSpanElement" {
}

class HTMLStyleElement extends HTMLElement native "*HTMLStyleElement" {

  bool disabled;

  String media;

  StyleSheet sheet;

  String type;
}

class HTMLTableCaptionElement extends HTMLElement native "*HTMLTableCaptionElement" {

  String align;
}

class HTMLTableCellElement extends HTMLElement native "*HTMLTableCellElement" {

  String abbr;

  String align;

  String axis;

  String bgColor;

  int cellIndex;

  String ch;

  String chOff;

  int colSpan;

  String headers;

  String height;

  bool noWrap;

  int rowSpan;

  String scope;

  String vAlign;

  String width;
}

class HTMLTableColElement extends HTMLElement native "*HTMLTableColElement" {

  String align;

  String ch;

  String chOff;

  int span;

  String vAlign;

  String width;
}

class HTMLTableElement extends HTMLElement native "*HTMLTableElement" {

  String align;

  String bgColor;

  String border;

  HTMLTableCaptionElement caption;

  String cellPadding;

  String cellSpacing;

  String frame;

  HTMLCollection rows;

  String rules;

  String summary;

  HTMLCollection tBodies;

  HTMLTableSectionElement tFoot;

  HTMLTableSectionElement tHead;

  String width;

  HTMLElement createCaption() native;

  HTMLElement createTFoot() native;

  HTMLElement createTHead() native;

  void deleteCaption() native;

  void deleteRow(int index) native;

  void deleteTFoot() native;

  void deleteTHead() native;

  HTMLElement insertRow(int index) native;
}

class HTMLTableRowElement extends HTMLElement native "*HTMLTableRowElement" {

  String align;

  String bgColor;

  HTMLCollection cells;

  String ch;

  String chOff;

  int rowIndex;

  int sectionRowIndex;

  String vAlign;

  void deleteCell(int index) native;

  HTMLElement insertCell(int index) native;
}

class HTMLTableSectionElement extends HTMLElement native "*HTMLTableSectionElement" {

  String align;

  String ch;

  String chOff;

  HTMLCollection rows;

  String vAlign;

  void deleteRow(int index) native;

  HTMLElement insertRow(int index) native;
}

class HTMLTextAreaElement extends HTMLElement native "*HTMLTextAreaElement" {

  String accessKey;

  bool autofocus;

  int cols;

  String defaultValue;

  bool disabled;

  HTMLFormElement form;

  NodeList labels;

  int maxLength;

  String name;

  String placeholder;

  bool readOnly;

  bool required;

  int rows;

  String selectionDirection;

  int selectionEnd;

  int selectionStart;

  int textLength;

  String type;

  String validationMessage;

  ValidityState validity;

  String value;

  bool willValidate;

  String wrap;

  bool checkValidity() native;

  void select() native;

  void setCustomValidity(String error) native;

  void setSelectionRange(int start, int end, [String direction = null]) native;
}

class HTMLTitleElement extends HTMLElement native "*HTMLTitleElement" {

  String text;
}

class HTMLTrackElement extends HTMLElement native "*HTMLTrackElement" {

  bool isDefault;

  String kind;

  String label;

  String src;

  String srclang;

  TextTrack track;
}

class HTMLUListElement extends HTMLElement native "*HTMLUListElement" {

  bool compact;

  String type;
}

class HTMLUnknownElement extends HTMLElement native "*HTMLUnknownElement" {
}

class HTMLVideoElement extends HTMLMediaElement native "*HTMLVideoElement" {

  int height;

  String poster;

  int videoHeight;

  int videoWidth;

  int webkitDecodedFrameCount;

  bool webkitDisplayingFullscreen;

  int webkitDroppedFrameCount;

  bool webkitSupportsFullscreen;

  int width;

  void webkitEnterFullScreen() native;

  void webkitEnterFullscreen() native;

  void webkitExitFullScreen() native;

  void webkitExitFullscreen() native;
}

class HashChangeEvent extends Event native "*HashChangeEvent" {

  String newURL;

  String oldURL;

  void initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL) native;
}

class HighPass2FilterNode extends AudioNode native "*HighPass2FilterNode" {

  AudioParam cutoff;

  AudioParam resonance;
}

class History native "*History" {

  int length;

  void back() native;

  void forward() native;

  void go(int distance) native;

  void pushState(Object data, String title, [String url = null]) native;

  void replaceState(Object data, String title, [String url = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBAny native "*IDBAny" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBCursor native "*IDBCursor" {

  static final int NEXT = 0;

  static final int NEXT_NO_DUPLICATE = 1;

  static final int PREV = 2;

  static final int PREV_NO_DUPLICATE = 3;

  int direction;

  IDBKey key;

  IDBKey primaryKey;

  IDBAny source;

  void continueFunction([IDBKey key = null]) native;

  IDBRequest delete() native;

  IDBRequest update(String value) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBCursorWithValue extends IDBCursor native "*IDBCursorWithValue" {

  IDBAny value;
}

class IDBDatabase native "*IDBDatabase" {

  String name;

  EventListener onabort;

  EventListener onerror;

  EventListener onversionchange;

  String version;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void close() native;

  IDBObjectStore createObjectStore(String name) native;

  void deleteObjectStore(String name) native;

  bool dispatchEvent(Event evt) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  IDBVersionChangeRequest setVersion(String version) native;

  IDBTransaction transaction(String storeName, int mode) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBDatabaseError native "*IDBDatabaseError" {

  int code;

  String message;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBDatabaseException native "*IDBDatabaseException" {

  static final int ABORT_ERR = 13;

  static final int CONSTRAINT_ERR = 4;

  static final int DATA_ERR = 5;

  static final int DEADLOCK_ERR = 11;

  static final int NON_TRANSIENT_ERR = 2;

  static final int NOT_ALLOWED_ERR = 6;

  static final int NOT_FOUND_ERR = 3;

  static final int NO_ERR = 0;

  static final int READ_ONLY_ERR = 12;

  static final int RECOVERABLE_ERR = 8;

  static final int SERIAL_ERR = 7;

  static final int TIMEOUT_ERR = 10;

  static final int TRANSIENT_ERR = 9;

  static final int UNKNOWN_ERR = 1;

  int code;

  String message;

  String name;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBFactory native "*IDBFactory" {

  int cmp(IDBKey first, IDBKey second) native;

  IDBVersionChangeRequest deleteDatabase(String name) native;

  IDBRequest getDatabaseNames() native;

  IDBRequest open(String name) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBIndex native "*IDBIndex" {

  String keyPath;

  String name;

  IDBObjectStore objectStore;

  bool unique;

  IDBRequest getObject(IDBKey key) native;

  IDBRequest getKey(IDBKey key) native;

  IDBRequest openCursor([IDBKeyRange range = null, int direction = null]) native;

  IDBRequest openKeyCursor([IDBKeyRange range = null, int direction = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBKey native "*IDBKey" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBKeyRange native "*IDBKeyRange" {

  IDBKey lower;

  bool lowerOpen;

  IDBKey upper;

  bool upperOpen;

  IDBKeyRange bound(IDBKey lower, IDBKey upper, [bool lowerOpen = null, bool upperOpen = null]) native;

  IDBKeyRange lowerBound(IDBKey bound, [bool open = null]) native;

  IDBKeyRange only(IDBKey value) native;

  IDBKeyRange upperBound(IDBKey bound, [bool open = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBObjectStore native "*IDBObjectStore" {

  String keyPath;

  String name;

  IDBTransaction transaction;

  IDBRequest add(String value, [IDBKey key = null]) native;

  IDBRequest clear() native;

  IDBIndex createIndex(String name, String keyPath) native;

  IDBRequest delete(IDBKey key) native;

  void deleteIndex(String name) native;

  IDBRequest getObject(IDBKey key) native;

  IDBIndex index(String name) native;

  IDBRequest openCursor([IDBKeyRange range = null, int direction = null]) native;

  IDBRequest put(String value, [IDBKey key = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBRequest native "*IDBRequest" {

  static final int DONE = 2;

  static final int LOADING = 1;

  int errorCode;

  EventListener onerror;

  EventListener onsuccess;

  int readyState;

  IDBAny result;

  IDBAny source;

  IDBTransaction transaction;

  String webkitErrorMessage;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  bool dispatchEvent(Event evt) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBTransaction native "*IDBTransaction" {

  static final int READ_ONLY = 0;

  static final int READ_WRITE = 1;

  static final int VERSION_CHANGE = 2;

  IDBDatabase db;

  int mode;

  EventListener onabort;

  EventListener oncomplete;

  EventListener onerror;

  void abort() native;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  bool dispatchEvent(Event evt) native;

  IDBObjectStore objectStore(String name) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class IDBVersionChangeEvent extends Event native "*IDBVersionChangeEvent" {

  String version;
}

class IDBVersionChangeRequest extends IDBRequest native "*IDBVersionChangeRequest" {

  EventListener onblocked;
}

class ImageData native "*ImageData" {

  CanvasPixelArray data;

  int height;

  int width;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class InjectedScriptHost native "*InjectedScriptHost" {

  void clearConsoleMessages() native;

  void copyText(String text) native;

  int databaseId(Object database) native;

  void didCreateWorker(int id, String url, bool isFakeWorker) native;

  void didDestroyWorker(int id) native;

  Object evaluate(String text) native;

  void inspect(Object objectId, Object hints) native;

  Object inspectedNode(int num) native;

  Object internalConstructorName(Object object) native;

  bool isHTMLAllCollection(Object object) native;

  int nextWorkerId() native;

  int storageId(Object storage) native;

  String type(Object object) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class InspectorFrontendHost native "*InspectorFrontendHost" {

  void bringToFront() native;

  void closeWindow() native;

  void copyText(String text) native;

  void disconnectFromBackend() native;

  String hiddenPanels() native;

  void inspectedURLChanged(String newURL) native;

  void loaded() native;

  String localizedStringsURL() native;

  void moveWindowBy(num x, num y) native;

  String platform() native;

  String port() native;

  void recordActionTaken(int actionCode) native;

  void recordPanelShown(int panelCode) native;

  void recordSettingChanged(int settingChanged) native;

  void requestAttachWindow() native;

  void requestDetachWindow() native;

  void saveAs(String fileName, String content) native;

  void sendMessageToBackend(String message) native;

  void setAttachedWindowHeight(int height) native;

  void setExtensionAPI(String script) native;

  void showContextMenu(MouseEvent event, Object items) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Int16Array extends ArrayBufferView implements List<int> native "*Int16Array" {

  factory Int16Array(int length) =>  _construct(length);

  factory Int16Array.fromList(List<int> list) => _construct(list);

  factory Int16Array.fromBuffer(ArrayBuffer buffer) => _construct(buffer);

  static _construct(arg) native 'return new Int16Array(arg);';

  static final int BYTES_PER_ELEMENT = 2;

  int length;

  int operator[](int index) native;

  void operator[]=(int index, int value) native;

  Int16Array subarray(int start, [int end = null]) native;
}

class Int32Array extends ArrayBufferView implements List<int> native "*Int32Array" {

  factory Int32Array(int length) =>  _construct(length);

  factory Int32Array.fromList(List<int> list) => _construct(list);

  factory Int32Array.fromBuffer(ArrayBuffer buffer) => _construct(buffer);

  static _construct(arg) native 'return new Int32Array(arg);';

  static final int BYTES_PER_ELEMENT = 4;

  int length;

  int operator[](int index) native;

  void operator[]=(int index, int value) native;

  Int32Array subarray(int start, [int end = null]) native;
}

class Int8Array extends ArrayBufferView implements List<int> native "*Int8Array" {

  factory Int8Array(int length) =>  _construct(length);

  factory Int8Array.fromList(List<int> list) => _construct(list);

  factory Int8Array.fromBuffer(ArrayBuffer buffer) => _construct(buffer);

  static _construct(arg) native 'return new Int8Array(arg);';

  static final int BYTES_PER_ELEMENT = 1;

  int length;

  int operator[](int index) native;

  void operator[]=(int index, int value) native;

  Int8Array subarray(int start, [int end = null]) native;
}

class JavaScriptAudioNode extends AudioNode native "*JavaScriptAudioNode" {

  int bufferSize;

  EventListener onaudioprocess;
}

class JavaScriptCallFrame native "*JavaScriptCallFrame" {

  static final int CATCH_SCOPE = 4;

  static final int CLOSURE_SCOPE = 3;

  static final int GLOBAL_SCOPE = 0;

  static final int LOCAL_SCOPE = 1;

  static final int WITH_SCOPE = 2;

  JavaScriptCallFrame caller;

  int column;

  String functionName;

  int line;

  List scopeChain;

  int sourceID;

  String type;

  void evaluate(String script) native;

  int scopeType(int scopeIndex) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class KeyboardEvent extends UIEvent native "*KeyboardEvent" {

  bool altGraphKey;

  bool altKey;

  bool ctrlKey;

  String keyIdentifier;

  int keyLocation;

  bool metaKey;

  bool shiftKey;

  void initKeyboardEvent(String type, bool canBubble, bool cancelable, DOMWindow view, String keyIdentifier, int keyLocation, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey) native;
}

class Location native "*Location" {

  String hash;

  String host;

  String hostname;

  String href;

  String origin;

  String pathname;

  String port;

  String protocol;

  String search;

  void assign(String url) native;

  String getParameter(String name) native;

  void reload() native;

  void replace(String url) native;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class LowPass2FilterNode extends AudioNode native "*LowPass2FilterNode" {

  AudioParam cutoff;

  AudioParam resonance;
}

class MediaElementAudioSourceNode extends AudioSourceNode native "*MediaElementAudioSourceNode" {

  HTMLMediaElement mediaElement;
}

class MediaError native "*MediaError" {

  static final int MEDIA_ERR_ABORTED = 1;

  static final int MEDIA_ERR_DECODE = 3;

  static final int MEDIA_ERR_NETWORK = 2;

  static final int MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

  int code;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class MediaList native "*MediaList" {

  int length;

  String mediaText;

  String operator[](int index) native;

  void operator[]=(int index, String value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void appendMedium(String newMedium) native;

  void deleteMedium(String oldMedium) native;

  String item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class MediaQueryList native "*MediaQueryList" {

  bool matches;

  String media;

  void addListener(MediaQueryListListener listener) native;

  void removeListener(MediaQueryListListener listener) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class MediaQueryListListener native "*MediaQueryListListener" {

  void queryChanged(MediaQueryList list) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class MemoryInfo native "*MemoryInfo" {

  int jsHeapSizeLimit;

  int totalJSHeapSize;

  int usedJSHeapSize;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class MessageChannel native "*MessageChannel" {

  MessagePort port1;

  MessagePort port2;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class MessageEvent extends Event native "*MessageEvent" {

  Object data;

  String lastEventId;

  String origin;

  List ports;

  DOMWindow source;

  void initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, DOMWindow sourceArg, List messagePorts) native;

  void webkitInitMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, DOMWindow sourceArg, List transferables) native;
}

class MessagePort native "*MessagePort" {

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void close() native;

  bool dispatchEvent(Event evt) native;

  void postMessage(String message, [List messagePorts = null]) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void start() native;

  void webkitPostMessage(String message, [List transfer = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Metadata native "*Metadata" {

  Date modificationTime;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class MouseEvent extends UIEvent native "*MouseEvent" {

  bool altKey;

  int button;

  int clientX;

  int clientY;

  bool ctrlKey;

  Clipboard dataTransfer;

  Node fromElement;

  bool metaKey;

  int offsetX;

  int offsetY;

  EventTarget relatedTarget;

  int screenX;

  int screenY;

  bool shiftKey;

  Node toElement;

  int x;

  int y;

  void initMouseEvent(String type, bool canBubble, bool cancelable, DOMWindow view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget) native;
}

class MutationCallback native "*MutationCallback" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class MutationEvent extends Event native "*MutationEvent" {

  static final int ADDITION = 2;

  static final int MODIFICATION = 1;

  static final int REMOVAL = 3;

  int attrChange;

  String attrName;

  String newValue;

  String prevValue;

  Node relatedNode;

  void initMutationEvent(String type, bool canBubble, bool cancelable, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange) native;
}

class MutationRecord native "*MutationRecord" {

  NodeList addedNodes;

  String attributeName;

  String attributeNamespace;

  Node nextSibling;

  String oldValue;

  Node previousSibling;

  NodeList removedNodes;

  Node target;

  String type;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class NamedNodeMap native "*NamedNodeMap" {

  int length;

  Node operator[](int index) native;

  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  Node getNamedItem(String name) native;

  Node getNamedItemNS(String namespaceURI, String localName) native;

  Node item(int index) native;

  Node removeNamedItem(String name) native;

  Node removeNamedItemNS(String namespaceURI, String localName) native;

  Node setNamedItem(Node node) native;

  Node setNamedItemNS(Node node) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Navigator native "*Navigator" {

  String appCodeName;

  String appName;

  String appVersion;

  bool cookieEnabled;

  Geolocation geolocation;

  String language;

  DOMMimeTypeArray mimeTypes;

  bool onLine;

  String platform;

  DOMPluginArray plugins;

  String product;

  String productSub;

  String userAgent;

  String vendor;

  String vendorSub;

  void getStorageUpdates() native;

  bool javaEnabled() native;

  void registerProtocolHandler(String scheme, String url, String title) native;

  void webkitGetUserMedia(String options, NavigatorUserMediaSuccessCallback successCallback, [NavigatorUserMediaErrorCallback errorCallback = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class NavigatorUserMediaError native "*NavigatorUserMediaError" {

  static final int PERMISSION_DENIED = 1;

  int code;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class NavigatorUserMediaSuccessCallback native "*NavigatorUserMediaSuccessCallback" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Node native "Node" {

  static final int ATTRIBUTE_NODE = 2;

  static final int CDATA_SECTION_NODE = 4;

  static final int COMMENT_NODE = 8;

  static final int DOCUMENT_FRAGMENT_NODE = 11;

  static final int DOCUMENT_NODE = 9;

  static final int DOCUMENT_POSITION_CONTAINED_BY = 0x10;

  static final int DOCUMENT_POSITION_CONTAINS = 0x08;

  static final int DOCUMENT_POSITION_DISCONNECTED = 0x01;

  static final int DOCUMENT_POSITION_FOLLOWING = 0x04;

  static final int DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

  static final int DOCUMENT_POSITION_PRECEDING = 0x02;

  static final int DOCUMENT_TYPE_NODE = 10;

  static final int ELEMENT_NODE = 1;

  static final int ENTITY_NODE = 6;

  static final int ENTITY_REFERENCE_NODE = 5;

  static final int NOTATION_NODE = 12;

  static final int PROCESSING_INSTRUCTION_NODE = 7;

  static final int TEXT_NODE = 3;

  NamedNodeMap attributes;

  String baseURI;

  NodeList childNodes;

  Node firstChild;

  Node lastChild;

  String localName;

  String namespaceURI;

  Node nextSibling;

  String nodeName;

  int nodeType;

  String nodeValue;

  Document ownerDocument;

  Element parentElement;

  Node parentNode;

  String prefix;

  Node previousSibling;

  String textContent;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  Node appendChild(Node newChild) native;

  Node cloneNode(bool deep) native;

  int compareDocumentPosition(Node other) native;

  bool contains(Node other) native;

  bool dispatchEvent(Event event) native;

  bool hasAttributes() native;

  bool hasChildNodes() native;

  Node insertBefore(Node newChild, Node refChild) native;

  bool isDefaultNamespace(String namespaceURI) native;

  bool isEqualNode(Node other) native;

  bool isSameNode(Node other) native;

  bool isSupported(String feature, String version) native;

  String lookupNamespaceURI(String prefix) native;

  String lookupPrefix(String namespaceURI) native;

  void normalize() native;

  Node removeChild(Node oldChild) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  Node replaceChild(Node newChild, Node oldChild) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class NodeFilter native "*NodeFilter" {

  static final int FILTER_ACCEPT = 1;

  static final int FILTER_REJECT = 2;

  static final int FILTER_SKIP = 3;

  static final int SHOW_ALL = 0xFFFFFFFF;

  static final int SHOW_ATTRIBUTE = 0x00000002;

  static final int SHOW_CDATA_SECTION = 0x00000008;

  static final int SHOW_COMMENT = 0x00000080;

  static final int SHOW_DOCUMENT = 0x00000100;

  static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400;

  static final int SHOW_DOCUMENT_TYPE = 0x00000200;

  static final int SHOW_ELEMENT = 0x00000001;

  static final int SHOW_ENTITY = 0x00000020;

  static final int SHOW_ENTITY_REFERENCE = 0x00000010;

  static final int SHOW_NOTATION = 0x00000800;

  static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040;

  static final int SHOW_TEXT = 0x00000004;

  int acceptNode(Node n) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class NodeIterator native "*NodeIterator" {

  bool expandEntityReferences;

  NodeFilter filter;

  bool pointerBeforeReferenceNode;

  Node referenceNode;

  Node root;

  int whatToShow;

  void detach() native;

  Node nextNode() native;

  Node previousNode() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class NodeList native "*NodeList" {

  int length;

  Node operator[](int index) native;

  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  Node item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class NodeSelector native "*NodeSelector" {

  Element querySelector(String selectors) native;

  NodeList querySelectorAll(String selectors) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Notation extends Node native "*Notation" {

  String publicId;

  String systemId;
}

class Notification native "*Notification" {

  String dir;

  String replaceId;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void cancel() native;

  bool dispatchEvent(Event evt) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void show() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class NotificationCenter native "*NotificationCenter" {

  int checkPermission() native;

  Notification createHTMLNotification(String url) native;

  Notification createNotification(String iconUrl, String title, String body) native;

  void requestPermission(VoidCallback callback) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class OESStandardDerivatives native "*OESStandardDerivatives" {

  static final int FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class OESTextureFloat native "*OESTextureFloat" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class OESVertexArrayObject native "*OESVertexArrayObject" {

  static final int VERTEX_ARRAY_BINDING_OES = 0x85B5;

  void bindVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) native;

  WebGLVertexArrayObjectOES createVertexArrayOES() native;

  void deleteVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) native;

  bool isVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class OfflineAudioCompletionEvent extends Event native "*OfflineAudioCompletionEvent" {

  AudioBuffer renderedBuffer;
}

class OperationNotAllowedException native "*OperationNotAllowedException" {

  static final int NOT_ALLOWED_ERR = 1;

  int code;

  String message;

  String name;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class OverflowEvent extends Event native "*OverflowEvent" {

  static final int BOTH = 2;

  static final int HORIZONTAL = 0;

  static final int VERTICAL = 1;

  bool horizontalOverflow;

  int orient;

  bool verticalOverflow;

  void initOverflowEvent(int orient, bool horizontalOverflow, bool verticalOverflow) native;
}

class PageTransitionEvent extends Event native "*PageTransitionEvent" {

  bool persisted;

  void initPageTransitionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, bool persisted) native;
}

class Performance native "*Performance" {

  MemoryInfo memory;

  PerformanceNavigation navigation;

  PerformanceTiming timing;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class PerformanceNavigation native "*PerformanceNavigation" {

  static final int TYPE_BACK_FORWARD = 2;

  static final int TYPE_NAVIGATE = 0;

  static final int TYPE_RELOAD = 1;

  static final int TYPE_RESERVED = 255;

  int redirectCount;

  int type;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class PerformanceTiming native "*PerformanceTiming" {

  int connectEnd;

  int connectStart;

  int domComplete;

  int domContentLoadedEventEnd;

  int domContentLoadedEventStart;

  int domInteractive;

  int domLoading;

  int domainLookupEnd;

  int domainLookupStart;

  int fetchStart;

  int loadEventEnd;

  int loadEventStart;

  int navigationStart;

  int redirectEnd;

  int redirectStart;

  int requestStart;

  int responseEnd;

  int responseStart;

  int secureConnectionStart;

  int unloadEventEnd;

  int unloadEventStart;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class PopStateEvent extends Event native "*PopStateEvent" {

  Object state;

  void initPopStateEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object stateArg) native;
}

class PositionError native "*PositionError" {

  static final int PERMISSION_DENIED = 1;

  static final int POSITION_UNAVAILABLE = 2;

  static final int TIMEOUT = 3;

  int code;

  String message;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class ProcessingInstruction extends Node native "*ProcessingInstruction" {

  String data;

  StyleSheet sheet;

  String target;
}

class ProgressEvent extends Event native "*ProgressEvent" {

  bool lengthComputable;

  int loaded;

  int total;

  void initProgressEvent(String typeArg, bool canBubbleArg, bool cancelableArg, bool lengthComputableArg, int loadedArg, int totalArg) native;
}

class RGBColor native "*RGBColor" {

  CSSPrimitiveValue blue;

  CSSPrimitiveValue green;

  CSSPrimitiveValue red;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Range native "*Range" {

  static final int END_TO_END = 2;

  static final int END_TO_START = 3;

  static final int NODE_AFTER = 1;

  static final int NODE_BEFORE = 0;

  static final int NODE_BEFORE_AND_AFTER = 2;

  static final int NODE_INSIDE = 3;

  static final int START_TO_END = 1;

  static final int START_TO_START = 0;

  bool collapsed;

  Node commonAncestorContainer;

  Node endContainer;

  int endOffset;

  Node startContainer;

  int startOffset;

  DocumentFragment cloneContents() native;

  Range cloneRange() native;

  void collapse(bool toStart) native;

  int compareNode(Node refNode) native;

  int comparePoint(Node refNode, int offset) native;

  DocumentFragment createContextualFragment(String html) native;

  void deleteContents() native;

  void detach() native;

  void expand(String unit) native;

  DocumentFragment extractContents() native;

  ClientRect getBoundingClientRect() native;

  ClientRectList getClientRects() native;

  void insertNode(Node newNode) native;

  bool intersectsNode(Node refNode) native;

  bool isPointInRange(Node refNode, int offset) native;

  void selectNode(Node refNode) native;

  void selectNodeContents(Node refNode) native;

  void setEnd(Node refNode, int offset) native;

  void setEndAfter(Node refNode) native;

  void setEndBefore(Node refNode) native;

  void setStart(Node refNode, int offset) native;

  void setStartAfter(Node refNode) native;

  void setStartBefore(Node refNode) native;

  void surroundContents(Node newParent) native;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class RangeException native "*RangeException" {

  static final int BAD_BOUNDARYPOINTS_ERR = 1;

  static final int INVALID_NODE_TYPE_ERR = 2;

  int code;

  String message;

  String name;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class RealtimeAnalyserNode extends AudioNode native "*RealtimeAnalyserNode" {

  int fftSize;

  int frequencyBinCount;

  num maxDecibels;

  num minDecibels;

  num smoothingTimeConstant;

  void getByteFrequencyData(Uint8Array array) native;

  void getByteTimeDomainData(Uint8Array array) native;

  void getFloatFrequencyData(Float32Array array) native;
}

class Rect native "*Rect" {

  CSSPrimitiveValue bottom;

  CSSPrimitiveValue left;

  CSSPrimitiveValue right;

  CSSPrimitiveValue top;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SQLError native "*SQLError" {

  static final int CONSTRAINT_ERR = 6;

  static final int DATABASE_ERR = 1;

  static final int QUOTA_ERR = 4;

  static final int SYNTAX_ERR = 5;

  static final int TIMEOUT_ERR = 7;

  static final int TOO_LARGE_ERR = 3;

  static final int UNKNOWN_ERR = 0;

  static final int VERSION_ERR = 2;

  int code;

  String message;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SQLException native "*SQLException" {

  static final int CONSTRAINT_ERR = 6;

  static final int DATABASE_ERR = 1;

  static final int QUOTA_ERR = 4;

  static final int SYNTAX_ERR = 5;

  static final int TIMEOUT_ERR = 7;

  static final int TOO_LARGE_ERR = 3;

  static final int UNKNOWN_ERR = 0;

  static final int VERSION_ERR = 2;

  int code;

  String message;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SQLResultSet native "*SQLResultSet" {

  int insertId;

  SQLResultSetRowList rows;

  int rowsAffected;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SQLResultSetRowList native "*SQLResultSetRowList" {

  int length;

  Object item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SQLTransaction native "*SQLTransaction" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SQLTransactionSync native "*SQLTransactionSync" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAElement extends SVGElement native "*SVGAElement" {

  SVGAnimatedString target;

  // From SVGURIReference

  SVGAnimatedString href;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGAltGlyphDefElement extends SVGElement native "*SVGAltGlyphDefElement" {
}

class SVGAltGlyphElement extends SVGTextPositioningElement native "*SVGAltGlyphElement" {

  String format;

  String glyphRef;

  // From SVGURIReference

  SVGAnimatedString href;
}

class SVGAltGlyphItemElement extends SVGElement native "*SVGAltGlyphItemElement" {
}

class SVGAngle native "*SVGAngle" {

  static final int SVG_ANGLETYPE_DEG = 2;

  static final int SVG_ANGLETYPE_GRAD = 4;

  static final int SVG_ANGLETYPE_RAD = 3;

  static final int SVG_ANGLETYPE_UNKNOWN = 0;

  static final int SVG_ANGLETYPE_UNSPECIFIED = 1;

  int unitType;

  num value;

  String valueAsString;

  num valueInSpecifiedUnits;

  void convertToSpecifiedUnits(int unitType) native;

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimateColorElement extends SVGAnimationElement native "*SVGAnimateColorElement" {
}

class SVGAnimateElement extends SVGAnimationElement native "*SVGAnimateElement" {
}

class SVGAnimateMotionElement extends SVGAnimationElement native "*SVGAnimateMotionElement" {
}

class SVGAnimateTransformElement extends SVGAnimationElement native "*SVGAnimateTransformElement" {
}

class SVGAnimatedAngle native "*SVGAnimatedAngle" {

  SVGAngle animVal;

  SVGAngle baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimatedBoolean native "*SVGAnimatedBoolean" {

  bool animVal;

  bool baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimatedEnumeration native "*SVGAnimatedEnumeration" {

  int animVal;

  int baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimatedInteger native "*SVGAnimatedInteger" {

  int animVal;

  int baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimatedLength native "*SVGAnimatedLength" {

  SVGLength animVal;

  SVGLength baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimatedLengthList native "*SVGAnimatedLengthList" {

  SVGLengthList animVal;

  SVGLengthList baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimatedNumber native "*SVGAnimatedNumber" {

  num animVal;

  num baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimatedNumberList native "*SVGAnimatedNumberList" {

  SVGNumberList animVal;

  SVGNumberList baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimatedPreserveAspectRatio native "*SVGAnimatedPreserveAspectRatio" {

  SVGPreserveAspectRatio animVal;

  SVGPreserveAspectRatio baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimatedRect native "*SVGAnimatedRect" {

  SVGRect animVal;

  SVGRect baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimatedString native "*SVGAnimatedString" {

  String animVal;

  String baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimatedTransformList native "*SVGAnimatedTransformList" {

  SVGTransformList animVal;

  SVGTransformList baseVal;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGAnimationElement extends SVGElement native "*SVGAnimationElement" {

  SVGElement targetElement;

  num getCurrentTime() native;

  num getSimpleDuration() native;

  num getStartTime() native;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From ElementTimeControl

  void beginElement() native;

  void beginElementAt(num offset) native;

  void endElement() native;

  void endElementAt(num offset) native;
}

class SVGCircleElement extends SVGElement native "*SVGCircleElement" {

  SVGAnimatedLength cx;

  SVGAnimatedLength cy;

  SVGAnimatedLength r;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGClipPathElement extends SVGElement native "*SVGClipPathElement" {

  SVGAnimatedEnumeration clipPathUnits;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGColor extends CSSValue native "*SVGColor" {

  static final int SVG_COLORTYPE_CURRENTCOLOR = 3;

  static final int SVG_COLORTYPE_RGBCOLOR = 1;

  static final int SVG_COLORTYPE_RGBCOLOR_ICCCOLOR = 2;

  static final int SVG_COLORTYPE_UNKNOWN = 0;

  int colorType;

  RGBColor rgbColor;

  void setColor(int colorType, String rgbColor, String iccColor) native;

  void setRGBColor(String rgbColor) native;

  void setRGBColorICCColor(String rgbColor, String iccColor) native;
}

class SVGComponentTransferFunctionElement extends SVGElement native "*SVGComponentTransferFunctionElement" {

  static final int SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE = 3;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_GAMMA = 5;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY = 1;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_LINEAR = 4;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_TABLE = 2;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN = 0;

  SVGAnimatedNumber amplitude;

  SVGAnimatedNumber exponent;

  SVGAnimatedNumber intercept;

  SVGAnimatedNumber offset;

  SVGAnimatedNumber slope;

  SVGAnimatedNumberList tableValues;

  SVGAnimatedEnumeration type;
}

class SVGCursorElement extends SVGElement native "*SVGCursorElement" {

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGURIReference

  SVGAnimatedString href;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;
}

class SVGDefsElement extends SVGElement native "*SVGDefsElement" {

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGDescElement extends SVGElement native "*SVGDescElement" {

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGDocument extends Document native "*SVGDocument" {

  SVGSVGElement rootElement;

  Event createEvent(String eventType) native;
}

class SVGElement extends Element native "SVGElement" {

  String id;

  SVGSVGElement ownerSVGElement;

  SVGElement viewportElement;

  String xmlbase;
}

class SVGElementInstance native "*SVGElementInstance" {

  SVGElementInstanceList childNodes;

  SVGElement correspondingElement;

  SVGUseElement correspondingUseElement;

  SVGElementInstance firstChild;

  SVGElementInstance lastChild;

  SVGElementInstance nextSibling;

  SVGElementInstance parentNode;

  SVGElementInstance previousSibling;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  bool dispatchEvent(Event event) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGElementInstanceList native "*SVGElementInstanceList" {

  int length;

  SVGElementInstance item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGEllipseElement extends SVGElement native "*SVGEllipseElement" {

  SVGAnimatedLength cx;

  SVGAnimatedLength cy;

  SVGAnimatedLength rx;

  SVGAnimatedLength ry;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGException native "*SVGException" {

  static final int SVG_INVALID_VALUE_ERR = 1;

  static final int SVG_MATRIX_NOT_INVERTABLE = 2;

  static final int SVG_WRONG_TYPE_ERR = 0;

  int code;

  String message;

  String name;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGExternalResourcesRequired native "*SVGExternalResourcesRequired" {

  SVGAnimatedBoolean externalResourcesRequired;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGFEBlendElement extends SVGElement native "*SVGFEBlendElement" {

  static final int SVG_FEBLEND_MODE_DARKEN = 4;

  static final int SVG_FEBLEND_MODE_LIGHTEN = 5;

  static final int SVG_FEBLEND_MODE_MULTIPLY = 2;

  static final int SVG_FEBLEND_MODE_NORMAL = 1;

  static final int SVG_FEBLEND_MODE_SCREEN = 3;

  static final int SVG_FEBLEND_MODE_UNKNOWN = 0;

  SVGAnimatedString in1;

  SVGAnimatedString in2;

  SVGAnimatedEnumeration mode;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEColorMatrixElement extends SVGElement native "*SVGFEColorMatrixElement" {

  static final int SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3;

  static final int SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4;

  static final int SVG_FECOLORMATRIX_TYPE_MATRIX = 1;

  static final int SVG_FECOLORMATRIX_TYPE_SATURATE = 2;

  static final int SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0;

  SVGAnimatedString in1;

  SVGAnimatedEnumeration type;

  SVGAnimatedNumberList values;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEComponentTransferElement extends SVGElement native "*SVGFEComponentTransferElement" {

  SVGAnimatedString in1;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFECompositeElement extends SVGElement native "*SVGFECompositeElement" {

  static final int SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6;

  static final int SVG_FECOMPOSITE_OPERATOR_ATOP = 4;

  static final int SVG_FECOMPOSITE_OPERATOR_IN = 2;

  static final int SVG_FECOMPOSITE_OPERATOR_OUT = 3;

  static final int SVG_FECOMPOSITE_OPERATOR_OVER = 1;

  static final int SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0;

  static final int SVG_FECOMPOSITE_OPERATOR_XOR = 5;

  SVGAnimatedString in1;

  SVGAnimatedString in2;

  SVGAnimatedNumber k1;

  SVGAnimatedNumber k2;

  SVGAnimatedNumber k3;

  SVGAnimatedNumber k4;

  SVGAnimatedEnumeration operator;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEConvolveMatrixElement extends SVGElement native "*SVGFEConvolveMatrixElement" {

  static final int SVG_EDGEMODE_DUPLICATE = 1;

  static final int SVG_EDGEMODE_NONE = 3;

  static final int SVG_EDGEMODE_UNKNOWN = 0;

  static final int SVG_EDGEMODE_WRAP = 2;

  SVGAnimatedNumber bias;

  SVGAnimatedNumber divisor;

  SVGAnimatedEnumeration edgeMode;

  SVGAnimatedString in1;

  SVGAnimatedNumberList kernelMatrix;

  SVGAnimatedNumber kernelUnitLengthX;

  SVGAnimatedNumber kernelUnitLengthY;

  SVGAnimatedInteger orderX;

  SVGAnimatedInteger orderY;

  SVGAnimatedBoolean preserveAlpha;

  SVGAnimatedInteger targetX;

  SVGAnimatedInteger targetY;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEDiffuseLightingElement extends SVGElement native "*SVGFEDiffuseLightingElement" {

  SVGAnimatedNumber diffuseConstant;

  SVGAnimatedString in1;

  SVGAnimatedNumber kernelUnitLengthX;

  SVGAnimatedNumber kernelUnitLengthY;

  SVGAnimatedNumber surfaceScale;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEDisplacementMapElement extends SVGElement native "*SVGFEDisplacementMapElement" {

  static final int SVG_CHANNEL_A = 4;

  static final int SVG_CHANNEL_B = 3;

  static final int SVG_CHANNEL_G = 2;

  static final int SVG_CHANNEL_R = 1;

  static final int SVG_CHANNEL_UNKNOWN = 0;

  SVGAnimatedString in1;

  SVGAnimatedString in2;

  SVGAnimatedNumber scale;

  SVGAnimatedEnumeration xChannelSelector;

  SVGAnimatedEnumeration yChannelSelector;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEDistantLightElement extends SVGElement native "*SVGFEDistantLightElement" {

  SVGAnimatedNumber azimuth;

  SVGAnimatedNumber elevation;
}

class SVGFEDropShadowElement extends SVGElement native "*SVGFEDropShadowElement" {

  SVGAnimatedNumber dx;

  SVGAnimatedNumber dy;

  SVGAnimatedString in1;

  SVGAnimatedNumber stdDeviationX;

  SVGAnimatedNumber stdDeviationY;

  void setStdDeviation(num stdDeviationX, num stdDeviationY) native;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEFloodElement extends SVGElement native "*SVGFEFloodElement" {

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEFuncAElement extends SVGComponentTransferFunctionElement native "*SVGFEFuncAElement" {
}

class SVGFEFuncBElement extends SVGComponentTransferFunctionElement native "*SVGFEFuncBElement" {
}

class SVGFEFuncGElement extends SVGComponentTransferFunctionElement native "*SVGFEFuncGElement" {
}

class SVGFEFuncRElement extends SVGComponentTransferFunctionElement native "*SVGFEFuncRElement" {
}

class SVGFEGaussianBlurElement extends SVGElement native "*SVGFEGaussianBlurElement" {

  SVGAnimatedString in1;

  SVGAnimatedNumber stdDeviationX;

  SVGAnimatedNumber stdDeviationY;

  void setStdDeviation(num stdDeviationX, num stdDeviationY) native;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEImageElement extends SVGElement native "*SVGFEImageElement" {

  SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  // From SVGURIReference

  SVGAnimatedString href;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEMergeElement extends SVGElement native "*SVGFEMergeElement" {

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEMergeNodeElement extends SVGElement native "*SVGFEMergeNodeElement" {

  SVGAnimatedString in1;
}

class SVGFEMorphologyElement extends SVGElement native "*SVGFEMorphologyElement" {

  static final int SVG_MORPHOLOGY_OPERATOR_DILATE = 2;

  static final int SVG_MORPHOLOGY_OPERATOR_ERODE = 1;

  static final int SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0;

  SVGAnimatedString in1;

  SVGAnimatedEnumeration operator;

  SVGAnimatedNumber radiusX;

  SVGAnimatedNumber radiusY;

  void setRadius(num radiusX, num radiusY) native;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEOffsetElement extends SVGElement native "*SVGFEOffsetElement" {

  SVGAnimatedNumber dx;

  SVGAnimatedNumber dy;

  SVGAnimatedString in1;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFEPointLightElement extends SVGElement native "*SVGFEPointLightElement" {

  SVGAnimatedNumber x;

  SVGAnimatedNumber y;

  SVGAnimatedNumber z;
}

class SVGFESpecularLightingElement extends SVGElement native "*SVGFESpecularLightingElement" {

  SVGAnimatedString in1;

  SVGAnimatedNumber specularConstant;

  SVGAnimatedNumber specularExponent;

  SVGAnimatedNumber surfaceScale;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFESpotLightElement extends SVGElement native "*SVGFESpotLightElement" {

  SVGAnimatedNumber limitingConeAngle;

  SVGAnimatedNumber pointsAtX;

  SVGAnimatedNumber pointsAtY;

  SVGAnimatedNumber pointsAtZ;

  SVGAnimatedNumber specularExponent;

  SVGAnimatedNumber x;

  SVGAnimatedNumber y;

  SVGAnimatedNumber z;
}

class SVGFETileElement extends SVGElement native "*SVGFETileElement" {

  SVGAnimatedString in1;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFETurbulenceElement extends SVGElement native "*SVGFETurbulenceElement" {

  static final int SVG_STITCHTYPE_NOSTITCH = 2;

  static final int SVG_STITCHTYPE_STITCH = 1;

  static final int SVG_STITCHTYPE_UNKNOWN = 0;

  static final int SVG_TURBULENCE_TYPE_FRACTALNOISE = 1;

  static final int SVG_TURBULENCE_TYPE_TURBULENCE = 2;

  static final int SVG_TURBULENCE_TYPE_UNKNOWN = 0;

  SVGAnimatedNumber baseFrequencyX;

  SVGAnimatedNumber baseFrequencyY;

  SVGAnimatedInteger numOctaves;

  SVGAnimatedNumber seed;

  SVGAnimatedEnumeration stitchTiles;

  SVGAnimatedEnumeration type;

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFilterElement extends SVGElement native "*SVGFilterElement" {

  SVGAnimatedInteger filterResX;

  SVGAnimatedInteger filterResY;

  SVGAnimatedEnumeration filterUnits;

  SVGAnimatedLength height;

  SVGAnimatedEnumeration primitiveUnits;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  void setFilterRes(int filterResX, int filterResY) native;

  // From SVGURIReference

  SVGAnimatedString href;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGFilterPrimitiveStandardAttributes extends SVGStylable native "*SVGFilterPrimitiveStandardAttributes" {

  SVGAnimatedLength height;

  SVGAnimatedString result;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;
}

class SVGFitToViewBox native "*SVGFitToViewBox" {

  SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  SVGAnimatedRect viewBox;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGFontElement extends SVGElement native "*SVGFontElement" {
}

class SVGFontFaceElement extends SVGElement native "*SVGFontFaceElement" {
}

class SVGFontFaceFormatElement extends SVGElement native "*SVGFontFaceFormatElement" {
}

class SVGFontFaceNameElement extends SVGElement native "*SVGFontFaceNameElement" {
}

class SVGFontFaceSrcElement extends SVGElement native "*SVGFontFaceSrcElement" {
}

class SVGFontFaceUriElement extends SVGElement native "*SVGFontFaceUriElement" {
}

class SVGForeignObjectElement extends SVGElement native "*SVGForeignObjectElement" {

  SVGAnimatedLength height;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGGElement extends SVGElement native "*SVGGElement" {

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGGlyphElement extends SVGElement native "*SVGGlyphElement" {
}

class SVGGlyphRefElement extends SVGElement native "*SVGGlyphRefElement" {

  num dx;

  num dy;

  String format;

  String glyphRef;

  num x;

  num y;

  // From SVGURIReference

  SVGAnimatedString href;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGGradientElement extends SVGElement native "SVGGradientElement" {

  static final int SVG_SPREADMETHOD_PAD = 1;

  static final int SVG_SPREADMETHOD_REFLECT = 2;

  static final int SVG_SPREADMETHOD_REPEAT = 3;

  static final int SVG_SPREADMETHOD_UNKNOWN = 0;

  SVGAnimatedTransformList gradientTransform;

  SVGAnimatedEnumeration gradientUnits;

  SVGAnimatedEnumeration spreadMethod;

  // From SVGURIReference

  SVGAnimatedString href;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGHKernElement extends SVGElement native "*SVGHKernElement" {
}

class SVGImageElement extends SVGElement native "*SVGImageElement" {

  SVGAnimatedLength height;

  SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGURIReference

  SVGAnimatedString href;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGLangSpace native "*SVGLangSpace" {

  String xmllang;

  String xmlspace;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGLength native "*SVGLength" {

  static final int SVG_LENGTHTYPE_CM = 6;

  static final int SVG_LENGTHTYPE_EMS = 3;

  static final int SVG_LENGTHTYPE_EXS = 4;

  static final int SVG_LENGTHTYPE_IN = 8;

  static final int SVG_LENGTHTYPE_MM = 7;

  static final int SVG_LENGTHTYPE_NUMBER = 1;

  static final int SVG_LENGTHTYPE_PC = 10;

  static final int SVG_LENGTHTYPE_PERCENTAGE = 2;

  static final int SVG_LENGTHTYPE_PT = 9;

  static final int SVG_LENGTHTYPE_PX = 5;

  static final int SVG_LENGTHTYPE_UNKNOWN = 0;

  int unitType;

  num value;

  String valueAsString;

  num valueInSpecifiedUnits;

  void convertToSpecifiedUnits(int unitType) native;

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGLengthList native "*SVGLengthList" {

  int numberOfItems;

  SVGLength appendItem(SVGLength item) native;

  void clear() native;

  SVGLength getItem(int index) native;

  SVGLength initialize(SVGLength item) native;

  SVGLength insertItemBefore(SVGLength item, int index) native;

  SVGLength removeItem(int index) native;

  SVGLength replaceItem(SVGLength item, int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGLineElement extends SVGElement native "*SVGLineElement" {

  SVGAnimatedLength x1;

  SVGAnimatedLength x2;

  SVGAnimatedLength y1;

  SVGAnimatedLength y2;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGLinearGradientElement extends SVGGradientElement native "*SVGLinearGradientElement" {

  SVGAnimatedLength x1;

  SVGAnimatedLength x2;

  SVGAnimatedLength y1;

  SVGAnimatedLength y2;
}

class SVGLocatable native "*SVGLocatable" {

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGMPathElement extends SVGElement native "*SVGMPathElement" {

  // From SVGURIReference

  SVGAnimatedString href;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;
}

class SVGMarkerElement extends SVGElement native "*SVGMarkerElement" {

  static final int SVG_MARKERUNITS_STROKEWIDTH = 2;

  static final int SVG_MARKERUNITS_UNKNOWN = 0;

  static final int SVG_MARKERUNITS_USERSPACEONUSE = 1;

  static final int SVG_MARKER_ORIENT_ANGLE = 2;

  static final int SVG_MARKER_ORIENT_AUTO = 1;

  static final int SVG_MARKER_ORIENT_UNKNOWN = 0;

  SVGAnimatedLength markerHeight;

  SVGAnimatedEnumeration markerUnits;

  SVGAnimatedLength markerWidth;

  SVGAnimatedAngle orientAngle;

  SVGAnimatedEnumeration orientType;

  SVGAnimatedLength refX;

  SVGAnimatedLength refY;

  void setOrientToAngle(SVGAngle angle) native;

  void setOrientToAuto() native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  SVGAnimatedRect viewBox;
}

class SVGMaskElement extends SVGElement native "*SVGMaskElement" {

  SVGAnimatedLength height;

  SVGAnimatedEnumeration maskContentUnits;

  SVGAnimatedEnumeration maskUnits;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGMatrix native "*SVGMatrix" {

  num a;

  num b;

  num c;

  num d;

  num e;

  num f;

  SVGMatrix flipX() native;

  SVGMatrix flipY() native;

  SVGMatrix inverse() native;

  SVGMatrix multiply(SVGMatrix secondMatrix) native;

  SVGMatrix rotate(num angle) native;

  SVGMatrix rotateFromVector(num x, num y) native;

  SVGMatrix scale(num scaleFactor) native;

  SVGMatrix scaleNonUniform(num scaleFactorX, num scaleFactorY) native;

  SVGMatrix skewX(num angle) native;

  SVGMatrix skewY(num angle) native;

  SVGMatrix translate(num x, num y) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGMetadataElement extends SVGElement native "*SVGMetadataElement" {
}

class SVGMissingGlyphElement extends SVGElement native "*SVGMissingGlyphElement" {
}

class SVGNumber native "*SVGNumber" {

  num value;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGNumberList native "*SVGNumberList" {

  int numberOfItems;

  SVGNumber appendItem(SVGNumber item) native;

  void clear() native;

  SVGNumber getItem(int index) native;

  SVGNumber initialize(SVGNumber item) native;

  SVGNumber insertItemBefore(SVGNumber item, int index) native;

  SVGNumber removeItem(int index) native;

  SVGNumber replaceItem(SVGNumber item, int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGPaint extends SVGColor native "*SVGPaint" {

  static final int SVG_PAINTTYPE_CURRENTCOLOR = 102;

  static final int SVG_PAINTTYPE_NONE = 101;

  static final int SVG_PAINTTYPE_RGBCOLOR = 1;

  static final int SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR = 2;

  static final int SVG_PAINTTYPE_UNKNOWN = 0;

  static final int SVG_PAINTTYPE_URI = 107;

  static final int SVG_PAINTTYPE_URI_CURRENTCOLOR = 104;

  static final int SVG_PAINTTYPE_URI_NONE = 103;

  static final int SVG_PAINTTYPE_URI_RGBCOLOR = 105;

  static final int SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR = 106;

  int paintType;

  String uri;

  void setPaint(int paintType, String uri, String rgbColor, String iccColor) native;

  void setUri(String uri) native;
}

class SVGPathElement extends SVGElement native "*SVGPathElement" {

  SVGPathSegList animatedNormalizedPathSegList;

  SVGPathSegList animatedPathSegList;

  SVGPathSegList normalizedPathSegList;

  SVGAnimatedNumber pathLength;

  SVGPathSegList pathSegList;

  SVGPathSegArcAbs createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) native;

  SVGPathSegArcRel createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) native;

  SVGPathSegClosePath createSVGPathSegClosePath() native;

  SVGPathSegCurvetoCubicAbs createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2) native;

  SVGPathSegCurvetoCubicRel createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2) native;

  SVGPathSegCurvetoCubicSmoothAbs createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2) native;

  SVGPathSegCurvetoCubicSmoothRel createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2) native;

  SVGPathSegCurvetoQuadraticAbs createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1) native;

  SVGPathSegCurvetoQuadraticRel createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1) native;

  SVGPathSegCurvetoQuadraticSmoothAbs createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y) native;

  SVGPathSegCurvetoQuadraticSmoothRel createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y) native;

  SVGPathSegLinetoAbs createSVGPathSegLinetoAbs(num x, num y) native;

  SVGPathSegLinetoHorizontalAbs createSVGPathSegLinetoHorizontalAbs(num x) native;

  SVGPathSegLinetoHorizontalRel createSVGPathSegLinetoHorizontalRel(num x) native;

  SVGPathSegLinetoRel createSVGPathSegLinetoRel(num x, num y) native;

  SVGPathSegLinetoVerticalAbs createSVGPathSegLinetoVerticalAbs(num y) native;

  SVGPathSegLinetoVerticalRel createSVGPathSegLinetoVerticalRel(num y) native;

  SVGPathSegMovetoAbs createSVGPathSegMovetoAbs(num x, num y) native;

  SVGPathSegMovetoRel createSVGPathSegMovetoRel(num x, num y) native;

  int getPathSegAtLength(num distance) native;

  SVGPoint getPointAtLength(num distance) native;

  num getTotalLength() native;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGPathSeg native "*SVGPathSeg" {

  static final int PATHSEG_ARC_ABS = 10;

  static final int PATHSEG_ARC_REL = 11;

  static final int PATHSEG_CLOSEPATH = 1;

  static final int PATHSEG_CURVETO_CUBIC_ABS = 6;

  static final int PATHSEG_CURVETO_CUBIC_REL = 7;

  static final int PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;

  static final int PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;

  static final int PATHSEG_CURVETO_QUADRATIC_ABS = 8;

  static final int PATHSEG_CURVETO_QUADRATIC_REL = 9;

  static final int PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;

  static final int PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;

  static final int PATHSEG_LINETO_ABS = 4;

  static final int PATHSEG_LINETO_HORIZONTAL_ABS = 12;

  static final int PATHSEG_LINETO_HORIZONTAL_REL = 13;

  static final int PATHSEG_LINETO_REL = 5;

  static final int PATHSEG_LINETO_VERTICAL_ABS = 14;

  static final int PATHSEG_LINETO_VERTICAL_REL = 15;

  static final int PATHSEG_MOVETO_ABS = 2;

  static final int PATHSEG_MOVETO_REL = 3;

  static final int PATHSEG_UNKNOWN = 0;

  int pathSegType;

  String pathSegTypeAsLetter;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGPathSegArcAbs extends SVGPathSeg native "*SVGPathSegArcAbs" {

  num angle;

  bool largeArcFlag;

  num r1;

  num r2;

  bool sweepFlag;

  num x;

  num y;
}

class SVGPathSegArcRel extends SVGPathSeg native "*SVGPathSegArcRel" {

  num angle;

  bool largeArcFlag;

  num r1;

  num r2;

  bool sweepFlag;

  num x;

  num y;
}

class SVGPathSegClosePath extends SVGPathSeg native "*SVGPathSegClosePath" {
}

class SVGPathSegCurvetoCubicAbs extends SVGPathSeg native "*SVGPathSegCurvetoCubicAbs" {

  num x;

  num x1;

  num x2;

  num y;

  num y1;

  num y2;
}

class SVGPathSegCurvetoCubicRel extends SVGPathSeg native "*SVGPathSegCurvetoCubicRel" {

  num x;

  num x1;

  num x2;

  num y;

  num y1;

  num y2;
}

class SVGPathSegCurvetoCubicSmoothAbs extends SVGPathSeg native "*SVGPathSegCurvetoCubicSmoothAbs" {

  num x;

  num x2;

  num y;

  num y2;
}

class SVGPathSegCurvetoCubicSmoothRel extends SVGPathSeg native "*SVGPathSegCurvetoCubicSmoothRel" {

  num x;

  num x2;

  num y;

  num y2;
}

class SVGPathSegCurvetoQuadraticAbs extends SVGPathSeg native "*SVGPathSegCurvetoQuadraticAbs" {

  num x;

  num x1;

  num y;

  num y1;
}

class SVGPathSegCurvetoQuadraticRel extends SVGPathSeg native "*SVGPathSegCurvetoQuadraticRel" {

  num x;

  num x1;

  num y;

  num y1;
}

class SVGPathSegCurvetoQuadraticSmoothAbs extends SVGPathSeg native "*SVGPathSegCurvetoQuadraticSmoothAbs" {

  num x;

  num y;
}

class SVGPathSegCurvetoQuadraticSmoothRel extends SVGPathSeg native "*SVGPathSegCurvetoQuadraticSmoothRel" {

  num x;

  num y;
}

class SVGPathSegLinetoAbs extends SVGPathSeg native "*SVGPathSegLinetoAbs" {

  num x;

  num y;
}

class SVGPathSegLinetoHorizontalAbs extends SVGPathSeg native "*SVGPathSegLinetoHorizontalAbs" {

  num x;
}

class SVGPathSegLinetoHorizontalRel extends SVGPathSeg native "*SVGPathSegLinetoHorizontalRel" {

  num x;
}

class SVGPathSegLinetoRel extends SVGPathSeg native "*SVGPathSegLinetoRel" {

  num x;

  num y;
}

class SVGPathSegLinetoVerticalAbs extends SVGPathSeg native "*SVGPathSegLinetoVerticalAbs" {

  num y;
}

class SVGPathSegLinetoVerticalRel extends SVGPathSeg native "*SVGPathSegLinetoVerticalRel" {

  num y;
}

class SVGPathSegList native "*SVGPathSegList" {

  int numberOfItems;

  SVGPathSeg appendItem(SVGPathSeg newItem) native;

  void clear() native;

  SVGPathSeg getItem(int index) native;

  SVGPathSeg initialize(SVGPathSeg newItem) native;

  SVGPathSeg insertItemBefore(SVGPathSeg newItem, int index) native;

  SVGPathSeg removeItem(int index) native;

  SVGPathSeg replaceItem(SVGPathSeg newItem, int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGPathSegMovetoAbs extends SVGPathSeg native "*SVGPathSegMovetoAbs" {

  num x;

  num y;
}

class SVGPathSegMovetoRel extends SVGPathSeg native "*SVGPathSegMovetoRel" {

  num x;

  num y;
}

class SVGPatternElement extends SVGElement native "*SVGPatternElement" {

  SVGAnimatedLength height;

  SVGAnimatedEnumeration patternContentUnits;

  SVGAnimatedTransformList patternTransform;

  SVGAnimatedEnumeration patternUnits;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGURIReference

  SVGAnimatedString href;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  SVGAnimatedRect viewBox;
}

class SVGPoint native "*SVGPoint" {

  num x;

  num y;

  SVGPoint matrixTransform(SVGMatrix matrix) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGPointList native "*SVGPointList" {

  int numberOfItems;

  SVGPoint appendItem(SVGPoint item) native;

  void clear() native;

  SVGPoint getItem(int index) native;

  SVGPoint initialize(SVGPoint item) native;

  SVGPoint insertItemBefore(SVGPoint item, int index) native;

  SVGPoint removeItem(int index) native;

  SVGPoint replaceItem(SVGPoint item, int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGPolygonElement extends SVGElement native "*SVGPolygonElement" {

  SVGPointList animatedPoints;

  SVGPointList points;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGPolylineElement extends SVGElement native "*SVGPolylineElement" {

  SVGPointList animatedPoints;

  SVGPointList points;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGPreserveAspectRatio native "*SVGPreserveAspectRatio" {

  static final int SVG_MEETORSLICE_MEET = 1;

  static final int SVG_MEETORSLICE_SLICE = 2;

  static final int SVG_MEETORSLICE_UNKNOWN = 0;

  static final int SVG_PRESERVEASPECTRATIO_NONE = 1;

  static final int SVG_PRESERVEASPECTRATIO_UNKNOWN = 0;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMID = 7;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMID = 6;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMAX = 8;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMID = 5;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMIN = 2;

  int align;

  int meetOrSlice;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGRadialGradientElement extends SVGGradientElement native "*SVGRadialGradientElement" {

  SVGAnimatedLength cx;

  SVGAnimatedLength cy;

  SVGAnimatedLength fx;

  SVGAnimatedLength fy;

  SVGAnimatedLength r;
}

class SVGRect native "*SVGRect" {

  num height;

  num width;

  num x;

  num y;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGRectElement extends SVGElement native "*SVGRectElement" {

  SVGAnimatedLength height;

  SVGAnimatedLength rx;

  SVGAnimatedLength ry;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGRenderingIntent native "*SVGRenderingIntent" {

  static final int RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = 5;

  static final int RENDERING_INTENT_AUTO = 1;

  static final int RENDERING_INTENT_PERCEPTUAL = 2;

  static final int RENDERING_INTENT_RELATIVE_COLORIMETRIC = 3;

  static final int RENDERING_INTENT_SATURATION = 4;

  static final int RENDERING_INTENT_UNKNOWN = 0;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGSVGElement extends SVGElement native "*SVGSVGElement" {

  String contentScriptType;

  String contentStyleType;

  num currentScale;

  SVGPoint currentTranslate;

  SVGAnimatedLength height;

  num pixelUnitToMillimeterX;

  num pixelUnitToMillimeterY;

  num screenPixelToMillimeterX;

  num screenPixelToMillimeterY;

  bool useCurrentView;

  SVGRect viewport;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  bool animationsPaused() native;

  bool checkEnclosure(SVGElement element, SVGRect rect) native;

  bool checkIntersection(SVGElement element, SVGRect rect) native;

  SVGAngle createSVGAngle() native;

  SVGLength createSVGLength() native;

  SVGMatrix createSVGMatrix() native;

  SVGNumber createSVGNumber() native;

  SVGPoint createSVGPoint() native;

  SVGRect createSVGRect() native;

  SVGTransform createSVGTransform() native;

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) native;

  void deselectAll() native;

  void forceRedraw() native;

  num getCurrentTime() native;

  Element getElementById(String elementId) native;

  NodeList getEnclosureList(SVGRect rect, SVGElement referenceElement) native;

  NodeList getIntersectionList(SVGRect rect, SVGElement referenceElement) native;

  void pauseAnimations() native;

  void setCurrentTime(num seconds) native;

  int suspendRedraw(int maxWaitMilliseconds) native;

  void unpauseAnimations() native;

  void unsuspendRedraw(int suspendHandleId) native;

  void unsuspendRedrawAll() native;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  SVGAnimatedRect viewBox;

  // From SVGZoomAndPan

  int zoomAndPan;
}

class SVGScriptElement extends SVGElement native "*SVGScriptElement" {

  String type;

  // From SVGURIReference

  SVGAnimatedString href;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;
}

class SVGSetElement extends SVGAnimationElement native "*SVGSetElement" {
}

class SVGStopElement extends SVGElement native "*SVGStopElement" {

  SVGAnimatedNumber offset;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGStringList native "*SVGStringList" {

  int numberOfItems;

  String appendItem(String item) native;

  void clear() native;

  String getItem(int index) native;

  String initialize(String item) native;

  String insertItemBefore(String item, int index) native;

  String removeItem(int index) native;

  String replaceItem(String item, int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGStylable native "*SVGStylable" {

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGStyleElement extends SVGElement native "*SVGStyleElement" {

  String media;

  String title;

  String type;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;
}

class SVGSwitchElement extends SVGElement native "*SVGSwitchElement" {

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGSymbolElement extends SVGElement native "*SVGSymbolElement" {

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  SVGAnimatedRect viewBox;
}

class SVGTRefElement extends SVGTextPositioningElement native "*SVGTRefElement" {

  // From SVGURIReference

  SVGAnimatedString href;
}

class SVGTSpanElement extends SVGTextPositioningElement native "*SVGTSpanElement" {
}

class SVGTests native "*SVGTests" {

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGTextContentElement extends SVGElement native "SVGTextContentElement" {

  static final int LENGTHADJUST_SPACING = 1;

  static final int LENGTHADJUST_SPACINGANDGLYPHS = 2;

  static final int LENGTHADJUST_UNKNOWN = 0;

  SVGAnimatedEnumeration lengthAdjust;

  SVGAnimatedLength textLength;

  int getCharNumAtPosition(SVGPoint point) native;

  num getComputedTextLength() native;

  SVGPoint getEndPositionOfChar(int offset) native;

  SVGRect getExtentOfChar(int offset) native;

  int getNumberOfChars() native;

  num getRotationOfChar(int offset) native;

  SVGPoint getStartPositionOfChar(int offset) native;

  num getSubStringLength(int offset, int length) native;

  void selectSubString(int offset, int length) native;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGTextElement extends SVGTextPositioningElement native "*SVGTextElement" {

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGTextPathElement extends SVGTextContentElement native "*SVGTextPathElement" {

  static final int TEXTPATH_METHODTYPE_ALIGN = 1;

  static final int TEXTPATH_METHODTYPE_STRETCH = 2;

  static final int TEXTPATH_METHODTYPE_UNKNOWN = 0;

  static final int TEXTPATH_SPACINGTYPE_AUTO = 1;

  static final int TEXTPATH_SPACINGTYPE_EXACT = 2;

  static final int TEXTPATH_SPACINGTYPE_UNKNOWN = 0;

  SVGAnimatedEnumeration method;

  SVGAnimatedEnumeration spacing;

  SVGAnimatedLength startOffset;

  // From SVGURIReference

  SVGAnimatedString href;
}

class SVGTextPositioningElement extends SVGTextContentElement native "SVGTextPositioningElement" {

  SVGAnimatedLengthList dx;

  SVGAnimatedLengthList dy;

  SVGAnimatedNumberList rotate;

  SVGAnimatedLengthList x;

  SVGAnimatedLengthList y;
}

class SVGTitleElement extends SVGElement native "*SVGTitleElement" {

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;
}

class SVGTransform native "*SVGTransform" {

  static final int SVG_TRANSFORM_MATRIX = 1;

  static final int SVG_TRANSFORM_ROTATE = 4;

  static final int SVG_TRANSFORM_SCALE = 3;

  static final int SVG_TRANSFORM_SKEWX = 5;

  static final int SVG_TRANSFORM_SKEWY = 6;

  static final int SVG_TRANSFORM_TRANSLATE = 2;

  static final int SVG_TRANSFORM_UNKNOWN = 0;

  num angle;

  SVGMatrix matrix;

  int type;

  void setMatrix(SVGMatrix matrix) native;

  void setRotate(num angle, num cx, num cy) native;

  void setScale(num sx, num sy) native;

  void setSkewX(num angle) native;

  void setSkewY(num angle) native;

  void setTranslate(num tx, num ty) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGTransformList native "*SVGTransformList" {

  int numberOfItems;

  SVGTransform appendItem(SVGTransform item) native;

  void clear() native;

  SVGTransform consolidate() native;

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) native;

  SVGTransform getItem(int index) native;

  SVGTransform initialize(SVGTransform item) native;

  SVGTransform insertItemBefore(SVGTransform item, int index) native;

  SVGTransform removeItem(int index) native;

  SVGTransform replaceItem(SVGTransform item, int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGTransformable extends SVGLocatable native "*SVGTransformable" {

  SVGAnimatedTransformList transform;
}

class SVGURIReference native "*SVGURIReference" {

  SVGAnimatedString href;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGUnitTypes native "*SVGUnitTypes" {

  static final int SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;

  static final int SVG_UNIT_TYPE_UNKNOWN = 0;

  static final int SVG_UNIT_TYPE_USERSPACEONUSE = 1;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGUseElement extends SVGElement native "*SVGUseElement" {

  SVGElementInstance animatedInstanceRoot;

  SVGAnimatedLength height;

  SVGElementInstance instanceRoot;

  SVGAnimatedLength width;

  SVGAnimatedLength x;

  SVGAnimatedLength y;

  // From SVGURIReference

  SVGAnimatedString href;

  // From SVGTests

  SVGStringList requiredExtensions;

  SVGStringList requiredFeatures;

  SVGStringList systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGStylable

  SVGAnimatedString className;

  CSSStyleDeclaration style;

  CSSValue getPresentationAttribute(String name) native;

  // From SVGTransformable

  SVGAnimatedTransformList transform;

  // From SVGLocatable

  SVGElement farthestViewportElement;

  SVGElement nearestViewportElement;

  SVGRect getBBox() native;

  SVGMatrix getCTM() native;

  SVGMatrix getScreenCTM() native;

  SVGMatrix getTransformToElement(SVGElement element) native;
}

class SVGVKernElement extends SVGElement native "*SVGVKernElement" {
}

class SVGViewElement extends SVGElement native "*SVGViewElement" {

  SVGStringList viewTarget;

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean externalResourcesRequired;

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  SVGAnimatedRect viewBox;

  // From SVGZoomAndPan

  int zoomAndPan;
}

class SVGViewSpec extends SVGZoomAndPan native "*SVGViewSpec" {

  String preserveAspectRatioString;

  SVGTransformList transform;

  String transformString;

  String viewBoxString;

  SVGElement viewTarget;

  String viewTargetString;

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  SVGAnimatedRect viewBox;
}

class SVGZoomAndPan native "*SVGZoomAndPan" {

  static final int SVG_ZOOMANDPAN_DISABLE = 1;

  static final int SVG_ZOOMANDPAN_MAGNIFY = 2;

  static final int SVG_ZOOMANDPAN_UNKNOWN = 0;

  int zoomAndPan;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SVGZoomEvent extends UIEvent native "*SVGZoomEvent" {

  num newScale;

  SVGPoint newTranslate;

  num previousScale;

  SVGPoint previousTranslate;

  SVGRect zoomRectScreen;
}

class Screen native "*Screen" {

  int availHeight;

  int availLeft;

  int availTop;

  int availWidth;

  int colorDepth;

  int height;

  int pixelDepth;

  int width;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class ScriptProfile native "*ScriptProfile" {

  ScriptProfileNode head;

  String title;

  int uid;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class ScriptProfileNode native "*ScriptProfileNode" {

  int callUID;

  List children;

  String functionName;

  int lineNumber;

  int numberOfCalls;

  num selfTime;

  num totalTime;

  String url;

  bool visible;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SharedWorker extends AbstractWorker native "*SharedWorker" {

  MessagePort port;
}

class SharedWorkercontext extends WorkerContext native "*SharedWorkercontext" {

  String name;

  EventListener onconnect;
}

class SpeechInputEvent extends Event native "*SpeechInputEvent" {

  SpeechInputResultList results;
}

class SpeechInputResult native "*SpeechInputResult" {

  num confidence;

  String utterance;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class SpeechInputResultList native "*SpeechInputResultList" {

  int length;

  SpeechInputResult item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Storage native "*Storage" {

  int length;

  void clear() native;

  String getItem(String key) native;

  String key(int index) native;

  void removeItem(String key) native;

  void setItem(String key, String data) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class StorageEvent extends Event native "*StorageEvent" {

  String key;

  String newValue;

  String oldValue;

  Storage storageArea;

  String url;

  void initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg) native;
}

class StorageInfo native "*StorageInfo" {

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback = null, StorageInfoErrorCallback errorCallback = null]) native;

  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback = null, StorageInfoErrorCallback errorCallback = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class StyleMedia native "*StyleMedia" {

  String type;

  bool matchMedium(String mediaquery) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class StyleSheet native "StyleSheet" {

  bool disabled;

  String href;

  MediaList media;

  Node ownerNode;

  StyleSheet parentStyleSheet;

  String title;

  String type;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class StyleSheetList native "*StyleSheetList" {

  int length;

  StyleSheet operator[](int index) native;

  void operator[]=(int index, StyleSheet value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  StyleSheet item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Text extends CharacterData native "Text" {

  String wholeText;

  Text replaceWholeText(String content) native;

  Text splitText(int offset) native;
}

class TextEvent extends UIEvent native "*TextEvent" {

  String data;

  void initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, DOMWindow viewArg, String dataArg) native;
}

class TextMetrics native "*TextMetrics" {

  num width;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class TextTrack native "*TextTrack" {

  static final int Disabled = 0;

  static final int Error = 3;

  static final int Hidden = 1;

  static final int Loaded = 2;

  static final int Loading = 1;

  static final int None = 0;

  static final int Showing = 2;

  TextTrackCueList activeCues;

  TextTrackCueList cues;

  String kind;

  String label;

  String language;

  int mode;

  int readyState;

  void addCue(TextTrackCue cue) native;

  void removeCue(TextTrackCue cue) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class TextTrackCue native "*TextTrackCue" {

  String alignment;

  String direction;

  num endTime;

  String id;

  int linePosition;

  bool pauseOnExit;

  int size;

  bool snapToLines;

  num startTime;

  int textPosition;

  TextTrack track;

  DocumentFragment getCueAsHTML() native;

  String getCueAsSource() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class TextTrackCueList native "*TextTrackCueList" {

  int length;

  TextTrackCue getCueById(String id) native;

  TextTrackCue item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class TimeRanges native "*TimeRanges" {

  int length;

  num end(int index) native;

  num start(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class Touch native "*Touch" {

  int clientX;

  int clientY;

  int identifier;

  int pageX;

  int pageY;

  int screenX;

  int screenY;

  EventTarget target;

  num webkitForce;

  int webkitRadiusX;

  int webkitRadiusY;

  num webkitRotationAngle;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class TouchEvent extends UIEvent native "*TouchEvent" {

  bool altKey;

  TouchList changedTouches;

  bool ctrlKey;

  bool metaKey;

  bool shiftKey;

  TouchList targetTouches;

  TouchList touches;

  void initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, DOMWindow view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) native;
}

class TouchList native "*TouchList" {

  int length;

  Touch operator[](int index) native;

  void operator[]=(int index, Touch value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  Touch item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class TreeWalker native "*TreeWalker" {

  Node currentNode;

  bool expandEntityReferences;

  NodeFilter filter;

  Node root;

  int whatToShow;

  Node firstChild() native;

  Node lastChild() native;

  Node nextNode() native;

  Node nextSibling() native;

  Node parentNode() native;

  Node previousNode() native;

  Node previousSibling() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class UIEvent extends Event native "UIEvent" {

  int charCode;

  int detail;

  int keyCode;

  int layerX;

  int layerY;

  int pageX;

  int pageY;

  DOMWindow view;

  int which;

  void initUIEvent(String type, bool canBubble, bool cancelable, DOMWindow view, int detail) native;
}

class Uint16Array extends ArrayBufferView implements List<int> native "*Uint16Array" {

  factory Uint16Array(int length) =>  _construct(length);

  factory Uint16Array.fromList(List<int> list) => _construct(list);

  factory Uint16Array.fromBuffer(ArrayBuffer buffer) => _construct(buffer);

  static _construct(arg) native 'return new Uint16Array(arg);';

  static final int BYTES_PER_ELEMENT = 2;

  int length;

  int operator[](int index) native;

  void operator[]=(int index, int value) native;

  Uint16Array subarray(int start, [int end = null]) native;
}

class Uint32Array extends ArrayBufferView implements List<int> native "*Uint32Array" {

  factory Uint32Array(int length) =>  _construct(length);

  factory Uint32Array.fromList(List<int> list) => _construct(list);

  factory Uint32Array.fromBuffer(ArrayBuffer buffer) => _construct(buffer);

  static _construct(arg) native 'return new Uint32Array(arg);';

  static final int BYTES_PER_ELEMENT = 4;

  int length;

  int operator[](int index) native;

  void operator[]=(int index, int value) native;

  Uint32Array subarray(int start, [int end = null]) native;
}

class Uint8Array extends ArrayBufferView implements List<int> native "*Uint8Array" {

  factory Uint8Array(int length) =>  _construct(length);

  factory Uint8Array.fromList(List<int> list) => _construct(list);

  factory Uint8Array.fromBuffer(ArrayBuffer buffer) => _construct(buffer);

  static _construct(arg) native 'return new Uint8Array(arg);';

  static final int BYTES_PER_ELEMENT = 1;

  int length;

  int operator[](int index) native;

  void operator[]=(int index, int value) native;

  Uint8Array subarray(int start, [int end = null]) native;
}

class ValidityState native "*ValidityState" {

  bool customError;

  bool patternMismatch;

  bool rangeOverflow;

  bool rangeUnderflow;

  bool stepMismatch;

  bool tooLong;

  bool typeMismatch;

  bool valid;

  bool valueMissing;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WaveShaperNode extends AudioNode native "*WaveShaperNode" {

  Float32Array curve;
}

class WebGLActiveInfo native "*WebGLActiveInfo" {

  String name;

  int size;

  int type;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebGLBuffer native "*WebGLBuffer" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebGLContextAttributes native "*WebGLContextAttributes" {

  bool alpha;

  bool antialias;

  bool depth;

  bool premultipliedAlpha;

  bool preserveDrawingBuffer;

  bool stencil;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebGLContextEvent extends Event native "*WebGLContextEvent" {

  String statusMessage;
}

class WebGLDebugRendererInfo native "*WebGLDebugRendererInfo" {

  static final int UNMASKED_RENDERER_WEBGL = 0x9246;

  static final int UNMASKED_VENDOR_WEBGL = 0x9245;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebGLDebugShaders native "*WebGLDebugShaders" {

  String getTranslatedShaderSource(WebGLShader shader) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebGLFramebuffer native "*WebGLFramebuffer" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebGLProgram native "*WebGLProgram" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebGLRenderbuffer native "*WebGLRenderbuffer" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebGLRenderingContext extends CanvasRenderingContext native "*WebGLRenderingContext" {

  static final int ACTIVE_ATTRIBUTES = 0x8B89;

  static final int ACTIVE_TEXTURE = 0x84E0;

  static final int ACTIVE_UNIFORMS = 0x8B86;

  static final int ALIASED_LINE_WIDTH_RANGE = 0x846E;

  static final int ALIASED_POINT_SIZE_RANGE = 0x846D;

  static final int ALPHA = 0x1906;

  static final int ALPHA_BITS = 0x0D55;

  static final int ALWAYS = 0x0207;

  static final int ARRAY_BUFFER = 0x8892;

  static final int ARRAY_BUFFER_BINDING = 0x8894;

  static final int ATTACHED_SHADERS = 0x8B85;

  static final int BACK = 0x0405;

  static final int BLEND = 0x0BE2;

  static final int BLEND_COLOR = 0x8005;

  static final int BLEND_DST_ALPHA = 0x80CA;

  static final int BLEND_DST_RGB = 0x80C8;

  static final int BLEND_EQUATION = 0x8009;

  static final int BLEND_EQUATION_ALPHA = 0x883D;

  static final int BLEND_EQUATION_RGB = 0x8009;

  static final int BLEND_SRC_ALPHA = 0x80CB;

  static final int BLEND_SRC_RGB = 0x80C9;

  static final int BLUE_BITS = 0x0D54;

  static final int BOOL = 0x8B56;

  static final int BOOL_VEC2 = 0x8B57;

  static final int BOOL_VEC3 = 0x8B58;

  static final int BOOL_VEC4 = 0x8B59;

  static final int BROWSER_DEFAULT_WEBGL = 0x9244;

  static final int BUFFER_SIZE = 0x8764;

  static final int BUFFER_USAGE = 0x8765;

  static final int BYTE = 0x1400;

  static final int CCW = 0x0901;

  static final int CLAMP_TO_EDGE = 0x812F;

  static final int COLOR_ATTACHMENT0 = 0x8CE0;

  static final int COLOR_BUFFER_BIT = 0x00004000;

  static final int COLOR_CLEAR_VALUE = 0x0C22;

  static final int COLOR_WRITEMASK = 0x0C23;

  static final int COMPILE_STATUS = 0x8B81;

  static final int COMPRESSED_TEXTURE_FORMATS = 0x86A3;

  static final int CONSTANT_ALPHA = 0x8003;

  static final int CONSTANT_COLOR = 0x8001;

  static final int CONTEXT_LOST_WEBGL = 0x9242;

  static final int CULL_FACE = 0x0B44;

  static final int CULL_FACE_MODE = 0x0B45;

  static final int CURRENT_PROGRAM = 0x8B8D;

  static final int CURRENT_VERTEX_ATTRIB = 0x8626;

  static final int CW = 0x0900;

  static final int DECR = 0x1E03;

  static final int DECR_WRAP = 0x8508;

  static final int DELETE_STATUS = 0x8B80;

  static final int DEPTH_ATTACHMENT = 0x8D00;

  static final int DEPTH_BITS = 0x0D56;

  static final int DEPTH_BUFFER_BIT = 0x00000100;

  static final int DEPTH_CLEAR_VALUE = 0x0B73;

  static final int DEPTH_COMPONENT = 0x1902;

  static final int DEPTH_COMPONENT16 = 0x81A5;

  static final int DEPTH_FUNC = 0x0B74;

  static final int DEPTH_RANGE = 0x0B70;

  static final int DEPTH_STENCIL = 0x84F9;

  static final int DEPTH_STENCIL_ATTACHMENT = 0x821A;

  static final int DEPTH_TEST = 0x0B71;

  static final int DEPTH_WRITEMASK = 0x0B72;

  static final int DITHER = 0x0BD0;

  static final int DONT_CARE = 0x1100;

  static final int DST_ALPHA = 0x0304;

  static final int DST_COLOR = 0x0306;

  static final int DYNAMIC_DRAW = 0x88E8;

  static final int ELEMENT_ARRAY_BUFFER = 0x8893;

  static final int ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;

  static final int EQUAL = 0x0202;

  static final int FASTEST = 0x1101;

  static final int FLOAT = 0x1406;

  static final int FLOAT_MAT2 = 0x8B5A;

  static final int FLOAT_MAT3 = 0x8B5B;

  static final int FLOAT_MAT4 = 0x8B5C;

  static final int FLOAT_VEC2 = 0x8B50;

  static final int FLOAT_VEC3 = 0x8B51;

  static final int FLOAT_VEC4 = 0x8B52;

  static final int FRAGMENT_SHADER = 0x8B30;

  static final int FRAMEBUFFER = 0x8D40;

  static final int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;

  static final int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;

  static final int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;

  static final int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;

  static final int FRAMEBUFFER_BINDING = 0x8CA6;

  static final int FRAMEBUFFER_COMPLETE = 0x8CD5;

  static final int FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;

  static final int FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;

  static final int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;

  static final int FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

  static final int FRONT = 0x0404;

  static final int FRONT_AND_BACK = 0x0408;

  static final int FRONT_FACE = 0x0B46;

  static final int FUNC_ADD = 0x8006;

  static final int FUNC_REVERSE_SUBTRACT = 0x800B;

  static final int FUNC_SUBTRACT = 0x800A;

  static final int GENERATE_MIPMAP_HINT = 0x8192;

  static final int GEQUAL = 0x0206;

  static final int GREATER = 0x0204;

  static final int GREEN_BITS = 0x0D53;

  static final int HIGH_FLOAT = 0x8DF2;

  static final int HIGH_INT = 0x8DF5;

  static final int INCR = 0x1E02;

  static final int INCR_WRAP = 0x8507;

  static final int INT = 0x1404;

  static final int INT_VEC2 = 0x8B53;

  static final int INT_VEC3 = 0x8B54;

  static final int INT_VEC4 = 0x8B55;

  static final int INVALID_ENUM = 0x0500;

  static final int INVALID_FRAMEBUFFER_OPERATION = 0x0506;

  static final int INVALID_OPERATION = 0x0502;

  static final int INVALID_VALUE = 0x0501;

  static final int INVERT = 0x150A;

  static final int KEEP = 0x1E00;

  static final int LEQUAL = 0x0203;

  static final int LESS = 0x0201;

  static final int LINEAR = 0x2601;

  static final int LINEAR_MIPMAP_LINEAR = 0x2703;

  static final int LINEAR_MIPMAP_NEAREST = 0x2701;

  static final int LINES = 0x0001;

  static final int LINE_LOOP = 0x0002;

  static final int LINE_STRIP = 0x0003;

  static final int LINE_WIDTH = 0x0B21;

  static final int LINK_STATUS = 0x8B82;

  static final int LOW_FLOAT = 0x8DF0;

  static final int LOW_INT = 0x8DF3;

  static final int LUMINANCE = 0x1909;

  static final int LUMINANCE_ALPHA = 0x190A;

  static final int MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;

  static final int MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;

  static final int MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;

  static final int MAX_RENDERBUFFER_SIZE = 0x84E8;

  static final int MAX_TEXTURE_IMAGE_UNITS = 0x8872;

  static final int MAX_TEXTURE_SIZE = 0x0D33;

  static final int MAX_VARYING_VECTORS = 0x8DFC;

  static final int MAX_VERTEX_ATTRIBS = 0x8869;

  static final int MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;

  static final int MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;

  static final int MAX_VIEWPORT_DIMS = 0x0D3A;

  static final int MEDIUM_FLOAT = 0x8DF1;

  static final int MEDIUM_INT = 0x8DF4;

  static final int MIRRORED_REPEAT = 0x8370;

  static final int NEAREST = 0x2600;

  static final int NEAREST_MIPMAP_LINEAR = 0x2702;

  static final int NEAREST_MIPMAP_NEAREST = 0x2700;

  static final int NEVER = 0x0200;

  static final int NICEST = 0x1102;

  static final int NONE = 0;

  static final int NOTEQUAL = 0x0205;

  static final int NO_ERROR = 0;

  static final int NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;

  static final int ONE = 1;

  static final int ONE_MINUS_CONSTANT_ALPHA = 0x8004;

  static final int ONE_MINUS_CONSTANT_COLOR = 0x8002;

  static final int ONE_MINUS_DST_ALPHA = 0x0305;

  static final int ONE_MINUS_DST_COLOR = 0x0307;

  static final int ONE_MINUS_SRC_ALPHA = 0x0303;

  static final int ONE_MINUS_SRC_COLOR = 0x0301;

  static final int OUT_OF_MEMORY = 0x0505;

  static final int PACK_ALIGNMENT = 0x0D05;

  static final int POINTS = 0x0000;

  static final int POLYGON_OFFSET_FACTOR = 0x8038;

  static final int POLYGON_OFFSET_FILL = 0x8037;

  static final int POLYGON_OFFSET_UNITS = 0x2A00;

  static final int RED_BITS = 0x0D52;

  static final int RENDERBUFFER = 0x8D41;

  static final int RENDERBUFFER_ALPHA_SIZE = 0x8D53;

  static final int RENDERBUFFER_BINDING = 0x8CA7;

  static final int RENDERBUFFER_BLUE_SIZE = 0x8D52;

  static final int RENDERBUFFER_DEPTH_SIZE = 0x8D54;

  static final int RENDERBUFFER_GREEN_SIZE = 0x8D51;

  static final int RENDERBUFFER_HEIGHT = 0x8D43;

  static final int RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;

  static final int RENDERBUFFER_RED_SIZE = 0x8D50;

  static final int RENDERBUFFER_STENCIL_SIZE = 0x8D55;

  static final int RENDERBUFFER_WIDTH = 0x8D42;

  static final int RENDERER = 0x1F01;

  static final int REPEAT = 0x2901;

  static final int REPLACE = 0x1E01;

  static final int RGB = 0x1907;

  static final int RGB565 = 0x8D62;

  static final int RGB5_A1 = 0x8057;

  static final int RGBA = 0x1908;

  static final int RGBA4 = 0x8056;

  static final int SAMPLER_2D = 0x8B5E;

  static final int SAMPLER_CUBE = 0x8B60;

  static final int SAMPLES = 0x80A9;

  static final int SAMPLE_ALPHA_TO_COVERAGE = 0x809E;

  static final int SAMPLE_BUFFERS = 0x80A8;

  static final int SAMPLE_COVERAGE = 0x80A0;

  static final int SAMPLE_COVERAGE_INVERT = 0x80AB;

  static final int SAMPLE_COVERAGE_VALUE = 0x80AA;

  static final int SCISSOR_BOX = 0x0C10;

  static final int SCISSOR_TEST = 0x0C11;

  static final int SHADER_COMPILER = 0x8DFA;

  static final int SHADER_TYPE = 0x8B4F;

  static final int SHADING_LANGUAGE_VERSION = 0x8B8C;

  static final int SHORT = 0x1402;

  static final int SRC_ALPHA = 0x0302;

  static final int SRC_ALPHA_SATURATE = 0x0308;

  static final int SRC_COLOR = 0x0300;

  static final int STATIC_DRAW = 0x88E4;

  static final int STENCIL_ATTACHMENT = 0x8D20;

  static final int STENCIL_BACK_FAIL = 0x8801;

  static final int STENCIL_BACK_FUNC = 0x8800;

  static final int STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;

  static final int STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;

  static final int STENCIL_BACK_REF = 0x8CA3;

  static final int STENCIL_BACK_VALUE_MASK = 0x8CA4;

  static final int STENCIL_BACK_WRITEMASK = 0x8CA5;

  static final int STENCIL_BITS = 0x0D57;

  static final int STENCIL_BUFFER_BIT = 0x00000400;

  static final int STENCIL_CLEAR_VALUE = 0x0B91;

  static final int STENCIL_FAIL = 0x0B94;

  static final int STENCIL_FUNC = 0x0B92;

  static final int STENCIL_INDEX = 0x1901;

  static final int STENCIL_INDEX8 = 0x8D48;

  static final int STENCIL_PASS_DEPTH_FAIL = 0x0B95;

  static final int STENCIL_PASS_DEPTH_PASS = 0x0B96;

  static final int STENCIL_REF = 0x0B97;

  static final int STENCIL_TEST = 0x0B90;

  static final int STENCIL_VALUE_MASK = 0x0B93;

  static final int STENCIL_WRITEMASK = 0x0B98;

  static final int STREAM_DRAW = 0x88E0;

  static final int SUBPIXEL_BITS = 0x0D50;

  static final int TEXTURE = 0x1702;

  static final int TEXTURE0 = 0x84C0;

  static final int TEXTURE1 = 0x84C1;

  static final int TEXTURE10 = 0x84CA;

  static final int TEXTURE11 = 0x84CB;

  static final int TEXTURE12 = 0x84CC;

  static final int TEXTURE13 = 0x84CD;

  static final int TEXTURE14 = 0x84CE;

  static final int TEXTURE15 = 0x84CF;

  static final int TEXTURE16 = 0x84D0;

  static final int TEXTURE17 = 0x84D1;

  static final int TEXTURE18 = 0x84D2;

  static final int TEXTURE19 = 0x84D3;

  static final int TEXTURE2 = 0x84C2;

  static final int TEXTURE20 = 0x84D4;

  static final int TEXTURE21 = 0x84D5;

  static final int TEXTURE22 = 0x84D6;

  static final int TEXTURE23 = 0x84D7;

  static final int TEXTURE24 = 0x84D8;

  static final int TEXTURE25 = 0x84D9;

  static final int TEXTURE26 = 0x84DA;

  static final int TEXTURE27 = 0x84DB;

  static final int TEXTURE28 = 0x84DC;

  static final int TEXTURE29 = 0x84DD;

  static final int TEXTURE3 = 0x84C3;

  static final int TEXTURE30 = 0x84DE;

  static final int TEXTURE31 = 0x84DF;

  static final int TEXTURE4 = 0x84C4;

  static final int TEXTURE5 = 0x84C5;

  static final int TEXTURE6 = 0x84C6;

  static final int TEXTURE7 = 0x84C7;

  static final int TEXTURE8 = 0x84C8;

  static final int TEXTURE9 = 0x84C9;

  static final int TEXTURE_2D = 0x0DE1;

  static final int TEXTURE_BINDING_2D = 0x8069;

  static final int TEXTURE_BINDING_CUBE_MAP = 0x8514;

  static final int TEXTURE_CUBE_MAP = 0x8513;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;

  static final int TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;

  static final int TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;

  static final int TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;

  static final int TEXTURE_MAG_FILTER = 0x2800;

  static final int TEXTURE_MIN_FILTER = 0x2801;

  static final int TEXTURE_WRAP_S = 0x2802;

  static final int TEXTURE_WRAP_T = 0x2803;

  static final int TRIANGLES = 0x0004;

  static final int TRIANGLE_FAN = 0x0006;

  static final int TRIANGLE_STRIP = 0x0005;

  static final int UNPACK_ALIGNMENT = 0x0CF5;

  static final int UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;

  static final int UNPACK_FLIP_Y_WEBGL = 0x9240;

  static final int UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;

  static final int UNSIGNED_BYTE = 0x1401;

  static final int UNSIGNED_INT = 0x1405;

  static final int UNSIGNED_SHORT = 0x1403;

  static final int UNSIGNED_SHORT_4_4_4_4 = 0x8033;

  static final int UNSIGNED_SHORT_5_5_5_1 = 0x8034;

  static final int UNSIGNED_SHORT_5_6_5 = 0x8363;

  static final int VALIDATE_STATUS = 0x8B83;

  static final int VENDOR = 0x1F00;

  static final int VERSION = 0x1F02;

  static final int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;

  static final int VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;

  static final int VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;

  static final int VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;

  static final int VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;

  static final int VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;

  static final int VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;

  static final int VERTEX_SHADER = 0x8B31;

  static final int VIEWPORT = 0x0BA2;

  static final int ZERO = 0;

  int drawingBufferHeight;

  int drawingBufferWidth;

  void activeTexture(int texture) native;

  void attachShader(WebGLProgram program, WebGLShader shader) native;

  void bindAttribLocation(WebGLProgram program, int index, String name) native;

  void bindBuffer(int target, WebGLBuffer buffer) native;

  void bindFramebuffer(int target, WebGLFramebuffer framebuffer) native;

  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer) native;

  void bindTexture(int target, WebGLTexture texture) native;

  void blendColor(num red, num green, num blue, num alpha) native;

  void blendEquation(int mode) native;

  void blendEquationSeparate(int modeRGB, int modeAlpha) native;

  void blendFunc(int sfactor, int dfactor) native;

  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) native;

  void bufferData(int target, var data_OR_size, int usage) native;

  void bufferSubData(int target, int offset, var data) native;

  int checkFramebufferStatus(int target) native;

  void clear(int mask) native;

  void clearColor(num red, num green, num blue, num alpha) native;

  void clearDepth(num depth) native;

  void clearStencil(int s) native;

  void colorMask(bool red, bool green, bool blue, bool alpha) native;

  void compileShader(WebGLShader shader) native;

  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) native;

  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) native;

  WebGLBuffer createBuffer() native;

  WebGLFramebuffer createFramebuffer() native;

  WebGLProgram createProgram() native;

  WebGLRenderbuffer createRenderbuffer() native;

  WebGLShader createShader(int type) native;

  WebGLTexture createTexture() native;

  void cullFace(int mode) native;

  void deleteBuffer(WebGLBuffer buffer) native;

  void deleteFramebuffer(WebGLFramebuffer framebuffer) native;

  void deleteProgram(WebGLProgram program) native;

  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer) native;

  void deleteShader(WebGLShader shader) native;

  void deleteTexture(WebGLTexture texture) native;

  void depthFunc(int func) native;

  void depthMask(bool flag) native;

  void depthRange(num zNear, num zFar) native;

  void detachShader(WebGLProgram program, WebGLShader shader) native;

  void disable(int cap) native;

  void disableVertexAttribArray(int index) native;

  void drawArrays(int mode, int first, int count) native;

  void drawElements(int mode, int count, int type, int offset) native;

  void enable(int cap) native;

  void enableVertexAttribArray(int index) native;

  void finish() native;

  void flush() native;

  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer) native;

  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level) native;

  void frontFace(int mode) native;

  void generateMipmap(int target) native;

  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index) native;

  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index) native;

  void getAttachedShaders(WebGLProgram program) native;

  int getAttribLocation(WebGLProgram program, String name) native;

  Object getBufferParameter(int target, int pname) native;

  WebGLContextAttributes getContextAttributes() native;

  int getError() native;

  Object getExtension(String name) native;

  Object getFramebufferAttachmentParameter(int target, int attachment, int pname) native;

  Object getParameter(int pname) native;

  String getProgramInfoLog(WebGLProgram program) native;

  Object getProgramParameter(WebGLProgram program, int pname) native;

  Object getRenderbufferParameter(int target, int pname) native;

  String getShaderInfoLog(WebGLShader shader) native;

  Object getShaderParameter(WebGLShader shader, int pname) native;

  String getShaderSource(WebGLShader shader) native;

  Object getTexParameter(int target, int pname) native;

  Object getUniform(WebGLProgram program, WebGLUniformLocation location) native;

  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name) native;

  Object getVertexAttrib(int index, int pname) native;

  int getVertexAttribOffset(int index, int pname) native;

  void hint(int target, int mode) native;

  bool isBuffer(WebGLBuffer buffer) native;

  bool isContextLost() native;

  bool isEnabled(int cap) native;

  bool isFramebuffer(WebGLFramebuffer framebuffer) native;

  bool isProgram(WebGLProgram program) native;

  bool isRenderbuffer(WebGLRenderbuffer renderbuffer) native;

  bool isShader(WebGLShader shader) native;

  bool isTexture(WebGLTexture texture) native;

  void lineWidth(num width) native;

  void linkProgram(WebGLProgram program) native;

  void pixelStorei(int pname, int param) native;

  void polygonOffset(num factor, num units) native;

  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels) native;

  void releaseShaderCompiler() native;

  void renderbufferStorage(int target, int internalformat, int width, int height) native;

  void sampleCoverage(num value, bool invert) native;

  void scissor(int x, int y, int width, int height) native;

  void shaderSource(WebGLShader shader, String string) native;

  void stencilFunc(int func, int ref, int mask) native;

  void stencilFuncSeparate(int face, int func, int ref, int mask) native;

  void stencilMask(int mask) native;

  void stencilMaskSeparate(int face, int mask) native;

  void stencilOp(int fail, int zfail, int zpass) native;

  void stencilOpSeparate(int face, int fail, int zfail, int zpass) native;

  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, var border_OR_canvas_OR_image_OR_pixels_OR_video, [int format = null, int type = null, ArrayBufferView pixels = null]) native;

  void texParameterf(int target, int pname, num param) native;

  void texParameteri(int target, int pname, int param) native;

  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, var canvas_OR_format_OR_image_OR_pixels_OR_video, [int type = null, ArrayBufferView pixels = null]) native;

  void uniform1f(WebGLUniformLocation location, num x) native;

  void uniform1fv(WebGLUniformLocation location, Float32Array v) native;

  void uniform1i(WebGLUniformLocation location, int x) native;

  void uniform1iv(WebGLUniformLocation location, Int32Array v) native;

  void uniform2f(WebGLUniformLocation location, num x, num y) native;

  void uniform2fv(WebGLUniformLocation location, Float32Array v) native;

  void uniform2i(WebGLUniformLocation location, int x, int y) native;

  void uniform2iv(WebGLUniformLocation location, Int32Array v) native;

  void uniform3f(WebGLUniformLocation location, num x, num y, num z) native;

  void uniform3fv(WebGLUniformLocation location, Float32Array v) native;

  void uniform3i(WebGLUniformLocation location, int x, int y, int z) native;

  void uniform3iv(WebGLUniformLocation location, Int32Array v) native;

  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w) native;

  void uniform4fv(WebGLUniformLocation location, Float32Array v) native;

  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w) native;

  void uniform4iv(WebGLUniformLocation location, Int32Array v) native;

  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array) native;

  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array) native;

  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array) native;

  void useProgram(WebGLProgram program) native;

  void validateProgram(WebGLProgram program) native;

  void vertexAttrib1f(int indx, num x) native;

  void vertexAttrib1fv(int indx, Float32Array values) native;

  void vertexAttrib2f(int indx, num x, num y) native;

  void vertexAttrib2fv(int indx, Float32Array values) native;

  void vertexAttrib3f(int indx, num x, num y, num z) native;

  void vertexAttrib3fv(int indx, Float32Array values) native;

  void vertexAttrib4f(int indx, num x, num y, num z, num w) native;

  void vertexAttrib4fv(int indx, Float32Array values) native;

  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset) native;

  void viewport(int x, int y, int width, int height) native;
}

class WebGLShader native "*WebGLShader" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebGLTexture native "*WebGLTexture" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebGLUniformLocation native "*WebGLUniformLocation" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebGLVertexArrayObjectOES native "*WebGLVertexArrayObjectOES" {

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebKitAnimation native "*WebKitAnimation" {

  static final int DIRECTION_ALTERNATE = 1;

  static final int DIRECTION_NORMAL = 0;

  static final int FILL_BACKWARDS = 1;

  static final int FILL_BOTH = 3;

  static final int FILL_FORWARDS = 2;

  static final int FILL_NONE = 0;

  num delay;

  int direction;

  num duration;

  num elapsedTime;

  bool ended;

  int fillMode;

  int iterationCount;

  String name;

  bool paused;

  void pause() native;

  void play() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebKitAnimationEvent extends Event native "*WebKitAnimationEvent" {

  String animationName;

  num elapsedTime;

  void initWebKitAnimationEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String animationNameArg, num elapsedTimeArg) native;
}

class WebKitAnimationList native "*WebKitAnimationList" {

  int length;

  WebKitAnimation item(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebKitBlobBuilder native "*WebKitBlobBuilder" {

  void append(var arrayBuffer_OR_blob_OR_value, [String endings = null]) native;

  Blob getBlob([String contentType = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebKitCSSFilterValue extends CSSValueList native "*WebKitCSSFilterValue" {

  static final int CSS_FILTER_BLUR = 9;

  static final int CSS_FILTER_DROP_SHADOW = 11;

  static final int CSS_FILTER_GAMMA = 8;

  static final int CSS_FILTER_GRAYSCALE = 2;

  static final int CSS_FILTER_HUE_ROTATE = 5;

  static final int CSS_FILTER_INVERT = 6;

  static final int CSS_FILTER_OPACITY = 7;

  static final int CSS_FILTER_REFERENCE = 1;

  static final int CSS_FILTER_SATURATE = 4;

  static final int CSS_FILTER_SEPIA = 3;

  static final int CSS_FILTER_SHARPEN = 10;

  int operationType;
}

class WebKitCSSKeyframeRule extends CSSRule native "*WebKitCSSKeyframeRule" {

  String keyText;

  CSSStyleDeclaration style;
}

class WebKitCSSKeyframesRule extends CSSRule native "*WebKitCSSKeyframesRule" {

  CSSRuleList cssRules;

  String name;

  void deleteRule(String key) native;

  WebKitCSSKeyframeRule findRule(String key) native;

  void insertRule(String rule) native;
}

class WebKitCSSMatrix native "*WebKitCSSMatrix" {
  WebKitCSSMatrix([String spec]) native;


  num a;

  num b;

  num c;

  num d;

  num e;

  num f;

  num m11;

  num m12;

  num m13;

  num m14;

  num m21;

  num m22;

  num m23;

  num m24;

  num m31;

  num m32;

  num m33;

  num m34;

  num m41;

  num m42;

  num m43;

  num m44;

  WebKitCSSMatrix inverse() native;

  WebKitCSSMatrix multiply(WebKitCSSMatrix secondMatrix) native;

  WebKitCSSMatrix rotate(num rotX, num rotY, num rotZ) native;

  WebKitCSSMatrix rotateAxisAngle(num x, num y, num z, num angle) native;

  WebKitCSSMatrix scale(num scaleX, num scaleY, num scaleZ) native;

  void setMatrixValue(String string) native;

  WebKitCSSMatrix skewX(num angle) native;

  WebKitCSSMatrix skewY(num angle) native;

  String toString() native;

  WebKitCSSMatrix translate(num x, num y, num z) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebKitCSSTransformValue extends CSSValueList native "*WebKitCSSTransformValue" {

  static final int CSS_MATRIX = 11;

  static final int CSS_MATRIX3D = 21;

  static final int CSS_PERSPECTIVE = 20;

  static final int CSS_ROTATE = 4;

  static final int CSS_ROTATE3D = 17;

  static final int CSS_ROTATEX = 14;

  static final int CSS_ROTATEY = 15;

  static final int CSS_ROTATEZ = 16;

  static final int CSS_SCALE = 5;

  static final int CSS_SCALE3D = 19;

  static final int CSS_SCALEX = 6;

  static final int CSS_SCALEY = 7;

  static final int CSS_SCALEZ = 18;

  static final int CSS_SKEW = 8;

  static final int CSS_SKEWX = 9;

  static final int CSS_SKEWY = 10;

  static final int CSS_TRANSLATE = 1;

  static final int CSS_TRANSLATE3D = 13;

  static final int CSS_TRANSLATEX = 2;

  static final int CSS_TRANSLATEY = 3;

  static final int CSS_TRANSLATEZ = 12;

  int operationType;
}

class WebKitFlags native "*WebKitFlags" {

  bool create;

  bool exclusive;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebKitLoseContext native "*WebKitLoseContext" {

  void loseContext() native;

  void restoreContext() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebKitMutationObserver native "*WebKitMutationObserver" {

  void disconnect() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebKitPoint native "*WebKitPoint" {
  WebKitPoint(num x, num y) native;


  num x;

  num y;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WebKitTransitionEvent extends Event native "*WebKitTransitionEvent" {

  num elapsedTime;

  String propertyName;

  void initWebKitTransitionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String propertyNameArg, num elapsedTimeArg) native;
}

class WebSocket native "*WebSocket" {
  WebSocket(String url) native;


  static final int CLOSED = 3;

  static final int CLOSING = 2;

  static final int CONNECTING = 0;

  static final int OPEN = 1;

  String URL;

  String binaryType;

  int bufferedAmount;

  String extensions;

  String protocol;

  int readyState;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void close([int code = null, String reason = null]) native;

  bool dispatchEvent(Event evt) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  bool send(String data) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WheelEvent extends UIEvent native "*WheelEvent" {

  bool altKey;

  int clientX;

  int clientY;

  bool ctrlKey;

  bool metaKey;

  int offsetX;

  int offsetY;

  int screenX;

  int screenY;

  bool shiftKey;

  bool webkitDirectionInvertedFromDevice;

  int wheelDelta;

  int wheelDeltaX;

  int wheelDeltaY;

  int x;

  int y;

  void initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, DOMWindow view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) native;
}

class Worker extends AbstractWorker native "*Worker" {

  void postMessage(String message, [List messagePorts = null]) native;

  void terminate() native;

  void webkitPostMessage(String message, [List messagePorts = null]) native;
}

class WorkerContext native "*WorkerContext" {

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  WorkerLocation location;

  WorkerNavigator navigator;

  EventListener onerror;

  WorkerContext self;

  NotificationCenter webkitNotifications;

  DOMURL webkitURL;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void clearInterval(int handle) native;

  void clearTimeout(int handle) native;

  void close() native;

  bool dispatchEvent(Event evt) native;

  void importScripts() native;

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) native;

  DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  int setInterval(TimeoutHandler handler, int timeout) native;

  int setTimeout(TimeoutHandler handler, int timeout) native;

  void webkitRequestFileSystem(int type, int size, [FileSystemCallback successCallback = null, ErrorCallback errorCallback = null]) native;

  DOMFileSystemSync webkitRequestFileSystemSync(int type, int size) native;

  EntrySync webkitResolveLocalFileSystemSyncURL(String url) native;

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback = null, ErrorCallback errorCallback = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WorkerLocation native "*WorkerLocation" {

  String hash;

  String host;

  String hostname;

  String href;

  String pathname;

  String port;

  String protocol;

  String search;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class WorkerNavigator native "*WorkerNavigator" {

  String appName;

  String appVersion;

  bool onLine;

  String platform;

  String userAgent;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class XMLHttpRequest native "*XMLHttpRequest" {
  XMLHttpRequest() native;


  static final int DONE = 4;

  static final int HEADERS_RECEIVED = 2;

  static final int LOADING = 3;

  static final int OPENED = 1;

  static final int UNSENT = 0;

  bool asBlob;

  int readyState;

  Blob responseBlob;

  String responseText;

  String responseType;

  Document responseXML;

  int status;

  String statusText;

  XMLHttpRequestUpload upload;

  bool withCredentials;

  void abort() native;

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  bool dispatchEvent(Event evt) native;

  String getAllResponseHeaders() native;

  String getResponseHeader(String header) native;

  void open(String method, String url, [bool async = null, String user = null, String password = null]) native;

  void overrideMimeType(String override) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  void send([var data = null]) native;

  void setRequestHeader(String header, String value) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class XMLHttpRequestException native "*XMLHttpRequestException" {

  static final int ABORT_ERR = 102;

  static final int NETWORK_ERR = 101;

  int code;

  String message;

  String name;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class XMLHttpRequestProgressEvent extends ProgressEvent native "*XMLHttpRequestProgressEvent" {

  int position;

  int totalSize;
}

class XMLHttpRequestUpload native "*XMLHttpRequestUpload" {

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  bool dispatchEvent(Event evt) native;

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class XMLSerializer native "*XMLSerializer" {

  String serializeToString(Node node) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class XPathEvaluator native "*XPathEvaluator" {

  XPathExpression createExpression(String expression, XPathNSResolver resolver) native;

  XPathNSResolver createNSResolver(Node nodeResolver) native;

  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class XPathException native "*XPathException" {

  static final int INVALID_EXPRESSION_ERR = 51;

  static final int TYPE_ERR = 52;

  int code;

  String message;

  String name;

  String toString() native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class XPathExpression native "*XPathExpression" {

  XPathResult evaluate(Node contextNode, int type, XPathResult inResult) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class XPathNSResolver native "*XPathNSResolver" {

  String lookupNamespaceURI(String prefix) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class XPathResult native "*XPathResult" {

  static final int ANY_TYPE = 0;

  static final int ANY_UNORDERED_NODE_TYPE = 8;

  static final int BOOLEAN_TYPE = 3;

  static final int FIRST_ORDERED_NODE_TYPE = 9;

  static final int NUMBER_TYPE = 1;

  static final int ORDERED_NODE_ITERATOR_TYPE = 5;

  static final int ORDERED_NODE_SNAPSHOT_TYPE = 7;

  static final int STRING_TYPE = 2;

  static final int UNORDERED_NODE_ITERATOR_TYPE = 4;

  static final int UNORDERED_NODE_SNAPSHOT_TYPE = 6;

  bool booleanValue;

  bool invalidIteratorState;

  num numberValue;

  int resultType;

  Node singleNodeValue;

  int snapshotLength;

  String stringValue;

  Node iterateNext() native;

  Node snapshotItem(int index) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}

class XSLTProcessor native "*XSLTProcessor" {

  void clearParameters() native;

  String getParameter(String namespaceURI, String localName) native;

  void importStylesheet(Node stylesheet) native;

  void removeParameter(String namespaceURI, String localName) native;

  void reset() native;

  void setParameter(String namespaceURI, String localName, String value) native;

  Document transformToDocument(Node source) native;

  DocumentFragment transformToFragment(Node source, Document docVal) native;

  var dartObjectLocalStorage;

  String get typeName() native;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool AudioBufferCallback(AudioBuffer audioBuffer);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool DatabaseCallback(var database);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool EntriesCallback(EntryArray entries);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool EntryCallback(Entry entry);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool ErrorCallback(FileError error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileCallback(File file);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileSystemCallback(DOMFileSystem fileSystem);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileWriterCallback(FileWriter fileWriter);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool MetadataCallback(Metadata metadata);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool NavigatorUserMediaErrorCallback(NavigatorUserMediaError error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool PositionCallback(Geoposition position);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool PositionErrorCallback(PositionError error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLStatementCallback(SQLTransaction transaction, SQLResultSet resultSet);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLStatementErrorCallback(SQLTransaction transaction, SQLError error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionCallback(SQLTransaction transaction);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionErrorCallback(SQLError error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionSyncCallback(SQLTransactionSync transaction);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoErrorCallback(DOMException error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoQuotaCallback(int grantedQuotaInBytes);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoUsageCallback(int currentUsageInBytes, int currentQuotaInBytes);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StringCallback(String data);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef void VoidCallback();
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef void EventListener(Event event);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the standard key locations returned by
 * KeyboardEvent.getKeyLocation.
 */
interface KeyLocation {

  /**
   * The event key is not distinguished as the left or right version
   * of the key, and did not originate from the numeric keypad (or did not
   * originate with a virtual key corresponding to the numeric keypad).
   */
  static final int STANDARD = 0;

  /**
   * The event key is in the left key location.
   */
  static final int LEFT = 1;

  /**
   * The event key is in the right key location.
   */
  static final int RIGHT = 2;

  /**
   * The event key originated on the numeric keypad or with a virtual key
   * corresponding to the numeric keypad.
   */
  static final int NUMPAD = 3;

  /**
   * The event key originated on a mobile device, either on a physical
   * keypad or a virtual keyboard.
   */
  static final int MOBILE = 4;

  /**
   * The event key originated on a game controller or a joystick on a mobile
   * device.
   */
  static final int JOYSTICK = 5;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the standard keyboard identifier names for keys that are returned
 * by KeyEvent.getKeyboardIdentifier when the key does not have a direct
 * unicode mapping.
 */
interface KeyName {

  /** The Accept (Commit, OK) key */
  static final String ACCEPT = "Accept";

  /** The Add key */
  static final String ADD = "Add";

  /** The Again key */
  static final String AGAIN = "Again";

  /** The All Candidates key */
  static final String ALL_CANDIDATES = "AllCandidates";

  /** The Alphanumeric key */
  static final String ALPHANUMERIC = "Alphanumeric";

  /** The Alt (Menu) key */
  static final String ALT = "Alt";

  /** The Alt-Graph key */
  static final String ALT_GRAPH = "AltGraph";

  /** The Application key */
  static final String APPS = "Apps";

  /** The ATTN key */
  static final String ATTN = "Attn";

  /** The Browser Back key */
  static final String BROWSER_BACK = "BrowserBack";

  /** The Browser Favorites key */
  static final String BROWSER_FAVORTIES = "BrowserFavorites";

  /** The Browser Forward key */
  static final String BROWSER_FORWARD = "BrowserForward";

  /** The Browser Home key */
  static final String BROWSER_NAME = "BrowserHome";

  /** The Browser Refresh key */
  static final String BROWSER_REFRESH = "BrowserRefresh";

  /** The Browser Search key */
  static final String BROWSER_SEARCH = "BrowserSearch";

  /** The Browser Stop key */
  static final String BROWSER_STOP = "BrowserStop";

  /** The Camera key */
  static final String CAMERA = "Camera";

  /** The Caps Lock (Capital) key */
  static final String CAPS_LOCK = "CapsLock";

  /** The Clear key */
  static final String CLEAR = "Clear";

  /** The Code Input key */
  static final String CODE_INPUT = "CodeInput";

  /** The Compose key */
  static final String COMPOSE = "Compose";

  /** The Control (Ctrl) key */
  static final String CONTROL = "Control";

  /** The Crsel key */
  static final String CRSEL = "Crsel";

  /** The Convert key */
  static final String CONVERT = "Convert";

  /** The Copy key */
  static final String COPY = "Copy";

  /** The Cut key */
  static final String CUT = "Cut";

  /** The Decimal key */
  static final String DECIMAL = "Decimal";

  /** The Divide key */
  static final String DIVIDE = "Divide";

  /** The Down Arrow key */
  static final String DOWN = "Down";

  /** The diagonal Down-Left Arrow key */
  static final String DOWN_LEFT = "DownLeft";

  /** The diagonal Down-Right Arrow key */
  static final String DOWN_RIGHT = "DownRight";

  /** The Eject key */
  static final String EJECT = "Eject";

  /** The End key */
  static final String END = "End";

  /**
   * The Enter key. Note: This key value must also be used for the Return
   *  (Macintosh numpad) key
   */
  static final String ENTER = "Enter";

  /** The Erase EOF key */
  static final String ERASE_EOF= "EraseEof";

  /** The Execute key */
  static final String EXECUTE = "Execute";

  /** The Exsel key */
  static final String EXSEL = "Exsel";

  /** The Function switch key */
  static final String FN = "Fn";

  /** The F1 key */
  static final String F1 = "F1";

  /** The F2 key */
  static final String F2 = "F2";

  /** The F3 key */
  static final String F3 = "F3";

  /** The F4 key */
  static final String F4 = "F4";

  /** The F5 key */
  static final String F5 = "F5";

  /** The F6 key */
  static final String F6 = "F6";

  /** The F7 key */
  static final String F7 = "F7";

  /** The F8 key */
  static final String F8 = "F8";

  /** The F9 key */
  static final String F9 = "F9";

  /** The F10 key */
  static final String F10 = "F10";

  /** The F11 key */
  static final String F11 = "F11";

  /** The F12 key */
  static final String F12 = "F12";

  /** The F13 key */
  static final String F13 = "F13";

  /** The F14 key */
  static final String F14 = "F14";

  /** The F15 key */
  static final String F15 = "F15";

  /** The F16 key */
  static final String F16 = "F16";

  /** The F17 key */
  static final String F17 = "F17";

  /** The F18 key */
  static final String F18 = "F18";

  /** The F19 key */
  static final String F19 = "F19";

  /** The F20 key */
  static final String F20 = "F20";

  /** The F21 key */
  static final String F21 = "F21";

  /** The F22 key */
  static final String F22 = "F22";

  /** The F23 key */
  static final String F23 = "F23";

  /** The F24 key */
  static final String F24 = "F24";

  /** The Final Mode (Final) key used on some asian keyboards */
  static final String FINAL_MODE = "FinalMode";

  /** The Find key */
  static final String FIND = "Find";

  /** The Full-Width Characters key */
  static final String FULL_WIDTH = "FullWidth";

  /** The Half-Width Characters key */
  static final String HALF_WIDTH = "HalfWidth";

  /** The Hangul (Korean characters) Mode key */
  static final String HANGUL_MODE = "HangulMode";

  /** The Hanja (Korean characters) Mode key */
  static final String HANJA_MODE = "HanjaMode";

  /** The Help key */
  static final String HELP = "Help";

  /** The Hiragana (Japanese Kana characters) key */
  static final String HIRAGANA = "Hiragana";

  /** The Home key */
  static final String HOME = "Home";

  /** The Insert (Ins) key */
  static final String INSERT = "Insert";

  /** The Japanese-Hiragana key */
  static final String JAPANESE_HIRAGANA = "JapaneseHiragana";

  /** The Japanese-Katakana key */
  static final String JAPANESE_KATAKANA = "JapaneseKatakana";

  /** The Japanese-Romaji key */
  static final String JAPANESE_ROMAJI = "JapaneseRomaji";

  /** The Junja Mode key */
  static final String JUNJA_MODE = "JunjaMode";

  /** The Kana Mode (Kana Lock) key */
  static final String KANA_MODE = "KanaMode";

  /**
   * The Kanji (Japanese name for ideographic characters of Chinese origin)
   * Mode key
   */
  static final String KANJI_MODE = "KanjiMode";

  /** The Katakana (Japanese Kana characters) key */
  static final String KATAKANA = "Katakana";

  /** The Start Application One key */
  static final String LAUNCH_APPLICATION_1 = "LaunchApplication1";

  /** The Start Application Two key */
  static final String LAUNCH_APPLICATION_2 = "LaunchApplication2";

  /** The Start Mail key */
  static final String LAUNCH_MAIL = "LaunchMail";

  /** The Left Arrow key */
  static final String LEFT = "Left";

  /** The Menu key */
  static final String MENU = "Menu";

  /**
   * The Meta key. Note: This key value shall be also used for the Apple
   * Command key
   */
  static final String META = "Meta";

  /** The Media Next Track key */
  static final String MEDIA_NEXT_TRACK = "MediaNextTrack";

  /** The Media Play Pause key */
  static final String MEDIA_PAUSE_PLAY = "MediaPlayPause";

  /** The Media Previous Track key */
  static final String MEDIA_PREVIOUS_TRACK = "MediaPreviousTrack";

  /** The Media Stop key */
  static final String MEDIA_STOP = "MediaStop";

  /** The Mode Change key */
  static final String MODE_CHANGE = "ModeChange";

  /** The Next Candidate function key */
  static final String NEXT_CANDIDATE = "NextCandidate";

  /** The Nonconvert (Don't Convert) key */
  static final String NON_CONVERT = "Nonconvert";

  /** The Number Lock key */
  static final String NUM_LOCK = "NumLock";

  /** The Page Down (Next) key */
  static final String PAGE_DOWN = "PageDown";

  /** The Page Up key */
  static final String PAGE_UP = "PageUp";

  /** The Paste key */
  static final String PASTE = "Paste";

  /** The Pause key */
  static final String PAUSE = "Pause";

  /** The Play key */
  static final String PLAY = "Play";

  /**
   * The Power key. Note: Some devices may not expose this key to the
   * operating environment
   */
  static final String POWER = "Power";

  /** The Previous Candidate function key */
  static final String PREVIOUS_CANDIDATE = "PreviousCandidate";

  /** The Print Screen (PrintScrn, SnapShot) key */
  static final String PRINT_SCREEN = "PrintScreen";

  /** The Process key */
  static final String PROCESS = "Process";

  /** The Props key */
  static final String PROPS = "Props";

  /** The Right Arrow key */
  static final String RIGHT = "Right";

  /** The Roman Characters function key */
  static final String ROMAN_CHARACTERS = "RomanCharacters";

  /** The Scroll Lock key */
  static final String SCROLL = "Scroll";

  /** The Select key */
  static final String SELECT = "Select";

  /** The Select Media key */
  static final String SELECT_MEDIA = "SelectMedia";

  /** The Separator key */
  static final String SEPARATOR = "Separator";

  /** The Shift key */
  static final String SHIFT = "Shift";

  /** The Soft1 key */
  static final String SOFT_1 = "Soft1";

  /** The Soft2 key */
  static final String SOFT_2 = "Soft2";

  /** The Soft3 key */
  static final String SOFT_3 = "Soft3";

  /** The Soft4 key */
  static final String SOFT_4 = "Soft4";

  /** The Stop key */
  static final String STOP = "Stop";

  /** The Subtract key */
  static final String SUBTRACT = "Subtract";

  /** The Symbol Lock key */
  static final String SYMBOL_LOCK = "SymbolLock";

  /** The Up Arrow key */
  static final String UP = "Up";

  /** The diagonal Up-Left Arrow key */
  static final String UP_LEFT = "UpLeft";

  /** The diagonal Up-Right Arrow key */
  static final String UP_RIGHT = "UpRight";

  /** The Undo key */
  static final String UNDO = "Undo";

  /** The Volume Down key */
  static final String VOLUME_DOWN = "VolumeDown";

  /** The Volume Mute key */
  static final String VOLUMN_MUTE = "VolumeMute";

  /** The Volume Up key */
  static final String VOLUMN_UP = "VolumeUp";

  /** The Windows Logo key */
  static final String WIN = "Win";

  /** The Zoom key */
  static final String ZOOM = "Zoom";

  /**
   * The Backspace (Back) key. Note: This key value shall be also used for the
   * key labeled 'delete' MacOS keyboards when not modified by the 'Fn' key
   */
  static final String BACKSPACE = "Backspace";

  /** The Horizontal Tabulation (Tab) key */
  static final String TAB = "Tab";

  /** The Cancel key */
  static final String CANCEL = "Cancel";

  /** The Escape (Esc) key */
  static final String ESC = "Esc";

  /** The Space (Spacebar) key:   */
  static final String SPACEBAR = "Spacebar";

  /**
   * The Delete (Del) Key. Note: This key value shall be also used for the key
   * labeled 'delete' MacOS keyboards when modified by the 'Fn' key
   */
  static final String DEL = "Del";

  /** The Combining Grave Accent (Greek Varia, Dead Grave) key */
  static final String DEAD_GRAVE = "DeadGrave";

  /**
   * The Combining Acute Accent (Stress Mark, Greek Oxia, Tonos, Dead Eacute)
   * key
   */
  static final String DEAD_EACUTE = "DeadEacute";

  /** The Combining Circumflex Accent (Hat, Dead Circumflex) key */
  static final String DEAD_CIRCUMFLEX = "DeadCircumflex";

  /** The Combining Tilde (Dead Tilde) key */
  static final String DEAD_TILDE = "DeadTilde";

  /** The Combining Macron (Long, Dead Macron) key */
  static final String DEAD_MACRON = "DeadMacron";

  /** The Combining Breve (Short, Dead Breve) key */
  static final String DEAD_BREVE = "DeadBreve";

  /** The Combining Dot Above (Derivative, Dead Above Dot) key */
  static final String DEAD_ABOVE_DOT = "DeadAboveDot";

  /**
   * The Combining Diaeresis (Double Dot Abode, Umlaut, Greek Dialytika,
   * Double Derivative, Dead Diaeresis) key
   */
  static final String DEAD_UMLAUT = "DeadUmlaut";

  /** The Combining Ring Above (Dead Above Ring) key */
  static final String DEAD_ABOVE_RING = "DeadAboveRing";

  /** The Combining Double Acute Accent (Dead Doubleacute) key */
  static final String DEAD_DOUBLEACUTE = "DeadDoubleacute";

  /** The Combining Caron (Hacek, V Above, Dead Caron) key */
  static final String DEAD_CARON = "DeadCaron";

  /** The Combining Cedilla (Dead Cedilla) key */
  static final String DEAD_CEDILLA = "DeadCedilla";

  /** The Combining Ogonek (Nasal Hook, Dead Ogonek) key */
  static final String DEAD_OGONEK = "DeadOgonek";

  /**
   * The Combining Greek Ypogegrammeni (Greek Non-Spacing Iota Below, Iota
   * Subscript, Dead Iota) key
   */
  static final String DEAD_IOTA = "DeadIota";

  /**
   * The Combining Katakana-Hiragana Voiced Sound Mark (Dead Voiced Sound) key
   */
  static final String DEAD_VOICED_SOUND = "DeadVoicedSound";

  /**
   * The Combining Katakana-Hiragana Semi-Voiced Sound Mark (Dead Semivoiced
   * Sound) key
   */
  static final String DEC_SEMIVOICED_SOUND= "DeadSemivoicedSound";

  /**
   * Key value used when an implementation is unable to identify another key
   * value, due to either hardware, platform, or software constraints
   */
  static final String UNIDENTIFIED = "Unidentified";
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef bool RequestAnimationFrameCallback(int time);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef void TimeoutHandler();
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The [Collections] class implements static methods useful when
 * writing a class that implements [Collection] and the [iterator]
 * method.
 */
class _Collections {
  static void forEach(Iterable<Object> iterable, void f(Object o)) {
    for (final e in iterable) {
      f(e);
    }
  }

  static bool some(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (f(e)) return true;
    }
    return false;
  }

  static bool every(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (!f(e)) return false;
    }
    return true;
  }

  static List filter(Iterable<Object> source,
                     List<Object> destination,
                     bool f(o)) {
    for (final e in source) {
      if (f(e)) destination.add(e);
    }
    return destination;
  }

  static bool isEmpty(Iterable<Object> iterable) {
    return !iterable.iterator().hasNext();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Iterator for arrays with fixed size.
class _FixedSizeListIterator<T> extends _VariableSizeListIterator<T> {
  _FixedSizeListIterator(List<T> array)
      : super(array),
        _length = array.length;

  bool hasNext() => _length > _pos;

  final int _length;  // Cache array length for faster access.
}

// Iterator for arrays with variable size.
class _VariableSizeListIterator<T> implements Iterator<T> {
  _VariableSizeListIterator(List<T> array)
      : _array = array,
        _pos = 0;

  bool hasNext() => _array.length > _pos;

  T next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }
    return _array[_pos++];
  }

  final List<T> _array;
  int _pos;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _Lists {

  /**
   * Returns the index in the array [a] of the given [element], starting
   * the search at index [startIndex] to [endIndex] (exclusive).
   * Returns -1 if [element] is not found.
   */
  static int indexOf(List a,
                     Object element,
                     int startIndex,
                     int endIndex) {
    if (startIndex >= a.length) {
      return -1;
    }
    if (startIndex < 0) {
      startIndex = 0;
    }
    for (int i = startIndex; i < endIndex; i++) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns the last index in the array [a] of the given [element], starting
   * the search at index [startIndex] to 0.
   * Returns -1 if [element] is not found.
   */
  static int lastIndexOf(List a, Object element, int startIndex) {
    if (startIndex < 0) {
      return -1;
    }
    if (startIndex >= a.length) {
      startIndex = a.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }
}

</script>
<script type="application//inert" id="frog_dom_frog_js">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jmesserly): we need to find a way to avoid conflicts with other
// generated "typeName" fields. Ideally we wouldn't be patching 'Object' here.
Object.prototype.get$typeName = Object.prototype.$typeNameOf;

</script>
<script type="application//inert" id="implementation_dual_pivot_quicksort_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Dual-Pivot Quicksort algorithm.
 *
 * This class implements the dual-pivot quicksort algorithm as presented in
 * Vladimir Yaroslavskiy's paper.
 *
 * Some improvements have been copied from Android's implementation.
 */
class DualPivotQuicksort {
  // When a list has less then [:_INSERTION_SORT_THRESHOLD:] elements it will
  // be sorted by an insertion sort.
  static final int _INSERTION_SORT_THRESHOLD = 32;

  /**
   * Sorts all elements of the given list [:a:] according to the given
   * [:compare:] function.
   *
   * The [:compare:] function takes two arguments [:x:] and [:y:] and returns
   *  -1 if [:x < y:],
   *   0 if [:x == y:], and
   *   1 if [:x > y:].
   *
   * The function's behavior must be consistent. It must not return different
   * results for the same values.
   */
  static void sort(List a, int compare(a, b)) {
    _doSort(a, 0, a.length - 1, compare);
  }

  /**
   * Sorts all elements in the range [:from:] (inclusive) to [:to:] (exclusive)
   * of the given list [:a:].
   *
   * If the given range is invalid an "OutOfRange" error is raised.
   * TODO(floitsch): do we want an error?
   *
   * See [:sort:] for requirements of the [:compare:] function.
   */
  static void sortRange(List a, int from, int to, int compare(a, b)) {
    if ((from < 0) || (to > a.length) || (to < from)) {
      throw "OutOfRange";
    }
    _doSort(a, from, to - 1, compare);
  }

  /**
   * Sorts the list in the interval [:left:] to [:right:] (both inclusive).
   */
  static void _doSort(List a, int left, int right, int compare(a, b)) {
    if ((right - left) <= _INSERTION_SORT_THRESHOLD) {
      insertionSort_(a, left, right, compare);
    } else {
      _dualPivotQuicksort(a, left, right, compare);
    }
  }

  static void insertionSort_(List a, int left, int right, int compare(a, b)) {
    for (int i = left + 1; i <= right; i++) {
      var el = a[i];
      int j = i;
      while ((j > left) && (compare(a[j - 1], el) > 0)) {
        a[j] = a[j - 1];
        j--;
      }
      a[j] = el;
    }
  }

  static void _dualPivotQuicksort(List a,
                                  int left, int right,
                                  int compare(a, b)) {
    assert(right - left > _INSERTION_SORT_THRESHOLD);

    // Compute the two pivots by looking at 5 elements.
    int sixth = (right - left + 1) ~/ 6;
    int index1 = left + sixth;
    int index5 = right - sixth;
    int index3 = (left + right) ~/ 2;  // The midpoint.
    int index2 = index3 - sixth;
    int index4 = index3 + sixth;

    var el1 = a[index1];
    var el2 = a[index2];
    var el3 = a[index3];
    var el4 = a[index4];
    var el5 = a[index5];

    // Sort the selected 5 elements using a sorting network.
    if (compare(el1, el2) > 0) { var t = el1; el1 = el2; el2 = t; }
    if (compare(el4, el5) > 0) { var t = el4; el4 = el5; el5 = t; }
    if (compare(el1, el3) > 0) { var t = el1; el1 = el3; el3 = t; }
    if (compare(el2, el3) > 0) { var t = el2; el2 = el3; el3 = t; }
    if (compare(el1, el4) > 0) { var t = el1; el1 = el4; el4 = t; }
    if (compare(el3, el4) > 0) { var t = el3; el3 = el4; el4 = t; }
    if (compare(el2, el5) > 0) { var t = el2; el2 = el5; el5 = t; }
    if (compare(el2, el3) > 0) { var t = el2; el2 = el3; el3 = t; }
    if (compare(el4, el5) > 0) { var t = el4; el4 = el5; el5 = t; }

    var pivot1 = el2;
    var pivot2 = el4;

    // el2 and el4 have been saved in the pivot variables. They will be written
    // back, once the partioning is finished.
    a[index1] = el1;
    a[index3] = el3;
    a[index5] = el5;

    a[index2] = a[left];
    a[index4] = a[right];

    int less = left + 1;    // First element in the middle partition.
    int great = right - 1;  // Last element in the middle partition.

    bool pivots_are_equal = (compare(pivot1, pivot2) == 0);
    if (pivots_are_equal) {
      var pivot = pivot1;
      // Degenerated case where the partioning becomes a dutch national flag
      // problem.
      //
      // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]
      //  ^             ^          ^             ^            ^
      // left         less         k           great         right
      //
      // a[left] and a[right] are undefined and are filled after the
      // partitioning.
      //
      // Invariants:
      //   1) for x in ]left, less[ : x < pivot.
      //   2) for x in [less, k[ : x == pivot.
      //   3) for x in ]great, right[ : x > pivot.
      for (int k = less; k <= great; k++) {
        var ak = a[k];
        int comp = compare(ak, pivot);
        if (comp == 0) continue;
        if (comp < 0) {
          if (k != less) {
            a[k] = a[less];
            a[less] = ak;
          }
          less++;
        } else {
          // comp > 0.
          //
          // Find the first element <= pivot in the range [k - 1, great] and
          // put [:ak:] there. We know that such an element must exist:
          // When k == less, then el3 (which is equal to pivot) lies in the
          // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.
          // Note that in the latter case invariant 2 will be violated for a
          // short amount of time. The invariant will be restored when the
          // pivots are put into their final positions.
          while (true) {
            comp = compare(a[great], pivot);
            if (comp > 0) {
              great--;
              // This is the only location in the while-loop where a new
              // iteration is started.
              continue;
            } else if (comp < 0) {
              // Triple exchange.
              a[k] = a[less];
              a[less++] = a[great];
              a[great--] = ak;
              break;
            } else {
              // comp == 0;
              a[k] = a[great];
              a[great--] = ak;
              // Note: if great < k then we will exit the outer loop and fix
              // invariant 2 (which we just violated).
              break;
            }
          }
        }
      }
    } else {
      // We partition the list into three parts:
      //  1. < pivot1
      //  2. >= pivot1 && <= pivot2
      //  3. > pivot2
      //
      // During the loop we have:
      // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]
      //  ^            ^                        ^              ^             ^
      // left         less                     k              great        right
      //
      // a[left] and a[right] are undefined and are filled after the
      // partitioning.
      //
      // Invariants:
      //   1. for x in ]left, less[ : x < pivot1
      //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2
      //   3. for x in ]great, right[ : x > pivot2
      for (int k = less; k <= great; k++) {
        var ak = a[k];
        int comp_pivot1 = compare(ak, pivot1);
        if (comp_pivot1 < 0) {
          if (k != less) {
            a[k] = a[less];
            a[less] = ak;
          }
          less++;
        } else {
          int comp_pivot2 = compare(ak, pivot2);
          if (comp_pivot2 > 0) {
            while (true) {
              int comp = compare(a[great], pivot2);
              if (comp > 0) {
                great--;
                if (great < k) break;
                // This is the only location inside the loop where a new
                // iteration is started.
                continue;
              } else {
                // a[great] <= pivot2.
                comp = compare(a[great], pivot1);
                if (comp < 0) {
                  // Triple exchange.
                  a[k] = a[less];
                  a[less++] = a[great];
                  a[great--] = ak;
                } else {
                  // a[great] >= pivot1.
                  a[k] = a[great];
                  a[great--] = ak;
                }
                break;
              }
            }
          }
        }
      }
    }

    // Move pivots into their final positions.
    // We shrunk the list from both sides (a[left] and a[right] have
    // meaningless values in them) and now we move elements from the first
    // and third partition into these locations so that we can store the
    // pivots.
    a[left] = a[less - 1];
    a[less - 1] = pivot1;
    a[right] = a[great + 1];
    a[great + 1] = pivot2;

    // The list is now partitioned into three partitions:
    // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]
    //  ^            ^                        ^             ^
    // left         less                     great        right

    // Recursive descent. (Don't include the pivot values.)
    _doSort(a, left, less - 2, compare);
    _doSort(a, great + 2, right, compare);

    if (pivots_are_equal) {
      // All elements in the second partition are equal to the pivot. No
      // need to sort them.
      return;
    }

    // In theory it should be enough to call _doSort recursively on the second
    // partition.
    // The Android source however removes the pivot elements from the recursive
    // call if the second partition is too large (more than 2/3 of the list).
    if (less < index1 && great > index5) {
      while (compare(a[less], pivot1) == 0) { less++; }
      while (compare(a[great], pivot2) == 0) { great--; }

      // Copy paste of the previous 3-way partitioning with adaptions.
      //
      // We partition the list into three parts:
      //  1. == pivot1
      //  2. > pivot1 && < pivot2
      //  3. == pivot2
      //
      // During the loop we have:
      // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]
      //              ^                      ^              ^
      //            less                     k              great
      //
      // Invariants:
      //   1. for x in [ *, less[ : x == pivot1
      //   2. for x in [less, k[ : pivot1 < x && x < pivot2
      //   3. for x in ]great, * ] : x == pivot2
      for (int k = less; k <= great; k++) {
        var ak = a[k];
        int comp_pivot1 = compare(ak, pivot1);
        if (comp_pivot1 == 0) {
          if (k != less) {
            a[k] = a[less];
            a[less] = ak;
          }
          less++;
        } else {
          int comp_pivot2 = compare(ak, pivot2);
          if (comp_pivot2 == 0) {
            while (true) {
              int comp = compare(a[great], pivot2);
              if (comp == 0) {
                great--;
                if (great < k) break;
                // This is the only location inside the loop where a new
                // iteration is started.
                continue;
              } else {
                // a[great] < pivot2.
                comp = compare(a[great], pivot1);
                if (comp < 0) {
                  // Triple exchange.
                  a[k] = a[less];
                  a[less++] = a[great];
                  a[great--] = ak;
                } else {
                  // a[great] == pivot1.
                  a[k] = a[great];
                  a[great--] = ak;
                }
                break;
              }
            }
          }
        }
      }
      // The second partition has now been cleared of pivot elements and looks
      // as follows:
      // [  *  |  > pivot1 && < pivot2  | * ]
      //        ^                      ^
      //       less                  great
      // Sort the second partition using recursive descent.
      _doSort(a, less, great, compare);
    } else {
      // The second partition looks as follows:
      // [  *  |  >= pivot1 && <= pivot2  | * ]
      //        ^                        ^
      //       less                    great
      // Simply sort it by recursive descent.
      _doSort(a, less, great, compare);
    }
  }
}

</script>
<script type="application//inert" id="implementation_duration_implementation_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

class DurationImplementation implements Duration {
  final int inMilliseconds;

  const DurationImplementation([int days = 0,
                                int hours = 0,
                                int minutes = 0,
                                int seconds = 0,
                                int milliseconds = 0])
    : inMilliseconds = days * Duration.MILLISECONDS_PER_DAY +
                       hours * Duration.MILLISECONDS_PER_HOUR +
                       minutes * Duration.MILLISECONDS_PER_MINUTE +
                       seconds * Duration.MILLISECONDS_PER_SECOND +
                       milliseconds;

  int get inDays() {
    return inMilliseconds ~/ Duration.MILLISECONDS_PER_DAY;
  }

  int get inHours() {
    return inMilliseconds ~/ Duration.MILLISECONDS_PER_HOUR;
  }

  int get inMinutes() {
    return inMilliseconds ~/ Duration.MILLISECONDS_PER_MINUTE;
  }

  int get inSeconds() {
    return inMilliseconds ~/ Duration.MILLISECONDS_PER_SECOND;
  }

  bool operator ==(other) {
    if (other is !Duration) return false;
    return inMilliseconds == other.inMilliseconds;
  }

  int hashCode() {
    return inMilliseconds.hashCode();
  }

  int compareTo(Duration other) {
    return inMilliseconds.compareTo(other.inMilliseconds);
  }

  String toString() {
    String threeDigits(int n) {
      if (n >= 100) return "${n}";
      if (n > 10) return "0${n}";
      return "00${n}";
    }
    String twoDigits(int n) {
      if (n >= 10) return "${n}";
      return "0${n}";
    }

    if (inMilliseconds < 0) {
      Duration duration =
          new DurationImplementation(milliseconds: -inMilliseconds);
      return "-${duration}";
    }
    String twoDigitMinutes =
        twoDigits(inMinutes.remainder(Duration.MINUTES_PER_HOUR));
    String twoDigitSeconds =
        twoDigits(inSeconds.remainder(Duration.SECONDS_PER_MINUTE));
    String threeDigitMs =
        threeDigits(inMilliseconds.remainder(Duration.MILLISECONDS_PER_SECOND));
    return "${inHours}:${twoDigitMinutes}:${twoDigitSeconds}.${threeDigitMs}";
  }
}

</script>
<script type="application//inert" id="implementation_exceptions_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class ExceptionImplementation implements Exception {
  const ExceptionImplementation([msg = null]) : _msg = msg;
  String toString() => (_msg === null) ? "Exception" : "Exception: $_msg";
  final _msg;
}

</script>
<script type="application//inert" id="implementation_future_implementation_dart">
// Copyright 2011 Google Inc. All Rights Reserved.
// Dart core library.

/**
 * Thrown if client tries to obtain value or exception
 * before a future has completed.
 */
class FutureNotCompleteException implements Exception {
  FutureNotCompleteException() {}
}

/**
 * Thrown if a completer tries to set the value on
 * a future that is already complete.
 */
class FutureAlreadyCompleteException implements Exception {
  FutureAlreadyCompleteException() {}
}


class FutureImpl<T> implements Future<T> {

  bool _isComplete;

  /**
   * Value that was provided to this Future by the Completer
   */
  T _value;

  /**
   * Exception that occured, if there was a problem providing
   * Value.
   */
  Object _exception;

  /**
   * true, if any onException handler handled the exception.
   */
  bool _exceptionHandled;

  /**
   * Listeners waiting to receive the value of this future.
   */
  final List<Function> _listeners;

  /**
   * Exception handlers waiting for exceptions.
   */
  final List<Function> _exceptionHandlers;

  FutureImpl() : _listeners = new List(), _exceptionHandlers = new List() {
    _isComplete = false;
    _exceptionHandled = false;
  }

  T get value() {
    if (!isComplete) {
      throw new FutureNotCompleteException();
    }
    if (_exception !== null) {
      throw _exception;
    }
    return _value;
  }

  Object get exception() {
    if (!isComplete) {
      throw new FutureNotCompleteException();
    }
    return _exception;
  }

  bool get isComplete() {
    return _isComplete;
  }

  bool get hasValue() {
    return isComplete && _exception === null;
  }

  void then(void onComplete(T value)) {
    if (hasValue) {
      onComplete(value);
    } else {
      _listeners.add(onComplete);
    }
  }

  void handleException(void onException(Object exception)) {
    _exceptionHandlers.add(onException);
  }

  void _complete() {
    _isComplete = true;
    if (_exception !== null) {
      for (Function handler in _exceptionHandlers) {
        if (handler(_exception)) {
          _exceptionHandled = true;
        }
      }
    }
    if (hasValue) {
      for (Function listener in _listeners) {
        listener(value);
      }
    } else {
      if (!_exceptionHandled && _listeners.length > 0) {
        throw _exception;
      }
    }
  }

  void _setValue(T value) {
    if (_isComplete) {
      throw new FutureAlreadyCompleteException();
    }
    _value = value;
    _complete();
  }

  void _setException(var exception) {
    if (exception === null) {
      // null is not a legal value for the exception of a Future
      throw new IllegalArgumentException(null);
    }
    if (_isComplete) {
      throw new FutureAlreadyCompleteException();
    }
    _exception = exception;
    _complete();
  }
}

class CompleterImpl<T> implements Completer<T> {

  final FutureImpl<T> _futureImpl;

  CompleterImpl() : _futureImpl = new FutureImpl() {}

  Future<T> get future() {
    return _futureImpl;
  }

  void complete(T value) {
    _futureImpl._setValue(value);
  }

  void completeException(var exception) {
    _futureImpl._setException(exception);
  }
}

</script>
<script type="application//inert" id="implementation_hash_map_set_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Hash map implementation with open addressing and quadratic probing.
class HashMapImplementation<K extends Hashable, V> implements HashMap<K, V> {

  // The [_keys] list contains the keys inserted in the map.
  // The [_keys] list must be a raw list because it
  // will contain both elements of type K, and the [_DELETED_KEY] of type
  // [_DeletedKeySentinel].
  // The alternative of declaring the [_keys] list as of type Object
  // does not work, because the HashSetIterator constructor would fail:
  //  HashSetIterator(HashSet<E> set)
  //    : _nextValidIndex = -1,
  //      _entries = set_._backingMap._keys {
  //    _advance();
  //  }
  // With K being type int, for example, it would fail because
  // List<Object> is not assignable to type List<int> of entries.
  List _keys;

  // The values inserted in the map. For a filled entry index in this
  // list, there is always the corresponding key in the [keys_] list
  // at the same entry index.
  List<V> _values;

  // The load limit is the number of entries we allow until we double
  // the size of the lists.
  int _loadLimit;

  // The current number of entries in the map. Will never be greater
  // than [_loadLimit].
  int _numberOfEntries;

  // The current number of deleted entries in the map.
  int _numberOfDeleted;

  // The sentinel when a key is deleted from the map.
  static final _DeletedKeySentinel _DELETED_KEY = const _DeletedKeySentinel();

  // The initial capacity of a hash map.
  static final int _INITIAL_CAPACITY = 8;  // must be power of 2

  HashMapImplementation() {
    _numberOfEntries = 0;
    _numberOfDeleted = 0;
    _loadLimit = _computeLoadLimit(_INITIAL_CAPACITY);
    _keys = new List(_INITIAL_CAPACITY);
    _values = new List<V>(_INITIAL_CAPACITY);
  }

  factory HashMapImplementation.from(Map<K, V> other) {
    Map<K, V> result = new HashMapImplementation<K, V>();
    other.forEach((K key, V value) { result[key] = value; });
    return result;
  }

  static int _computeLoadLimit(int capacity) {
    return (capacity * 3) ~/ 4;
  }

  static int _firstProbe(int hashCode, int length) {
    return hashCode & (length - 1);
  }

  static int _nextProbe(int currentProbe, int numberOfProbes, int length) {
    return (currentProbe + numberOfProbes) & (length - 1);
  }

  int _probeForAdding(K key) {
    int hash = _firstProbe(key.hashCode(), _keys.length);
    int numberOfProbes = 1;
    int initialHash = hash;
    // insertionIndex points to a slot where a key was deleted.
    int insertionIndex = -1;
    while (true) {
      // [existingKey] can be either of type [K] or [_DeletedKeySentinel].
      Object existingKey = _keys[hash];
      if (existingKey === null) {
        // We are sure the key is not already in the set.
        // If the current slot is empty and we didn't find any
        // insertion slot before, return this slot.
        if (insertionIndex < 0) return hash;
        // If we did find an insertion slot before, return it.
        return insertionIndex;
      } else if (existingKey == key) {
        // The key is already in the map. Return its slot.
        return hash;
      } else if ((insertionIndex < 0) && (_DELETED_KEY === existingKey)) {
        // The slot contains a deleted element. Because previous calls to this
        // method may not have had this slot deleted, we must continue iterate
        // to find if there is a slot with the given key.
        insertionIndex = hash;
      }

      // We did not find an insertion slot. Look at the next one.
      hash = _nextProbe(hash, numberOfProbes++, _keys.length);
      // _ensureCapacity has guaranteed the following cannot happen.
      // assert(hash != initialHash);
    }
  }

  int _probeForLookup(K key) {
    int hash = _firstProbe(key.hashCode(), _keys.length);
    int numberOfProbes = 1;
    int initialHash = hash;
    while (true) {
      // [existingKey] can be either of type [K] or [_DeletedKeySentinel].
      Object existingKey = _keys[hash];
      // If the slot does not contain anything (in particular, it does not
      // contain a deleted key), we know the key is not in the map.
      if (existingKey === null) return -1;
      // The key is in the map, return its index.
      if (existingKey == key) return hash;
      // Go to the next probe.
      hash = _nextProbe(hash, numberOfProbes++, _keys.length);
      // _ensureCapacity has guaranteed the following cannot happen.
      // assert(hash != initialHash);
    }
  }

  void _ensureCapacity() {
    int newNumberOfEntries = _numberOfEntries + 1;
    // Test if adding an element will reach the load limit.
    if (newNumberOfEntries >= _loadLimit) {
      _grow(_keys.length * 2);
      return;
    }

    // Make sure that we don't have poor performance when a map
    // contains lots of deleted entries: we _grow if
    // there are more deleted entried than free entries.
    int capacity = _keys.length;
    int numberOfFreeOrDeleted = capacity - newNumberOfEntries;
    int numberOfFree = numberOfFreeOrDeleted - _numberOfDeleted;
    // assert(numberOfFree > 0);
    if (_numberOfDeleted > numberOfFree) {
      _grow(_keys.length);
    }
  }

  static bool _isPowerOfTwo(int x) {
    return ((x & (x - 1)) == 0);
  }

  void _grow(int newCapacity) {
    assert(_isPowerOfTwo(newCapacity));
    int capacity = _keys.length;
    _loadLimit = _computeLoadLimit(newCapacity);
    List oldKeys = _keys;
    List<V> oldValues = _values;
    _keys = new List(newCapacity);
    _values = new List<V>(newCapacity);
    for (int i = 0; i < capacity; i++) {
      // [key] can be either of type [K] or [_DeletedKeySentinel].
      Object key = oldKeys[i];
      // If there is no key, we don't need to deal with the current slot.
      if (key === null || key === _DELETED_KEY) {
        continue;
      }
      V value = oldValues[i];
      // Insert the {key, value} pair in their new slot.
      int newIndex = _probeForAdding(key);
      _keys[newIndex] = key;
      _values[newIndex] = value;
    }
    _numberOfDeleted = 0;
  }

  void clear() {
    _numberOfEntries = 0;
    _numberOfDeleted = 0;
    int length = _keys.length;
    for (int i = 0; i < length; i++) {
      _keys[i] = null;
      _values[i] = null;
    }
  }

  void operator []=(K key, V value) {
    _ensureCapacity();
    int index = _probeForAdding(key);
    if ((_keys[index] === null) || (_keys[index] === _DELETED_KEY)) {
      _numberOfEntries++;
    }
    _keys[index] = key;
    _values[index] = value;
  }

  V operator [](K key) {
    int index = _probeForLookup(key);
    if (index < 0) return null;
    return _values[index];
  }

  V putIfAbsent(K key, V ifAbsent()) {
    int index = _probeForLookup(key);
    if (index >=0) return _values[index];

    V value = ifAbsent();
    this[key] = value;
    return value;
  }

  V remove(K key) {
    int index = _probeForLookup(key);
    if (index >= 0) {
      _numberOfEntries--;
      V value = _values[index];
      _values[index] = null;
      // Set the key to the sentinel to not break the probing chain.
      _keys[index] = _DELETED_KEY;
      _numberOfDeleted++;
      return value;
    }
    return null;
  }

  bool isEmpty() {
    return _numberOfEntries == 0;
  }

  int get length() {
    return _numberOfEntries;
  }

  void forEach(void f(K key, V value)) {
    int length = _keys.length;
    for (int i = 0; i < length; i++) {
      if ((_keys[i] !== null) && (_keys[i] !== _DELETED_KEY)) {
        f(_keys[i], _values[i]);
      }
    }
  }


  Collection<K> getKeys() {
    List<K> list = new List<K>(length);
    int i = 0;
    forEach(void _(K key, V value) {
      list[i++] = key;
    });
    return list;
  }

  Collection<V> getValues() {
    List<V> list = new List<V>(length);
    int i = 0;
    forEach(void _(K key, V value) {
      list[i++] = value;
    });
    return list;
  }

  bool containsKey(K key) {
    return (_probeForLookup(key) != -1);
  }

  bool containsValue(V value) {
    int length = _values.length;
    for (int i = 0; i < length; i++) {
      if ((_keys[i] !== null) && (_keys[i] !== _DELETED_KEY)) {
        if (_values[i] == value) return true;
      }
    }
    return false;
  }
}

class HashSetImplementation<E extends Hashable> implements HashSet<E> {

  HashSetImplementation() {
    _backingMap = new HashMapImplementation<E, E>();
  }

  factory HashSetImplementation.from(Iterable<E> other) {
    Set<E> set = new HashSetImplementation<E>();
    for (final e in other) {
      set.add(e);
    }
    return set;
  }

  void clear() {
    _backingMap.clear();
  }

  void add(E value) {
    _backingMap[value] = value;
  }

  bool contains(E value) {
    return _backingMap.containsKey(value);
  }

  bool remove(E value) {
    if (!_backingMap.containsKey(value)) return false;
    _backingMap.remove(value);
    return true;
  }

  void addAll(Collection<E> collection) {
    collection.forEach(void _(E value) {
      add(value);
    });
  }

  Set<E> intersection(Collection<E> collection) {
    Set<E> result = new Set<E>();
    collection.forEach(void _(E value) {
      if (contains(value)) result.add(value);
    });
    return result;
  }

  bool isSubsetOf(Collection<E> other) {
    return new Set<E>.from(other).containsAll(this);
  }

  void removeAll(Collection<E> collection) {
    collection.forEach(void _(E value) {
      remove(value);
    });
  }

  bool containsAll(Collection<E> collection) {
    return collection.every(bool _(E value) {
      return contains(value);
    });
  }

  void forEach(void f(E element)) {
    _backingMap.forEach(void _(E key, E value) {
      f(key);
    });
  }

  Set<E> filter(bool f(E element)) {
    Set<E> result = new Set<E>();
    _backingMap.forEach(void _(E key, E value) {
      if (f(key)) result.add(key);
    });
    return result;
  }

  bool every(bool f(E element)) {
    Collection<E> keys = _backingMap.getKeys();
    return keys.every(f);
  }

  bool some(bool f(E element)) {
    Collection<E> keys = _backingMap.getKeys();
    return keys.some(f);
  }

  bool isEmpty() {
    return _backingMap.isEmpty();
  }

  int get length() {
    return _backingMap.length;
  }

  Iterator<E> iterator() {
    return new HashSetIterator<E>(this);
  }

  // The map backing this set. The associations in this map are all
  // of the form element -> element. If a value is not in the map,
  // then it is not in the set.
  HashMapImplementation<E, E> _backingMap;
}

class HashSetIterator<E> implements Iterator<E> {

  // TODO(4504458): Replace set_ with set.
  HashSetIterator(HashSetImplementation<E> set_)
    : _nextValidIndex = -1,
      _entries = set_._backingMap._keys {
    _advance();
  }

  bool hasNext() {
    if (_nextValidIndex >= _entries.length) return false;
    if (_entries[_nextValidIndex] === HashMapImplementation._DELETED_KEY) {
      // This happens in case the set was modified in the meantime.
      // A modification on the set may make this iterator misbehave,
      // but we should never return the sentinel.
      _advance();
    }
    return _nextValidIndex < _entries.length;
  }

  E next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }
    E res = _entries[_nextValidIndex];
    _advance();
    return res;
  }

  void _advance() {
    int length = _entries.length;
    var entry;
    final deletedKey = HashMapImplementation._DELETED_KEY;
    do {
      if (++_nextValidIndex >= length) break;
      entry = _entries[_nextValidIndex];
    } while ((entry === null) || (entry === deletedKey));
  }

  // The entries in the set. May contain null or the sentinel value.
  List<E> _entries;

  // The next valid index in [_entries] or the length of [entries_].
  // If it is the length of [_entries], calling [hasNext] on the
  // iterator will return false.
  int _nextValidIndex;
}

/**
 * A singleton sentinel used to represent when a key is deleted from the map.
 * We can't use [: const Object() :] as a sentinel because it would end up
 * canonicalized and then we cannot distinguish the deleted key from the
 * canonicalized [: Object() :].
 */
class _DeletedKeySentinel {
  const _DeletedKeySentinel();
}

</script>
<script type="application//inert" id="implementation_linked_hash_map_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * This class represents a pair of two objects, used by LinkedHashMap
 * to store a {key, value} in a list.
 */
class KeyValuePair<K, V> {
  KeyValuePair(this.key, this.value) {}

  final K key;
  V value;
}

/**
 * A LinkedHashMap is a hash map that preserves the insertion order
 * when iterating over the keys or the values. Updating the value of a
 * key does not change the order.
 */
class LinkedHashMapImplementation<K extends Hashable, V>
    implements LinkedHashMap<K, V> {
  DoubleLinkedQueue<KeyValuePair<K, V>> _list;
  HashMap<K, DoubleLinkedQueueEntry<KeyValuePair<K, V>>> _map;

  LinkedHashMapImplementation() {
    _map = new HashMap<K, DoubleLinkedQueueEntry<KeyValuePair<K, V>>>();
    _list = new DoubleLinkedQueue<KeyValuePair<K, V>>();
  }

  factory LinkedHashMapImplementation.from(Map<K, V> other) {
    Map<K, V> result = new LinkedHashMapImplementation<K, V>();
    other.forEach((K key, V value) { result[key] = value; });
    return result;
  }

  void operator []=(K key, V value) {
    if (_map.containsKey(key)) {
      _map[key].element.value = value;
    } else {
      _list.addLast(new KeyValuePair<K, V>(key, value));
      _map[key] = _list.lastEntry();
    }
  }

  V operator [](K key) {
    DoubleLinkedQueueEntry<KeyValuePair<K, V>> entry = _map[key];
    if (entry === null) return null;
    return entry.element.value;
  }

  V remove(K key) {
    DoubleLinkedQueueEntry<KeyValuePair<K, V>> entry = _map.remove(key);
    if (entry === null) return null;
    entry.remove();
    return entry.element.value;
  }

  V putIfAbsent(K key, V ifAbsent()) {
    V value = this[key];
    if ((this[key] === null) && !(containsKey(key))) {
      value = ifAbsent();
      this[key] = value;
    }
    return value;
  }

  Collection<K> getKeys() {
    List<K> list = new List<K>(length);
    int index = 0;
    _list.forEach(void _(KeyValuePair<K, V> entry) {
      list[index++] = entry.key;
    });
    assert(index == length);
    return list;
  }


  Collection<V> getValues() {
    List<V> list = new List<V>(length);
    int index = 0;
    _list.forEach(void _(KeyValuePair<K, V> entry) {
      list[index++] = entry.value;
    });
    assert(index == length);
    return list;
  }

  void forEach(void f(K key, V value)) {
    _list.forEach(void _(KeyValuePair<K, V> entry) {
      f(entry.key, entry.value);
    });
  }

  bool containsKey(K key) {
    return _map.containsKey(key);
  }

  bool containsValue(V value) {
    return _list.some(bool _(KeyValuePair<K, V> entry) {
      return (entry.value == value);
    });
  }

  int get length() {
    return _map.length;
  }

  bool isEmpty() {
    return length == 0;
  }

  void clear() {
    _map.clear();
    _list.clear();
  }
}

</script>
<script type="application//inert" id="implementation_maps_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/*
 * Helper class which implements complex [Map] operations
 * in term of basic ones ([Map.getKeys], [Map.operator []],
 * [Map.operator []=] and [Map.remove].)  Not all methods are
 * necessary to implement each particular operation.
 */
class Maps {
  static bool containsValue(Map map, value) {
    for (final v in map.getValues()) {
      if (value == v) {
        return true;
      }
    }
    return false;
  }

  static bool containsKey(Map map, key) {
    for (final k in map.getKeys()) {
      if (key == k) {
        return true;
      }
    }
    return false;
  }

  static putIfAbsent(Map map, key, ifAbsent()) {
    if (map.containsKey(key)) {
      return map[key];
    }
    final v = ifAbsent();
    map[key] = v;
    return v;
  }

  static clear(Map map) {
    for (final k in map.getKeys()) {
      map.remove(k);
    }
  }

  static forEach(Map map, void f(key, value)) {
    for (final k in map.getKeys()) {
      f(k, map[k]);
    }
  }

  static Collection getValues(Map map) {
    final result = [];
    for (final k in map.getKeys()) {
      result.add(map[k]);
    }
    return result;
  }

  static int length(Map map) => map.getKeys().length;

  static bool isEmpty(Map map) => length(map) == 0;
}

</script>
<script type="application//inert" id="implementation_queue_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/**
 * An entry in a doubly linked list. It contains a pointer to the next
 * entry, the previous entry, and the boxed element.
 */
class DoubleLinkedQueueEntry<E> {
  DoubleLinkedQueueEntry<E> _previous;
  DoubleLinkedQueueEntry<E> _next;
  E _element;

  DoubleLinkedQueueEntry(E e) {
    _element = e;
  }

  void _link(DoubleLinkedQueueEntry<E> p,
             DoubleLinkedQueueEntry<E> n) {
    _next = n;
    _previous = p;
    p._next = this;
    n._previous = this;
  }

  void append(E e) {
    new DoubleLinkedQueueEntry<E>(e)._link(this, _next);
  }

  void prepend(E e) {
    new DoubleLinkedQueueEntry<E>(e)._link(_previous, this);
  }

  E remove() {
    _previous._next = _next;
    _next._previous = _previous;
    _next = null;
    _previous = null;
    return _element;
  }

  DoubleLinkedQueueEntry<E> _asNonSentinelEntry() {
    return this;
  }

  DoubleLinkedQueueEntry<E> previousEntry() {
    return _previous._asNonSentinelEntry();
  }

  DoubleLinkedQueueEntry<E> nextEntry() {
    return _next._asNonSentinelEntry();
  }

  E get element() {
    return _element;
  }

  void set element(E e) {
    _element = e;
  }
}

/**
 * A sentinel in a double linked list is used to manipulate the list
 * at both ends. A double linked list has exactly one sentinel, which
 * is the only entry when the list is constructed. Initially, a
 * sentinel has its next and previous entry point to itself. A
 * sentinel does not box any user element.
 */
class _DoubleLinkedQueueEntrySentinel<E> extends DoubleLinkedQueueEntry<E> {
  _DoubleLinkedQueueEntrySentinel() : super(null) {
    _link(this, this);
  }

  E remove() {
    throw const EmptyQueueException();
  }

  DoubleLinkedQueueEntry<E> _asNonSentinelEntry() {
    return null;
  }

  void set element(E e) {
    // This setter is unreachable.
    assert(false);
  }

  E get element() {
    throw const EmptyQueueException();
  }
}

/**
 * Implementation of a double linked list that box list elements into
 * DoubleLinkedQueueEntry objects.
 */
class DoubleLinkedQueue<E> implements Queue<E> {
  _DoubleLinkedQueueEntrySentinel<E> _sentinel;

  DoubleLinkedQueue() {
    _sentinel = new _DoubleLinkedQueueEntrySentinel<E>();
  }

  factory DoubleLinkedQueue.from(Iterable<E> other) {
    Queue<E> list = new DoubleLinkedQueue();
    for (final e in other) {
      list.addLast(e);
    }
    return list;
  }

  void addLast(E value) {
    _sentinel.prepend(value);
  }

  void addFirst(E value) {
    _sentinel.append(value);
  }

  void add(E value) {
    addLast(value);
  }

  void addAll(Collection<E> collection) {
    for (final e in collection) {
      add(e);
    }
  }

  E removeLast() {
    return _sentinel._previous.remove();
  }

  E removeFirst() {
    return _sentinel._next.remove();
  }

  E first() {
    return _sentinel._next.element;
  }

  E last() {
    return _sentinel._previous.element;
  }

  DoubleLinkedQueueEntry<E> lastEntry() {
    return _sentinel.previousEntry();
  }

  DoubleLinkedQueueEntry<E> firstEntry() {
    return _sentinel.nextEntry();
  }

  int get length() {
    int counter = 0;
    forEach(void _(E element) { counter++; });
    return counter;
  }

  bool isEmpty() {
    return (_sentinel._next === _sentinel);
  }

  void clear() {
    _sentinel._next = _sentinel;
    _sentinel._previous = _sentinel;
  }

  void forEach(void f(E element)) {
    DoubleLinkedQueueEntry<E> entry = _sentinel._next;
    while (entry !== _sentinel) {
      DoubleLinkedQueueEntry<E> nextEntry = entry._next;
      f(entry._element);
      entry = nextEntry;
    }
  }

  void forEachEntry(void f(DoubleLinkedQueueEntry<E> element)) {
    DoubleLinkedQueueEntry<E> entry = _sentinel._next;
    while (entry !== _sentinel) {
      DoubleLinkedQueueEntry<E> nextEntry = entry._next;
      f(entry);
      entry = nextEntry;
    }
  }

  bool every(bool f(E element)) {
    DoubleLinkedQueueEntry<E> entry = _sentinel._next;
    while (entry !== _sentinel) {
      DoubleLinkedQueueEntry<E> nextEntry = entry._next;
      if (!f(entry._element)) return false;
      entry = nextEntry;
    }
    return true;
  }

  bool some(bool f(E element)) {
    DoubleLinkedQueueEntry<E> entry = _sentinel._next;
    while (entry !== _sentinel) {
      DoubleLinkedQueueEntry<E> nextEntry = entry._next;
      if (f(entry._element)) return true;
      entry = nextEntry;
    }
    return false;
  }

  Queue<E> filter(bool f(E element)) {
    Queue<E> other = new Queue<E>();
    DoubleLinkedQueueEntry<E> entry = _sentinel._next;
    while (entry !== _sentinel) {
      DoubleLinkedQueueEntry<E> nextEntry = entry._next;
      if (f(entry._element)) other.addLast(entry._element);
      entry = nextEntry;
    }
    return other;
  }

  _DoubleLinkedQueueIterator<E> iterator() {
    return new _DoubleLinkedQueueIterator<E>(_sentinel);
  }
}

class _DoubleLinkedQueueIterator<E> implements Iterator<E> {
  final _DoubleLinkedQueueEntrySentinel<E> _sentinel;
  DoubleLinkedQueueEntry<E> _currentEntry;

  _DoubleLinkedQueueIterator(_DoubleLinkedQueueEntrySentinel this._sentinel) {
    _currentEntry = _sentinel;
  }

  bool hasNext() {
    return _currentEntry._next !== _sentinel;
  }

  E next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }
    _currentEntry = _currentEntry._next;
    return _currentEntry.element;
  }
}

</script>
<script type="application//inert" id="implementation_splay_tree_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * A node in a splay tree. It holds the key, the value and the left
 * and right children in the tree.
 */
class SplayTreeNode<K, V> {
  SplayTreeNode(K k, V v) {
    key = k;
    value = v;
  }

  K key;
  V value;
  SplayTreeNode<K, V> left;
  SplayTreeNode<K, V> right;
}

/**
 * A splay tree is a self-balancing binary
 * search tree with the additional property that recently accessed
 * elements are quick to access again. It performs basic operations
 * such as insertion, look-up and removal in O(log(n)) amortized time.
 *
 * This implementation is a Dart version of the JavaScript
 * implementation in the V8 project.
 */
class SplayTree<K extends Comparable, V> implements Map<K, V> {

  // The root node of the splay tree. It will contain either the last
  // element inserted, or the last element looked up.
  SplayTreeNode<K, V> _root;

  // The dummy node used when performing a splay on the tree. It is a
  // local field of the class to avoid allocating a node each time a
  // splay is performed.
  SplayTreeNode<K, V> _dummy;

  // Number of elements in the splay tree.
  int _count;

  SplayTree() {
    _dummy = new SplayTreeNode<K, V>(null, null);
    _count = 0;
  }

  /**
   * Perform the splay operation for the given key. Moves the node with
   * the given key to the top of the tree.  If no node has the given
   * key, the last node on the search path is moved to the top of the
   * tree. This is the simplified top-down splaying algorithm from:
   * "Self-adjusting Binary Search Trees" by Sleator and Tarjan.
   */
  void splay_(K key) {
    if (isEmpty()) return;

    // The right child of the dummy node will hold
    // the L tree of the algorithm.  The left child of the dummy node
    // will hold the R tree of the algorithm.  Using a dummy node, left
    // and right will always be nodes and we avoid special cases.
    SplayTreeNode<K, V> left = _dummy;
    SplayTreeNode<K, V> right = _dummy;
    SplayTreeNode<K, V> current = _root;
    while (true) {
      if (key.compareTo(current.key) < 0) {
        if (current.left === null) break;
        if (key.compareTo(current.left.key) < 0) {
          // Rotate right.
          SplayTreeNode<K, V> tmp = current.left;
          current.left = tmp.right;
          tmp.right = current;
          current = tmp;
          if (current.left === null) break;
        }
        // Link right.
        right.left = current;
        right = current;
        current = current.left;
      } else if (key.compareTo(current.key) > 0) {
        if (current.right === null) break;
        if (key.compareTo(current.right.key) > 0) {
          // Rotate left.
          SplayTreeNode<K, V> tmp = current.right;
          current.right = tmp.left;
          tmp.left = current;
          current = tmp;
          if (current.right === null) break;
        }
        // Link left.
        left.right = current;
        left = current;
        current = current.right;
      } else {
        break;
      }
    }
    // Assemble.
    left.right = current.left;
    right.left = current.right;
    current.left = _dummy.right;
    current.right = _dummy.left;
    _root = current;

    _dummy.right = null;
    _dummy.left = null;
  }

  V operator [](K key) {
    if (!isEmpty()) {
      splay_(key);
      if (_root.key.compareTo(key) == 0) return _root.value;
    }
    return null;
  }

  V remove(K key) {
    if (isEmpty()) return null;
    splay_(key);
    if (_root.key.compareTo(key) != 0) return null;
    V value = _root.value;

    _count--;
    // assert(_count >= 0);
    if (_root.left === null) {
      _root = _root.right;
    } else {
      SplayTreeNode<K, V> right = _root.right;
      _root = _root.left;
      // Splay to make sure that the new root has an empty right child.
      splay_(key);
      // Insert the original right child as the right child of the new
      // root.
      _root.right = right;
    }
    return value;
  }

  void operator []=(K key, V value) {
    if (isEmpty()) {
      _count++;
      _root = new SplayTreeNode(key, value);
      return;
    }
    // Splay on the key to move the last node on the search path for
    // the key to the root of the tree.
    splay_(key);
    if (_root.key.compareTo(key) == 0) {
      _root.value = value;
      return;
    }
    SplayTreeNode<K, V> node = new SplayTreeNode(key, value);
    // assert(_count >= 0);
    _count++;
    if (key.compareTo(_root.key) > 0) {
      node.left = _root;
      node.right = _root.right;
      _root.right = null;
    } else {
      node.right = _root;
      node.left = _root.left;
      _root.left = null;
    }
    _root = node;
  }

  V putIfAbsent(K key, V ifAbsent()) {
    if (containsKey(key)) return this[key];
    V value = ifAbsent();
    this[key] = value;
    return value;
  }

  bool isEmpty() {
    // assert(!((_root === null) && (_count != 0)));
    // assert(!((_count == 0) && (_root !== null)));
    return (_root === null);
  }

  void forEach(void f(K key, V value)) {
    List<SplayTreeNode<K, V>> list = new List<SplayTreeNode<K, V>>();
    SplayTreeNode<K, V> current = _root;
    while (current !== null) {
      if (current.left !== null) {
        list.add(current);
        current = current.left;
      } else {
        f(current.key, current.value);
        while (current.right === null) {
          if (list.isEmpty()) return;
          current = list.removeLast();
          f(current.key, current.value);
        }
        current = current.right;
      }
    }
  }

  int get length() {
    return _count;
  }

  void clear() {
    _root = null;
    _count = 0;
  }

  bool containsKey(K key) {
    if (!isEmpty()) {
      splay_(key);
      if (_root.key.compareTo(key) == 0) return true;
    }
    return false;
  }

  bool containsValue(V value) {
    bool found = false;
    // Note: Worst performance you can get because we don't have
    // non-local return.
    // TODO: optimize this method with a similar code than forEach.
    forEach((Object k, Object v) { if (value == v) found = true; });
    return found;
  }

  Collection<K> getKeys() {
    List<K> list = new List<K>();
    forEach((K k, V v) { list.add(k); });
    return list;
  }

  Collection<V> getValues() {
    List<V> list = new List<V>();
    forEach((K k, V v) { list.add(v); });
    return list;
  }
}

</script>
<script type="application//inert" id="implementation_stopwatch_implementation_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * A simple implementation of the [Stopwatch] interface.
 */
class StopwatchImplementation implements Stopwatch {
  // The _start and _stop fields capture the time when [start] and [stop]
  // are called respectively.
  // If _start is null, then the [Stopwatch] has not been started yet.
  // If _stop is null, then the [Stopwatch] has not been stopped yet.
  int _start;
  int _stop;

  StopwatchImplementation() : _start = null, _stop = null {}
  StopwatchImplementation.start() : _start = null, _stop = null {
    start();
  }

  void start() {
    if (_start === null) {
      // This stopwatch has never been started.
      _start = Clock.now();
    } else {
      if (_stop === null) {
        return;
      }
      // Restarting this stopwatch. Prepend the elapsed time to the current
      // start time.
      _start = Clock.now() - (_stop - _start);
    }
  }

  void stop() {
    if (_start === null) {
      return;
    }
    _stop = Clock.now();
  }

  void reset() {
    if (_start === null) return;
    // If [_start] is not null, then the stopwatch had already been started. It
    // may running right now.
    _start = Clock.now();
    if (_stop !== null) {
      // The watch is not running. So simply set the [_stop] to [_start] thus
      // having an elapsed time of 0.
      _stop = _start;
    }
  }

  int elapsed() {
    if (_start === null) {
      return 0;
    }
    return (_stop === null) ? (Clock.now() - _start) : (_stop - _start);
  }

  int elapsedInUs() {
    return (elapsed() * 1000000) ~/ frequency();
  }

  int elapsedInMs() {
    return (elapsed() * 1000) ~/ frequency();
  }

  int frequency() {
    return Clock.frequency();
  }

}

</script>
<script type="application//inert" id="lib_arrays_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class Arrays {

  static void copy(List<Object> src, int srcStart,
                   List<Object> dst, int dstStart, int count) {
    if (srcStart === null) srcStart = 0;
    if (dstStart === null) dstStart = 0;

    if (srcStart < dstStart) {
      for (int i = srcStart + count - 1, j = dstStart + count - 1;
           i >= srcStart; i--, j--) {
        dst[j] = src[i];
      }
    } else {
      for (int i = srcStart, j = dstStart; i < srcStart + count; i++, j++) {
        dst[j] = src[i];
      }
    }
  }

  /**
   * Returns the index in the array [a] of the given [element], starting
   * the search at index [startIndex] to [endIndex] (exclusive).
   * Returns -1 if [element] is not found.
   */
  static int indexOf(List a,
                     Object element,
                     int startIndex,
                     int endIndex) {
    if (startIndex >= a.length) {
      return -1;
    }
    if (startIndex < 0) {
      startIndex = 0;
    }
    for (int i = startIndex; i < endIndex; i++) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns the last index in the array [a] of the given [element], starting
   * the search at index [startIndex] to 0.
   * Returns -1 if [element] is not found.
   */
  static int lastIndexOf(List a, Object element, int startIndex) {
    if (startIndex < 0) {
      return -1;
    }
    if (startIndex >= a.length) {
      startIndex = a.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }
}

</script>
<script type="application//inert" id="lib_collections_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The [Collections] class implements static methods useful when
 * writing a class that implements [Collection] and the [iterator]
 * method.
 */
class Collections {
  static void forEach(Iterable<Object> iterable, void f(Object o)) {
    for (final e in iterable) {
      f(e);
    }
  }

  static bool some(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (f(e)) return true;
    }
    return false;
  }

  static bool every(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (!f(e)) return false;
    }
    return true;
  }

  static List filter(Iterable<Object> source,
                     List<Object> destination,
                     bool f(o)) {
    for (final e in source) {
      if (f(e)) destination.add(e);
    }
    return destination;
  }

  static bool isEmpty(Iterable<Object> iterable) {
    return !iterable.iterator().hasNext();
  }
}

</script>
<script type="application//inert" id="lib_corelib_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#library("dart:core");
#import("dart:coreimpl");

// TODO(jimhug): Better way to map in standard corelib
#source("../../corelib/src/bool.dart");
#source("../../corelib/src/collection.dart");
#source("../../corelib/src/comparable.dart");
#source("../../corelib/src/date.dart");
#source("../../corelib/src/double.dart");
#source("../../corelib/src/duration.dart");
#source("../../corelib/src/exceptions.dart");
#source("../../corelib/src/expect.dart");
#source("../../corelib/src/function.dart");
#source("../../corelib/src/future.dart");
#source("../../corelib/src/hashable.dart");
#source("../../corelib/src/int.dart");
#source("../../corelib/src/isolate.dart");
#source("../../corelib/src/iterable.dart");
#source("../../corelib/src/iterator.dart");
#source("../../corelib/src/list.dart");
#source("../../corelib/src/map.dart");
#source("math.dart"); // overriden to be more directly native
#source("natives.dart"); // native helpers generated by the compiler
#source("num.dart"); // overriden to include int members on num - weird typing
#source("../../corelib/src/pattern.dart");
#source("../../corelib/src/queue.dart");
#source("../../corelib/src/regexp.dart");
#source("../../corelib/src/set.dart");
#source("../../corelib/src/stopwatch.dart");
#source("../../corelib/src/string.dart");
#source("../../corelib/src/strings.dart");
#source("../../corelib/src/string_buffer.dart");
#source("../../corelib/src/time_zone.dart");

// TODO(jimhug): Ad-hoc cut-paste-and-edit from compiler/lib below:
// Conceptual change is moving to more true natives.

/**
 * The class [Clock] provides access to a monotonically incrementing clock
 * device.
 */
class Clock {
  /** Returns the current clock tick. */
  static int now() native 'return new Date().getTime();';

  /** Returns the frequency of clock ticks in Hz. */
  // TODO(jimhug): Why isn't this a property?
  static int frequency() => 1000;
}

// TODO(jmesserly): this is working around a name conflict with "window.print".
void print(Object obj) => _print(obj);
void _print(Object obj) native '''if (typeof console == 'object') {
  if (obj) obj = obj.toString();
  console.log(obj);
} else {
  write(obj);
  write('\n');
}''' {
  // ensure toString is generated
  obj.toString();
}

// Exceptions thrown by the generated JS code.

class AssertionError {
  final String failedAssertion;

  // TODO(jmesserly): I don't think these should be here. They are properties of
  // the stack trace
  final String url;
  final int line;
  final int column;

  AssertionError._internal(this.failedAssertion, this.url, this.line, this.column);

  String toString() {
    return "Failed assertion: '$failedAssertion' is not true " +
        "in $url at line $line, column $column.";
  }
}

// TODO(jmesserly): fix the strange interaction with JS TypeError, such as
// toString(). Ideally this would generate to a different JS name but I'm not
// sure how to force that.
class TypeError extends AssertionError native 'TypeError' {
  final String srcType;
  final String dstType;

  // TODO: make this non-native once $typeNameOf and toString issues are fixed.
  TypeError._internal(Object src, String dstType) native @'''
this.srcType = (src == null ? "Null" : src.$typeNameOf());
this.dstType = dstType;
this.toString = function() {
  return ("Failed type check: type " + this.srcType +
      " is not assignable to type " + this.dstType);
}''';
}

class FallThroughError {
  const FallThroughError();

  String toString() => "Switch case fall-through.";
}

// Dart core library.

class Object native "Object" {

  const Object() native;

  bool operator ==(Object other) native;
  String toString() native;

  // TODO(jmesserly): optimize this. No need to call it.
  get dynamic() => this;

  // TODO(jmesserly): add named args. For now stay compatible with the VM.
  noSuchMethod(String name, List args) {
    throw new NoSuchMethodException(this, name, args);
  }
}

LinkedHashMapImplementation _map(List itemsAndKeys) {
  LinkedHashMapImplementation ret = new LinkedHashMapImplementation();
  for (int i=0; i < itemsAndKeys.length;) {
    ret[itemsAndKeys[i++]] = itemsAndKeys[i++];
  }
  return ret;
}

ImmutableMap _constMap(List itemsAndKeys) {
  return new ImmutableMap(itemsAndKeys);
}

void _assert(var test, String text, String url, int line, int column) {
  if (test is Function) test = test();
  if (!test) throw new AssertionError._internal(text, url, line, column);
}

</script>
<script type="application//inert" id="lib_corelib_impl_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#library("dart:coreimpl");

#source("../../corelib/src/implementation/dual_pivot_quicksort.dart");
#source("../../corelib/src/implementation/duration_implementation.dart");
#source("../../corelib/src/implementation/exceptions.dart");
#source("../../corelib/src/implementation/future_implementation.dart");
#source("../../corelib/src/implementation/hash_map_set.dart");
// TODO(jimhug): Re-explore tradeoffs with using builtin JS maps.
#source("../../corelib/src/implementation/linked_hash_map.dart");
#source("../../corelib/src/implementation/maps.dart");
#source("../../corelib/src/implementation/queue.dart");
#source("../../corelib/src/implementation/stopwatch_implementation.dart");
#source("../../corelib/src/implementation/splay_tree.dart");

#source("string_buffer.dart");
#source("string_base.dart");
#source("string_implementation.dart");
#source("arrays.dart");
#source("collections.dart");
#source("date_implementation.dart");

#source("isolate.dart");
#source("isolate_serialization.dart");

#source("function_implementation.dart");

/**
 * The default implementation of the [List<E>] interface. Essentially a growable
 * array that will expand automatically as more elements are added.
 */
class ListFactory<E> implements List<E> native "Array" {
  ListFactory([int length]) native;

  // TODO(jmesserly): type parameters aren't working here
  factory ListFactory.from(Iterable other) {
    final list = [];
    for (final e in other) {
      list.add(e);
    }
    return list;
  }

  // TODO(jimhug): Only works for Arrays.
  factory ListFactory.fromList(List other, int startIndex, int endIndex)
    native 'return other.slice(startIndex, endIndex);';

  int length; // all fields on natives are implied native.

  // List<E> members:
  E operator [](int index) native;
  void operator []=(int index, E value) native;
  void add(E value) native "this.push(value);";
  void addLast(E value) native "this.push(value);";
  void addAll(Collection<E> collection) {
    for (E item in collection) add(item);
  }
  void sort(int compare(E a, E b)) native;
  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) native;
  int indexOf(E element, [int start]) native;
  int lastIndexOf(E element, [int start]) native;
  void clear() { length = 0; }

  E removeLast() native "return this.pop();";

  E last() => this[this.length-1];

  List<E> getRange(int start, int length) native
    "return this.slice(start, start + length);";

  void setRange(int start, int length, List<E> from, [int startFrom]) native;
  void removeRange(int start, int length) native "this.splice(start, length);";

  void insertRange(int start, int length, [E initialValue]) native
    """
    // Splice in the values with a minimum of array allocations.
    var args = new Array(length + 2);
    args[0] = start;
    args[1] = 0;
    for (var i = 0; i < length; i++) {
      args[i + 2] = initialValue;
    }
    this.splice.apply(this, args);
    """;

  // Collection<E> members:
  void forEach(void f(E element)) native;
  Collection<E> filter(bool f(E element)) native;
  bool every(bool f(E element)) native;
  bool some(bool f(E element)) native;
  bool isEmpty() => length == 0;

  // Iterable<E> members:
  Iterator<E> iterator() => new ListIterator(this);
}

// Iterator for lists.
class ListIterator<T> implements Iterator<T> {
  ListIterator(List<T> array)
      : _array = array,
        _pos = 0 {
  }

  bool hasNext() {
    return _array.length > _pos;
  }

  T next() {
    // TODO(jmesserly): this check is redundant in a for-in loop
    // Must we do it?
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }
    return _array[_pos++];
  }

  final List<T> _array;
  int _pos;
}

/** An immutable list. Attempting to modify the list will throw an exception. */
class ImmutableList<E> extends ListFactory<E> {
  final int _length;

  // TODO(sigmund): remove this when we stop overriding the [length] property
  // in Array.
  int get length() => _length;

  void set length(int length) {
    throw const IllegalAccessException();
  }

  ImmutableList([int length]) : _length = length, super(length);

  factory ImmutableList.from(List other) {
    final list = new ImmutableList(other.length);
    for (int i = 0; i < other.length; i++) {
      // Note: push invokes the setter of [length], which we override. So
      // instead we use the native []= operator that cannot be overriden.
      list._setindex(i, other[i]);
    }
    return list;
  }

  void _setindex(int index, E value) native "return this[index] = value;";

  void operator []=(int index, E value) {
    throw const IllegalAccessException();
  }

  void copyFrom(List src, int srcStart, int dstStart, int count) {
    throw const IllegalAccessException();
  }

  void setRange(int start, int length, List<E> from, [int startFrom = 0]) {
    throw const IllegalAccessException();
  }

  void removeRange(int start, int length) {
    throw const IllegalAccessException();
  }

  void insertRange(int start, int length, [E initialValue = null]) {
    throw const IllegalAccessException();
  }

  void sort(int compare(E a, E b)) {
    throw const IllegalAccessException();
  }

  void add(E element) {
    throw const IllegalAccessException();
  }

  void addLast(E element) {
    throw const IllegalAccessException();
  }

  void addAll(Collection<E> elements) {
    throw const IllegalAccessException();
  }

  void clear() {
    throw const IllegalAccessException();
  }

  E removeLast() {
    throw const IllegalAccessException();
  }


  // The base Array.prototype.toString does not like getting derived arrays,
  // so copy the array if needed.
  // TODO(jmesserly): this is not the right long term fix because it only works
  // for ImmutableList, but all derived types of ListFactory have this problem.
  // We need to implment ListFactory.toString in Dart. However, the
  // mplmentation needs correct handling of cycles (isolate tests depend on
  // this), so it's not trivial.
  String toString() => new List.from(this).toString();
}

/** An immutable map. */
class ImmutableMap<K, V> implements Map<K, V> {
  final Map<K, V> _internal;

  ImmutableMap(List keyValuePairs) : _internal = _map(keyValuePairs);

  V operator [](K key) => _internal[key];

  bool isEmpty() => _internal.isEmpty();

  int get length() => _internal.length;

  void forEach(void f(K key, V value)) {
    _internal.forEach(f);
  }

  Collection<K> getKeys() => _internal.getKeys();

  Collection<V> getValues() => _internal.getValues();

  bool containsKey(K key) => _internal.containsKey(key);

  bool containsValue(V value) => _internal.containsValue(value);

  void operator []=(K key, V value) {
    throw const IllegalAccessException();
  }

  V putIfAbsent(K key, V ifAbsent()) {
    throw const IllegalAccessException();
  }

  void clear() {
    throw const IllegalAccessException();
  }

  V remove(K key) {
    throw const IllegalAccessException();
  }
}


// TODO(jmesserly): this should wrap real RegExp when we can
// We can't do it yet because we'd need a way to redirect the const
// default constructor.
// TODO(jimhug): One way to resolve this is to make the const constructor
// very special in order for it to generate JS regex literals into the code
// and then treat the constructor as a factory.
class JSSyntaxRegExp implements RegExp {
  final String pattern;
  final bool multiLine;
  final bool ignoreCase;

  const JSSyntaxRegExp(String pattern, [bool multiLine, bool ignoreCase]):
    this._create(pattern,
        (multiLine == true ? 'm' : '') + (ignoreCase == true ? 'i' : ''));

  const JSSyntaxRegExp._create(String pattern, String flags) native
    '''this.re = new RegExp(pattern, flags);
    this.pattern = pattern;
    this.multiLine = this.re.multiline;
    this.ignoreCase = this.re.ignoreCase;''';

  Match firstMatch(String str) {
    List<String> m = _exec(str);
    return m == null ? null
        : new MatchImplementation(pattern, str, _matchStart(m), _lastIndex, m);
  }

  List<String> _exec(String str) native "return this.re.exec(str);" {
    // Note: this code is just a hint to tell the frog compiler the dependencies
    // this native code might have. It is not an implementation.
    return [];
  }
  int _matchStart(m) native "return m.index;";
  int get _lastIndex() native "return this.re.lastIndex;";

  bool hasMatch(String str) native "return this.re.test(str);";

  String stringMatch(String str) {
    var match = firstMatch(str);
    return match === null ? null : match.group(0);
  }

  Iterable<Match> allMatches(String str) => new _AllMatchesIterable(this, str);

  /**
   * Returns a new RegExp with the same pattern as this one and with the
   * "global" flag set. This allows us to match this RegExp against a string
   * multiple times, to support things like [allMatches] and
   * [String.replaceAll].
   *
   * Note that the returned RegExp disobeys the normal API in that it maintains
   * state about the location of the last match.
   */
  JSSyntaxRegExp get _global() => new JSSyntaxRegExp._create(pattern,
      'g' + (multiLine ? 'm' : '') + (ignoreCase ? 'i' : ''));
}

class MatchImplementation implements Match {
  const MatchImplementation(
      String this.pattern,
      String this.str,
      int this._start,
      int this._end,
      List<String> this._groups);

  final String pattern;
  final String str;
  final int _start;
  final int _end;
  final List<String> _groups;

  int start() => _start;
  int end() => _end;
  String group(int group) => _groups[group];
  String operator [](int group) => _groups[group];
  int groupCount() => _groups.length;

  List<String> groups(List<int> groups) {
    List<String> out = [];
    groups.forEach((int group) => out.add(_groups[group]));
    return out;
  }
}

class _AllMatchesIterable implements Iterable<Match> {
  final JSSyntaxRegExp _re;
  final String _str;

  const _AllMatchesIterable(this._re, this._str);

  Iterator<Match> iterator() => new _AllMatchesIterator(_re, _str);
}

class _AllMatchesIterator implements Iterator<Match> {
  final RegExp _re;
  final String _str;
  Match _next;
  bool _done;

  _AllMatchesIterator(JSSyntaxRegExp re, String this._str)
    : _done = false, _re = re._global;

  Match next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }

    // _next is set by #hasNext
    var next = _next;
    _next = null;
    return next;
  }

  bool hasNext() {
    if (_done) {
      return false;
    } else if (_next != null) {
      return true;
    }

    _next = _re.firstMatch(_str);
    if (_next == null) {
      _done = true;
      return false;
    } else {
      return true;
    }
  }
}


class NumImplementation implements int, double native "Number" {
  // TODO(jimhug): Move these out of methods to avoid boxing when not needed.
  // TODO(jmesserly): for now I'm avoiding boxing with "use strict", however,
  // we might want to do something better. It would be nice if operators and
  // methods on String/num were handled in a uniform way.
  num remainder(num other) native "'use strict'; return this % other;";

  bool isEven() native "'use strict'; return ((this & 1) == 0);";
  bool isOdd() native "'use strict'; return ((this & 1) == 1);";
  bool isNaN() native "'use strict'; return isNaN(this);";
  bool isNegative() native
    "'use strict'; return this == 0 ? (1 / this) < 0 : this < 0;";
  bool isInfinite() native
    "'use strict'; return (this == Infinity) || (this == -Infinity);";

  num abs() native "'use strict'; return Math.abs(this);";
  num round() native "'use strict'; return Math.round(this);";
  num floor() native "'use strict'; return Math.floor(this);";
  num ceil() native "'use strict'; return Math.ceil(this);";
  num truncate() native
    "'use strict'; return (this < 0) ? Math.ceil(this) : Math.floor(this);";

  int hashCode() native "'use strict'; return this & 0x1FFFFFFF;";

  // If truncated is -0.0 return +0. The test will also trigger for positive
  // 0s but that's not a problem.
  int toInt() native '''
  'use strict';
  if (isNaN(this)) \$throw(new BadNumberFormatException("NaN"));
  if ((this == Infinity) || (this == -Infinity)) {
    \$throw(new BadNumberFormatException("Infinity"));
  }
  var truncated = (this < 0) ? Math.ceil(this) : Math.floor(this);
  if (truncated == -0.0) return 0;
  return truncated;''' { throw new BadNumberFormatException(""); }

  double toDouble() native "'use strict'; return this + 0;";

  String toStringAsFixed(int fractionDigits) native
    "'use strict'; return this.toFixed(fractionDigits);";
  String toStringAsExponential(int fractionDigits) native
    "'use strict'; return this.toExponential(fractionDigits)";
  String toStringAsPrecision(int precision) native
    "'use strict'; return this.toPrecision(precision)";
  String toRadixString(int radix) native
    "'use strict'; return this.toString(radix)";

  // CompareTo has to give a complete order, including -0/+0, NaN and
  // Infinities.
  // Order is: -Inf < .. < -0.0 < 0.0 .. < +inf < NaN.
  int compareTo(NumImplementation other) {
    // Don't use the 'this' object (which is a JS Number object), but get the
    // primitive JS number by invoking toDouble().
    num thisValue = toDouble();
    // Remember that NaN return false for any comparison.
    if (thisValue < other) {
      return -1;
    } else if (thisValue > other) {
      return 1;
    } else if (thisValue == other) {
      if (thisValue == 0) {
        bool thisIsNegative = isNegative();
        bool otherIsNegative = other.isNegative();
        if (thisIsNegative == otherIsNegative) return 0;
        if (thisIsNegative) return -1;
        return 1;
      }
      return 0;
    } else if (isNaN()) {
      if (other.isNaN()) {
        return 0;
      }
      return 1;
    } else {
      return -1;
    }
  }
}

</script>
<script type="application//inert" id="lib_date_implementation_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jmesserly): the native class should be the real JS Date.
// TODO(jimhug): Making the date value non-lazy might be a good path there.
class DateImplementation implements Date {
  final int value;
  final TimeZoneImplementation timeZone;

  factory DateImplementation(int years,
                             int month,
                             int day,
                             int hours,
                             int minutes,
                             int seconds,
                             int milliseconds) {
    return new DateImplementation.withTimeZone(
        years, month, day,
        hours, minutes, seconds, milliseconds,
        new TimeZoneImplementation.local());
  }

  DateImplementation.withTimeZone(int years,
                                  int month,
                                  int day,
                                  int hours,
                                  int minutes,
                                  int seconds,
                                  int milliseconds,
                                  TimeZoneImplementation timeZone)
      : this.timeZone = timeZone,
        value = _valueFromDecomposed(years, month, day,
                                     hours, minutes, seconds, milliseconds,
                                     timeZone.isUtc) { _asJs();
  }

  DateImplementation.now()
      : timeZone = new TimeZone.local(),
        value = _now() { _asJs();
  }

  DateImplementation.fromString(String formattedString)
      : timeZone = new TimeZone.local(),
        value = _valueFromString(formattedString) { _asJs();
  }

  const DateImplementation.fromEpoch(this.value, this.timeZone);

  bool operator ==(other) {
    if (!(other is DateImplementation)) return false;
    return (value == other.value) && (timeZone == other.timeZone);
  }

  int compareTo(Date other) {
    return value.compareTo(other.value);
  }

  Date changeTimeZone(TimeZone targetTimeZone) {
    if (targetTimeZone == null) {
      targetTimeZone = new TimeZoneImplementation.local();
    }
    return new Date.fromEpoch(value, targetTimeZone);
  }

  int get year() native
  '''return this.isUtc ? this._asJs().getUTCFullYear() :
    this._asJs().getFullYear();''';

  int get month() native
  '''return this.isUtc ? this._asJs().getMonth() + 1 :
      this._asJs().getMonth() + 1;''';

  int get day() native
    'return this.isUtc ? this._asJs().getUTCDate() : this._asJs().getDate()';

  int get hours() native
    'return this.isUtc ? this._asJs().getUTCHours() : this._asJs().getHours()';

  int get minutes() native
    'return this.isUtc ? this._asJs().getUTCMinutes() : this._asJs().getMinutes()';

  int get seconds() native
    'return this.isUtc ? this._asJs().getUTCSeconds() : this._asJs().getSeconds()';

  int get milliseconds() native
  '''return this.isUtc ? this._asJs().getUTCMilliseconds() :
    this._asJs().getMilliseconds();''';

  int get weekday() {
    final Date unixTimeStart =
        new Date.withTimeZone(1970, 1, 1, 0, 0, 0, 0, timeZone);
    int msSince1970 = this.difference(unixTimeStart).inMilliseconds;
    // Adjust the milliseconds to avoid problems with summer-time.
    if (hours < 2) {
      msSince1970 += 2 * Duration.MILLISECONDS_PER_HOUR;
    }
    int daysSince1970 =
        (msSince1970 / Duration.MILLISECONDS_PER_DAY).floor().toInt();
    // 1970-1-1 was a Thursday.
    return ((daysSince1970 + Date.THU) % Date.DAYS_IN_WEEK);
  }

  // TODO(jimhug): Could this please be getters?
  bool isLocalTime() {
    return !timeZone.isUtc;
  }

  bool isUtc() {
    return timeZone.isUtc;
  }

  String toString() {
    String threeDigits(int n) {
      if (n >= 100) return "${n}";
      if (n > 10) return "0${n}";
      return "00${n}";
    }
    String twoDigits(int n) {
      if (n >= 10) return "${n}";
      return "0${n}";
    }

    String m = twoDigits(month);
    String d = twoDigits(day);
    String h = twoDigits(hours);
    String min = twoDigits(minutes);
    String sec = twoDigits(seconds);
    String ms = threeDigits(milliseconds);
    if (timeZone.isUtc) {
      return "$year-$m-$d $h:$min:$sec.${ms}Z";
    } else {
      return "$year-$m-$d $h:$min:$sec.$ms";
    }
  }

  // TODO(jimhug): Why not use operators here?
    // Adds the [duration] to this Date instance.
  Date add(Duration duration) {
    return new DateImplementation.fromEpoch(value + duration.inMilliseconds,
                                            timeZone);
  }

  // Subtracts the [duration] from this Date instance.
  Date subtract(Duration duration) {
    return new DateImplementation.fromEpoch(value - duration.inMilliseconds,
                                            timeZone);
  }

  // Returns a [Duration] with the difference of [this] and [other].
  Duration difference(Date other) {
    return new Duration(milliseconds: value - other.value);
  }

  // TODO(floitsch): Use real exception object.
  static int _valueFromDecomposed(int years, int month, int day,
                                  int hours, int minutes, int seconds,
                                  int milliseconds, bool isUtc) native
  '''var jsMonth = month - 1;
  var value = isUtc ?
    Date.UTC(years, jsMonth, day,
             hours, minutes, seconds, milliseconds) :
    new Date(years, jsMonth, day,
             hours, minutes, seconds, milliseconds).valueOf();
  if (isNaN(value)) throw Error("Invalid Date");
  return value;''';

  static int _valueFromString(String str) native
  '''var value = Date.parse(str);
  if (isNaN(value)) throw Error("Invalid Date");
  return value;''';

  static int _now() native "return new Date().valueOf();";

  // Lazily keep a JS Date stored in the dart object.
  var _asJs() native '''
  if (!this.date) {
    this.date = new Date(this.value);
  }
  return this.date;''';
}

// Trivial implementation of TimeZone
class TimeZoneImplementation implements TimeZone {
  const TimeZoneImplementation.utc() : this.isUtc = true;
  const TimeZoneImplementation.local() : this.isUtc = false;

  bool operator ==(other) {
    if (!(other is TimeZoneImplementation)) return false;
    return isUtc == other.isUtc;
  }

  String toString() {
    if (isUtc) return "TimeZone (UTC)";
    return "TimeZone (Local)";
  }

  final bool isUtc;
}

</script>
<script type="application//inert" id="lib_function_implementation_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// Exception thrown when a function receives the wrong number of arguments at
/// runtime. Overridden to provide a more informative error message.
// TODO(jmesserly): should the base class support a message?
class _ArgumentMismatchException extends ClosureArgumentMismatchException {
  String _message;
  const _ArgumentMismatchException(this._message);
  String toString() => "Closure argument mismatch: $_message";
}

/// Implementation details for [Function]
/// Note: we don't expose this because it has no useful API. It's just some
/// helpers for our dynamic calling convention. Maybe in the future there will
/// be more stuff here, though.
class _FunctionImplementation implements Function native "Function" {
  /**
   * Generates a dynamic call stub for a function.
   * Our goal is to create a stub method like this on-the-fly:
   *   function($0, $1, capture) { return this($0, $1, true, capture); }
   *
   * This stub then replaces the dynamic one on Function, with one that is
   * specialized for that particular function, taking into account its default
   * arguments.
   */
  _genStub(argsLength, [names]) native @'''
    // Fast path #1: if no named arguments and arg count matches
    if (this.length == argsLength && !names) {
      return this;
    }

    var paramsNamed = this.$optional ? (this.$optional.length / 2) : 0;
    var paramsBare = this.length - paramsNamed;
    var argsNamed = names ? names.length : 0;
    var argsBare = argsLength - argsNamed;

    // Check we got the right number of arguments
    if (argsBare < paramsBare || argsLength > this.length ||
        argsNamed > paramsNamed) {
      return function() {
        $throw(new _ArgumentMismatchException(
          'Wrong number of arguments to function. Expected ' + paramsBare +
          ' positional arguments and at most ' + paramsNamed +
          ' named arguments, but got ' + argsBare +
          ' positional arguments and ' + argsNamed + ' named arguments.'));
      };
    }

    // First, fill in all of the default values
    var p = new Array(paramsBare);
    if (paramsNamed) {
      p = p.concat(this.$optional.slice(paramsNamed));
    }
    // Fill in positional args
    var a = new Array(argsLength);
    for (var i = 0; i < argsBare; i++) {
      p[i] = a[i] = '$' + i;
    }
    // Then overwrite with supplied values for optional args
    var lastParameterIndex;
    var namesInOrder = true;
    for (var i = 0; i < argsNamed; i++) {
      var name = names[i];
      a[i + argsBare] = name;
      var j = this.$optional.indexOf(name);
      if (j < 0 || j >= paramsNamed) {
        return function() {
          $throw(new _ArgumentMismatchException(
            'Named argument "' + name + '" was not expected by function.' +
            ' Did you forget to mark the function parameter [optional]?'));
        };
      } else if (lastParameterIndex && lastParameterIndex > j) {
        namesInOrder = false;
      }
      p[j + paramsBare] = name;
      lastParameterIndex = j;
    }

    if (this.length == argsLength && namesInOrder) {
      // Fast path #2: named arguments, but they're in order and all supplied.
      return this;
    }

    // Note: using Function instead of 'eval' to get a clean scope.
    // TODO(jmesserly): evaluate the performance of these stubs.
    var f = 'function(' + a.join(',') + '){return $f(' + p.join(',') + ');}';
    return new Function('$f', 'return ' + f + '').call(null, this);
  ''' {
    throw new _ArgumentMismatchException('');
  }
}

</script>
<script type="application//inert" id="lib_isolate_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * A native object that is shared across isolates. This object is visible to all
 * isolates running on the same worker (either UI or background web worker).
 *
 * This is code that is intended to 'escape' the isolate boundaries in order to
 * implement the semantics of friendly isolates in JavaScript. Without this we
 * would have been forced to implement more code (including the top-level event
 * loop) in JavaScript itself.
 */
GlobalState get _globalState() native "return \$globalState;";
set _globalState(GlobalState val) native "\$globalState = val;";

/**
 * Wrapper that takes the dart entry point and runs it within an isolate. The
 * frog compiler will inject a call of the form [: startRootIsolate(main); :]
 * when it determines that this wrapping is needed. For single-isolate
 * applications (e.g. hello world), this call is not emitted.
 */
void startRootIsolate(entry) {
  _globalState = new GlobalState();

  // Don't start the main loop again, if we are in a worker.
  if (_globalState.isWorker) return;
  final rootContext = new IsolateContext();
  _globalState.rootContext = rootContext;
  _fillStatics(rootContext);

  // BUG(5151491): Setting currentContext should not be necessary, but
  // because closures passed to the DOM as event handlers do not bind their
  // isolate automatically we try to give them a reasonable context to live in
  // by having a "default" isolate (the first one created).
  _globalState.currentContext = rootContext;

  rootContext.eval(entry);
  _globalState.topEventLoop.run();
}

void _fillStatics(context) native @"""
  $globals = context.isolateStatics;
  $static_init();
""";

/** Global state associated with the current worker. See [_globalState]. */
// TODO(sigmund): split in multiple classes: global, thread, main-worker states?
class GlobalState {

  /** Next available isolate id. */
  int nextIsolateId = 0;

  /** Worker id associated with this worker. */
  int currentWorkerId = 0;

  /**
   * Next available worker id. Only used by the main worker to assign a unique
   * id to each worker created by it.
   */
  int nextWorkerId = 1;

  /** Context for the currently running [Isolate]. */
  IsolateContext currentContext = null;

  /** Context for the root [Isolate] that first run in this worker. */
  IsolateContext rootContext = null;

  /** The top-level event loop. */
  EventLoop topEventLoop;

  /** Whether this program is running in a background worker. */
  bool isWorker;

  /** Whether this program is running in a UI worker. */
  bool inWindow;

  /** Whether we support spawning workers. */
  bool supportsWorkers;

  /**
   * Whether to use web workers when implementing isolates. Set to false for
   * debugging/testing.
   */
  bool get useWorkers() => supportsWorkers;

  /**
   * Whether to use the web-worker JSON-based message serialization protocol. By
   * default this is only used with web workers. For debugging, you can force
   * using this protocol by changing this field value to [true].
   */
  bool get needSerialization() => useWorkers;

  /**
   * Registry of isolates. Isolates must be registered if, and only if, receive
   * ports are alive.  Normally no open receive-ports means that the isolate is
   * dead, but DOM callbacks could resurrect it.
   */
  Map<int, IsolateContext> isolates;

  /** Reference to the main worker. */
  MainWorker mainWorker;

  /** Registry of active workers. Only used in the main worker. */
  Map<int, var> workers;

  GlobalState() {
    topEventLoop = new EventLoop();
    isolates = {};
    workers = {};
    mainWorker = new MainWorker();
    _nativeInit();
  }

  void _nativeInit() native @"""
    this.isWorker = typeof ($globalThis['importScripts']) != 'undefined';
    this.inWindow = typeof(window) !== 'undefined';
    this.supportsWorkers = this.isWorker ||
        ((typeof $globalThis['Worker']) != 'undefined');

    // if workers are supported, treat this as a main worker:
    if (this.supportsWorkers) {
      $globalThis.onmessage = function(e) {
        IsolateNatives._processWorkerMessage(this.mainWorker, e);
      };
    }
  """;

  /**
   * Close the worker running this code, called when there is nothing else to
   * run.
   */
  void closeWorker() {
    if (isWorker) {
      if (!isolates.isEmpty()) return;
      mainWorker.postMessage(
          _serializeMessage({'command': 'close'}));
    } else if (isolates.containsKey(rootContext.id) && workers.isEmpty() &&
               !supportsWorkers && !inWindow) {
      // This should only trigger when running on the command-line.
      // We don't want this check to execute in the browser where the isolate
      // might still be alive due to DOM callbacks.
      throw new Exception("Program exited with open ReceivePorts.");
    }
  }
}

_serializeMessage(message) {
  if (_globalState.needSerialization) {
    return new Serializer().traverse(message);
  } else {
    return new Copier().traverse(message);
  }
}

_deserializeMessage(message) {
  if (_globalState.needSerialization) {
    return new Deserializer().deserialize(message);
  } else {
    // Nothing more to do.
    return message;
  }
}

/** Default worker. */
class MainWorker {
  int id = 0;
  void postMessage(msg) native "return \$globalThis.postMessage(msg);";
  void set onmessage(f) native "\$globalThis.onmessage = f;";
  void terminate() {}
}

/**
 * A web worker. This type is also defined in 'dart:dom', but we define it here
 * to avoid introducing a dependency from corelib to dom. This definition uses a
 * 'hidden' type (* prefix on the native name) to enforce that the type is
 * defined dynamically only when web workers are actually available.
 */
class _Worker native "*Worker" {
  get id() native "return this.id;";
  void set id(i) native "this.id = i;";
  void set onmessage(f) native "this.onmessage = f;";
  void postMessage(msg) native "return this.postMessage(msg);";
}

/** Context information tracked for each isolate. */
class IsolateContext {
  /** Current isolate id. */
  int id;

  /** Registry of receive ports currently active on this isolate. */
  Map<int, ReceivePort> ports;

  /** Holds isolate globals (statics and top-level properties). */
  var isolateStatics; // native object containing all globals of an isolate.

  IsolateContext() {
    id = _globalState.nextIsolateId++;
    ports = {};
    initGlobals();
  }

  // these are filled lazily the first time the isolate starts running.
  void initGlobals() native 'this.isolateStatics = {};';

  /**
   * Run [code] in the context of the isolate represented by [this]. Note this
   * is called from JavaScript (see $wrap_call in corejs.dart).
   */
  void eval(Function code) {
    var old = _globalState.currentContext;
    _globalState.currentContext = this;
    this._setGlobals();
    var result = null;
    try {
      result = code();
    } finally {
      _globalState.currentContext = old;
      if (old != null) old._setGlobals();
    }
    return result;
  }

  void _setGlobals() native @'$globals = this.isolateStatics;';

  /** Lookup a port registered for this isolate. */
  ReceivePort lookup(int id) => ports[id];

  /** Register a port on this isolate. */
  void register(int portId, ReceivePort port)  {
    if (ports.containsKey(portId)) {
      throw new Exception("Registry: ports must be registered only once.");
    }
    ports[portId] = port;
    _globalState.isolates[id] = this; // indicate this isolate is active
  }

  /** Unregister a port on this isolate. */
  void unregister(int portId) {
    ports.remove(portId);
    if (ports.isEmpty()) {
      _globalState.isolates.remove(id); // indicate this isolate is not active
    }
  }
}

/** Represent the event loop on a javascript thread (DOM or worker). */
class EventLoop {
  Queue<IsolateEvent> events;

  EventLoop() : events = new Queue<IsolateEvent>();

  void enqueue(isolate, fn, msg) {
    events.addLast(new IsolateEvent(isolate, fn, msg));
  }

  IsolateEvent dequeue() {
    if (events.isEmpty()) return null;
    return events.removeFirst();
  }

  /** Process a single event, if any. */
  bool runIteration() {
    final event = dequeue();
    if (event == null) {
      _globalState.closeWorker();
      return false;
    }
    event.process();
    return true;
  }

  /** Function equivalent to [:window.setTimeout:] when available, or null. */
  static Function _wrapSetTimeout() native """
      return typeof window != 'undefined' ?
          function(a, b) { window.setTimeout(a, b); } : undefined;
  """;

  /**
   * Runs multiple iterations of the run-loop. If possible, each iteration is
   * run asynchronously.
   */
  void _runHelper() {
    final setTimeout = _wrapSetTimeout();
    if (setTimeout != null) {
      // Run each iteration from the browser's top event loop.
      void next() {
        if (!runIteration()) return;
        setTimeout(next, 0);
      }
      next();
    } else {
      // Run synchronously until no more iterations are available.
      while (runIteration()) {}
    }
  }

  /**
   * Call [_runHelper] but ensure that worker exceptions are propragated. Note
   * this is called from JavaScript (see $wrap_call in corejs.dart).
   */
  void run() {
    if (!_globalState.isWorker) {
      _runHelper();
    } else {
      try {
        _runHelper();
      } catch(var e, var trace) {
        _globalState.mainWorker.postMessage(_serializeMessage(
            {'command': 'error', 'msg': '$e\n$trace' }));
      }
    }
  }
}

/** An event in the top-level event queue. */
class IsolateEvent {
  IsolateContext isolate;
  Function fn;
  String message;

  IsolateEvent(this.isolate, this.fn, this.message);

  void process() {
    isolate.eval(fn);
  }
}

/** Implementation of a send port on top of JavaScript. */
class SendPortImpl implements SendPort {

  const SendPortImpl(this._workerId, this._isolateId, this._receivePortId);

  void send(var message, [SendPort replyTo = null]) {
    if (replyTo !== null && !(replyTo is SendPortImpl)) {
      throw "SendPort::send: Illegal replyTo type.";
    }
    IsolateNatives._sendMessage(_workerId, _isolateId, _receivePortId,
        _serializeMessage(message), _serializeMessage(replyTo));
  }

  // TODO(sigmund): get rid of _sendNow (still used in corelib code)
  void _sendNow(var message, replyTo) { send(message, replyTo); }

  ReceivePortSingleShotImpl call(var message) {
    final result = new ReceivePortSingleShotImpl();
    this.send(message, result.toSendPort());
    return result;
  }

  ReceivePortSingleShotImpl _callNow(var message) {
    final result = new ReceivePortSingleShotImpl();
    send(message, result.toSendPort());
    return result;
  }

  bool operator==(var other) {
    return (other is SendPortImpl) &&
        (_workerId == other._workerId) &&
        (_isolateId == other._isolateId) &&
        (_receivePortId == other._receivePortId);
  }

  int hashCode() {
    return (_workerId << 16) ^ (_isolateId << 8) ^ _receivePortId;
  }

  final int _receivePortId;
  final int _isolateId;
  final int _workerId;
}

/** Default factory for receive ports. */
class ReceivePortFactory {

  factory ReceivePort() {
    return new ReceivePortImpl();
  }

  factory ReceivePort.singleShot() {
    return new ReceivePortSingleShotImpl();
  }
}

/** Implementation of a multi-use [ReceivePort] on top of JavaScript. */
class ReceivePortImpl implements ReceivePort {
  ReceivePortImpl()
      : _id = _nextFreeId++ {
    _globalState.currentContext.register(_id, this);
  }

  void receive(void onMessage(var message, SendPort replyTo)) {
    _callback = onMessage;
  }

  void close() {
    _callback = null;
    _globalState.currentContext.unregister(_id);
  }

  /**
   * Returns a fresh [SendPort]. The implementation is not allowed to cache
   * existing ports.
   */
  SendPort toSendPort() {
    return new SendPortImpl(
        _globalState.currentWorkerId, _globalState.currentContext.id, _id);
  }

  int _id;
  Function _callback;

  static int _nextFreeId = 1;
}

/** Implementation of a single-shot [ReceivePort]. */
class ReceivePortSingleShotImpl implements ReceivePort {

  ReceivePortSingleShotImpl() : _port = new ReceivePortImpl() { }

  void receive(void callback(var message, SendPort replyTo)) {
    _port.receive((var message, SendPort replyTo) {
      _port.close();
      callback(message, replyTo);
    });
  }

  void close() {
    _port.close();
  }

  SendPort toSendPort() => _port.toSendPort();

  final ReceivePortImpl _port;
}

final String _SPAWNED_SIGNAL = "spawned";

class IsolateNatives {

  /** JavaScript-specific implementation to spawn an isolate. */
  static Future<SendPort> spawn(Isolate isolate, bool isLight) {
    Completer<SendPort> completer = new Completer<SendPort>();
    ReceivePort port = new ReceivePort.singleShot();
    port.receive((msg, SendPort replyPort) {
      assert(msg == _SPAWNED_SIGNAL);
      completer.complete(replyPort);
    });

    // TODO(floitsch): throw exception if isolate's class doesn't have a
    // default constructor.
    if (_globalState.useWorkers && !isLight) {
      _startWorker(isolate, port.toSendPort());
    } else {
      _startNonWorker(isolate, port.toSendPort());
    }

    return completer.future;
  }

  static SendPort _startWorker(Isolate runnable, SendPort replyPort) {
    var factoryName = _getJSConstructorName(runnable);
    if (_globalState.isWorker) {
      _globalState.mainWorker.postMessage(_serializeMessage({
          'command': 'spawn-worker',
          'factoryName': factoryName,
          'replyPort': replyPort}));
    } else {
      _spawnWorker(factoryName, _serializeMessage(replyPort));
    }
  }


  /**
   * The src url for the script tag that loaded this code. Used to create
   * JavaScript workers.
   */
  static String get _thisScript() =>
      _thisScriptCache != null ? _thisScriptCache : _computeThisScript();

  static String _thisScriptCache;

  // TODO(sigmund): fix - this code should be run synchronously when loading the
  // script. Running lazily on DOMContentLoaded will yield incorrect results.
  static String _computeThisScript() native @"""
    if (!$globalState.supportsWorkers || $globalState.isWorker) return null;

    // TODO(5334778): Find a cross-platform non-brittle way of getting the
    // currently running script.
    var scripts = document.getElementsByTagName('script');
    // The scripts variable only contains the scripts that have already been
    // executed. The last one is the currently running script.
    var script = scripts[scripts.length - 1];
    var src = script && script.src;
    if (!src) {
      // TODO()
      src = "FIXME:5407062" + "_" + Math.random().toString();
      if (script) script.src = src;
    }
    IsolateNatives._thisScriptCache = src;
    return src;
  """;

  /** Starts a new worker with the given URL. */
  static _Worker _newWorker(url) native "return new Worker(url);";

  /**
   * Spawns an isolate in a worker. [factoryName] is the Javascript constructor
   * name for the isolate entry point class.
   */
  static void _spawnWorker(factoryName, serializedReplyPort) {
    final worker = _newWorker(_thisScript);
    worker.onmessage = (e) { _processWorkerMessage(worker, e); };
    var workerId = _globalState.nextWorkerId++;
    // We also store the id on the worker itself so that we can unregister it.
    worker.id = workerId;
    _globalState.workers[workerId] = worker;
    worker.postMessage(_serializeMessage({
      'command': 'start',
      'id': workerId,
      'replyTo': serializedReplyPort,
      'factoryName': factoryName }));
  }

  /**
   * Assume that [e] is a browser message event and extract its message data.
   * We don't import the dom explicitly so, when workers are disabled, this
   * library can also run on top of nodejs.
   */
  static _getEventData(e) native "return e.data";

  /**
   * Process messages on a worker, either to control the worker instance or to
   * pass messages along to the isolate running in the worker.
   */
  static void _processWorkerMessage(sender, e) {
    var msg = _deserializeMessage(_getEventData(e));
    switch (msg['command']) {
      case 'start':
        _globalState.currentWorkerId = msg['id'];
        var runnerObject =
            _allocate(_getJSConstructorFromName(msg['factoryName']));
        var serializedReplyTo = msg['replyTo'];
        _globalState.topEventLoop.enqueue(new IsolateContext(), function() {
          var replyTo = _deserializeMessage(serializedReplyTo);
          IsolateNatives._startIsolate(runnerObject, replyTo);
        }, 'worker-start');
        _globalState.topEventLoop.run();
        break;
      case 'spawn-worker':
        _spawnWorker(msg['factoryName'], msg['replyPort']);
        break;
      case 'message':
        _sendMessage(msg['workerId'], msg['isolateId'], msg['portId'],
            msg['msg'], msg['replyTo']);
        _globalState.topEventLoop.run();
        break;
      case 'close':
        _log("Closing Worker");
        _globalState.workers.remove(sender.id);
        sender.terminate();
        _globalState.topEventLoop.run();
        break;
      case 'log':
        _log(msg['msg']);
        break;
      case 'print':
        if (_globalState.isWorker) {
          _globalState.mainWorker.postMessage(
              _serializeMessage({'command': 'print', 'msg': msg}));
        } else {
          print(msg['msg']);
        }
        break;
      case 'error':
        throw msg['msg'];
    }
  }

  /** Log a message, forwarding to the main worker if appropriate. */
  static _log(msg) {
    if (_globalState.isWorker) {
      _globalState.mainWorker.postMessage(
          _serializeMessage({'command': 'log', 'msg': msg }));
    } else {
      try {
        _consoleLog(msg);
      } catch(e, trace) {
        throw new Exception(trace);
      }
    }
  }

  static void _consoleLog(msg) native "\$globalThis.console.log(msg);";


  /**
   * Extract the constructor of runnable, so it can be allocated in another
   * isolate.
   */
  static var _getJSConstructor(Isolate runnable) native """
    return runnable.constructor;
  """;

  /** Extract the constructor name of a runnable */
  // TODO(sigmund): find a browser-generic way to support this.
  static var _getJSConstructorName(Isolate runnable) native """
    return runnable.constructor.name;
  """;

  /** Find a constructor given it's name. */
  static var _getJSConstructorFromName(String factoryName) native """
    return \$globalThis[factoryName];
  """;

  /** Create a new JavasSript object instance given it's constructor. */
  static var _allocate(var ctor) native "return new ctor();";

  /** Starts a non-worker isolate. */
  static SendPort _startNonWorker(Isolate runnable, SendPort replyTo) {
    // Spawn a new isolate and create the receive port in it.
    final spawned = new IsolateContext();

    // Instead of just running the provided runnable, we create a
    // new cloned instance of it with a fresh state in the spawned
    // isolate. This way, we do not get cross-isolate references
    // through the runnable.
    final ctor = _getJSConstructor(runnable);
    _globalState.topEventLoop.enqueue(spawned, function() {
      _startIsolate(_allocate(ctor), replyTo);
    }, 'nonworker start');
  }

  /** Given a ready-to-start runnable, start running it. */
  static void _startIsolate(Isolate isolate, SendPort replyTo) {
    _fillStatics(_globalState.currentContext);
    ReceivePort port = new ReceivePort();
    replyTo.send(_SPAWNED_SIGNAL, port.toSendPort());
    isolate._run(port);
  }

  static void _sendMessage(int workerId, int isolateId, int receivePortId,
      message, replyTo) {
    // Both the message and the replyTo are already serialized.
    if (workerId == _globalState.currentWorkerId) {
      var isolate = _globalState.isolates[isolateId];
      if (isolate == null) return;  // Isolate has been closed.
      var receivePort = isolate.lookup(receivePortId);
      if (receivePort == null) return;  // ReceivePort has been closed.
      _globalState.topEventLoop.enqueue(isolate, () {
        if (receivePort._callback != null) {
          receivePort._callback(
            _deserializeMessage(message), _deserializeMessage(replyTo));
        }
      }, 'receive ' + message);
    } else {
      var worker;
      // communication between workers go through the main worker
      if (_globalState.isWorker) {
        worker = _globalState.mainWorker;
      } else {
        // TODO(sigmund): make sure this works
        worker = _globalState.workers[workerId];
      }
      worker.postMessage(_serializeMessage({
          'command': 'message',
          'workerId': workerId,
          'isolateId': isolateId,
          'portId': receivePortId,
          'msg': message,
          'replyTo': replyTo }));
    }
  }
}

</script>
<script type="application//inert" id="lib_isolate_serialization_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Abstract visitor for dart objects that can be passed as messages between any
 * isolates.
 */
class MessageTraverser {
  static bool isPrimitive(x) {
    return (x === null) || (x is String) || (x is num) || (x is bool);
  }

  MessageTraverser();

  /** Visitor's entry point. */
  traverse(var x) {
    if (isPrimitive(x)) return visitPrimitive(x);
    _taggedObjects = new List();
    var result;
    try {
      result = _dispatch(x);
    } finally {
      _cleanup();
    }
    return result;
  }

  /** Remove all information injected in the native objects by this visitor. */
  void _cleanup() {
    int len = _taggedObjects.length;
    for (int i = 0; i < len; i++) {
      _clearAttachedInfo(_taggedObjects[i]);
    }
    _taggedObjects = null;
  }

  /** Injects into the native object some information used by the visitor. */
  void _attachInfo(var o, var info) {
    _taggedObjects.add(o);
    _setAttachedInfo(o, info);
  }

  /** Retrieves any information stored in the native object [o]. */
  _getInfo(var o) {
    return _getAttachedInfo(o);
  }

  _dispatch(var x) {
    if (isPrimitive(x)) return visitPrimitive(x);
    if (x is List) return visitList(x);
    if (x is Map) return visitMap(x);
    if (x is SendPortImpl) return visitSendPort(x);
    if (x is ReceivePortImpl) return visitReceivePort(x);
    if (x is ReceivePortSingleShotImpl) return visitReceivePortSingleShot(x);
    // TODO(floitsch): make this a real exception. (which one)?
    throw "Message serialization: Illegal value $x passed";
  }

  abstract visitPrimitive(x);
  abstract visitList(List x);
  abstract visitMap(Map x);
  abstract visitSendPort(SendPortImpl x);
  abstract visitReceivePort(ReceivePortImpl x);
  abstract visitReceivePortSingleShot(ReceivePortSingleShotImpl x);

  List _taggedObjects;

  _clearAttachedInfo(var o) native
      "o['__MessageTraverser__attached_info__'] = (void 0);";

  _setAttachedInfo(var o, var info) native
      "o['__MessageTraverser__attached_info__'] = info;";

  _getAttachedInfo(var o) native
      "return o['__MessageTraverser__attached_info__'];";
}

/** A visitor that recursively copies a message. */
class Copier extends MessageTraverser {
  Copier() : super();

  visitPrimitive(x) => x;

  List visitList(List list) {
    List copy = _getInfo(list);
    if (copy !== null) return copy;

    int len = list.length;

    // TODO(floitsch): we loose the generic type of the List.
    copy = new List(len);
    _attachInfo(list, copy);
    for (int i = 0; i < len; i++) {
      copy[i] = _dispatch(list[i]);
    }
    return copy;
  }

  Map visitMap(Map map) {
    Map copy = _getInfo(map);
    if (copy !== null) return copy;

    // TODO(floitsch): we loose the generic type of the map.
    copy = new Map();
    _attachInfo(map, copy);
    map.forEach((key, val) {
      copy[_dispatch(key)] = _dispatch(val);
    });
    return copy;
  }

  SendPort visitSendPort(SendPortImpl port) {
    return new SendPortImpl(port._workerId,
                            port._isolateId,
                            port._receivePortId);
  }

  SendPort visitReceivePort(ReceivePortImpl port) {
    return port.toSendPort();
  }

  SendPort visitReceivePortSingleShot(ReceivePortSingleShotImpl port) {
    return port.toSendPort();
  }
}

/** Visitor that serializes a message as a JSON array. */
class Serializer extends MessageTraverser {
  Serializer() : super();

  visitPrimitive(x) => x;

  visitList(List list) {
    int copyId = _getInfo(list);
    if (copyId !== null) return ['ref', copyId];

    int id = _nextFreeRefId++;
    _attachInfo(list, id);
    var jsArray = _serializeList(list);
    // TODO(floitsch): we are losing the generic type.
    return ['list', id, jsArray];
  }

  visitMap(Map map) {
    int copyId = _getInfo(map);
    if (copyId !== null) return ['ref', copyId];

    int id = _nextFreeRefId++;
    _attachInfo(map, id);
    var keys = _serializeList(map.getKeys());
    var values = _serializeList(map.getValues());
    // TODO(floitsch): we are losing the generic type.
    return ['map', id, keys, values];
  }

  visitSendPort(SendPortImpl port) {
    return ['sendport', port._workerId, port._isolateId, port._receivePortId];
  }

  visitReceivePort(ReceivePortImpl port) {
    return visitSendPort(port.toSendPort());;
  }

  visitReceivePortSingleShot(ReceivePortSingleShotImpl port) {
    return visitSendPort(port.toSendPort());
  }

  _serializeList(List list) {
    int len = list.length;
    var result = new List(len);
    for (int i = 0; i < len; i++) {
      result[i] = _dispatch(list[i]);
    }
    return result;
  }

  int _nextFreeRefId = 0;
}

/** Deserializes arrays created with [Serializer]. */
class Deserializer {
  Deserializer();

  static bool isPrimitive(x) {
    return (x === null) || (x is String) || (x is num) || (x is bool);
  }

  deserialize(x) {
    if (isPrimitive(x)) return x;
    // TODO(floitsch): this should be new HashMap<int, var|Dynamic>()
    _deserialized = new HashMap();
    return _deserializeHelper(x);
  }

  _deserializeHelper(x) {
    if (isPrimitive(x)) return x;
    assert(x is List);
    switch (x[0]) {
      case 'ref': return _deserializeRef(x);
      case 'list': return _deserializeList(x);
      case 'map': return _deserializeMap(x);
      case 'sendport': return _deserializeSendPort(x);
      // TODO(floitsch): Use real exception (which one?).
      default: throw "Unexpected serialized object";
    }
  }

  _deserializeRef(List x) {
    int id = x[1];
    var result = _deserialized[id];
    assert(result !== null);
    return result;
  }

  List _deserializeList(List x) {
    int id = x[1];
    // We rely on the fact that Dart-lists are directly mapped to Js-arrays.
    List dartList = x[2];
    _deserialized[id] = dartList;
    int len = dartList.length;
    for (int i = 0; i < len; i++) {
      dartList[i] = _deserializeHelper(dartList[i]);
    }
    return dartList;
  }

  Map _deserializeMap(List x) {
    Map result = new Map();
    int id = x[1];
    _deserialized[id] = result;
    List keys = x[2];
    List values = x[3];
    int len = keys.length;
    assert(len == values.length);
    for (int i = 0; i < len; i++) {
      var key = _deserializeHelper(keys[i]);
      var value = _deserializeHelper(values[i]);
      result[key] = value;
    }
    return result;
  }

  SendPort _deserializeSendPort(List x) {
    int workerId = x[1];
    int isolateId = x[2];
    int receivePortId = x[3];
    return new SendPortImpl(workerId, isolateId, receivePortId);
  }

  // TODO(floitsch): this should by Map<int, var> or Map<int, Dynamic>.
  Map<int, Dynamic> _deserialized;
}

</script>
<script type="application//inert" id="lib_json_frog_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

#library('json');
#import('dart:coreimpl');

// TODO(jmesserly): this needs cleanup
// Ideally JS objects could be treated as Dart Maps directly, and then we can
// really use native JSON.parse and JSON.stringify.

typedef Object _NativeJsonConvert(Object key, Object value);

class _JSON native 'JSON' {
  static Object parse(String jsonString, _NativeJsonConvert fn) native;
  static String stringify(Object value, _NativeJsonConvert fn) native;
}


Object _getValue(obj, key) native 'return obj[key]';
void _setValue(obj, key, value) native 'obj[key] = value';

// This is a guard against general Dart objects getting through to
// JSON.stringify. We restrict to JS primitives and JS Array.
bool _directToJson(obj) native
  "return typeof obj != 'object' || obj == null || obj instanceof Array";

ListFactory<String> _jsKeys(Object obj) native '''
if (obj != null && typeof obj == 'object' && !(obj instanceof Array)) {
return Object.keys(obj);
}
return null;
''';

/**
 * Dart interface to JavaScript objects and JSON.
 */
class JSON {
  /**
   * Takes a string in JSON notation and returns the value it
   * represents.  The resulting value is one of the following:
   *   null
   *   a bool
   *   a double
   *   a String
   *   an Array of values (recursively)
   *   a Map from property names to values (recursively)
   */
  static Object parse(String str) {
    return _JSON.parse(str, (_, obj) {
      final keys = _jsKeys(obj);
      if (keys == null) return obj;

      // Note: only need to shallow convert here--JSON.parse handles the rest.
      final map = {};
      for (String key in keys) {
        map[key] = _getValue(obj, key);
      }
      return map;
    });
  }

  /**
   * Takes a value and returns a string in JSON notation
   * representing its value, or returns null if the value is not representable
   * in JSON.  A representable value is one of the following:
   *   null
   *   a bool
   *   a double
   *   a String
   *   an Array of values (recursively)
   *   a Map from property names to values (recursively)
   */
  // TODO(jmesserly): handle any List subtype? Right now it's converted as
  // something like:
  //     {"0":1,"1":2}
  static String stringify(Object value) {
    return _JSON.stringify(value, (_, obj) {
      if (_directToJson(obj)) return obj;
      if (obj is Map<String, Dynamic>) {
        Map<String, Dynamic> map = obj;
        obj = new Object();
        map.forEach((k, v) => _setValue(obj, k, v));
        return obj;
      }
      throw new IllegalArgumentException('cannot convert "$value" to JSON');
    });
  }
}

</script>
<script type="application//inert" id="lib_math_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

class Math native 'Math' {
  /**
   * Base of the natural logarithms.
   */
  static final double E = 2.718281828459045;

  /**
   * Natural logarithm of 10.
   */
  static final double LN10 =  2.302585092994046;

  /**
   * Natural logarithm of 2.
   */
  static final double LN2 =  0.6931471805599453;

  /**
   * Base-2 logarithm of E.
   */
  static final double LOG2E = 1.4426950408889634;

  /**
   * Base-10 logarithm of E.
   */
  static final double LOG10E = 0.4342944819032518;

  /**
   * The PI constant.
   */
  static final double PI = 3.1415926535897932;

  /**
   * Square root of 1/2.
   */
  static final double SQRT1_2 = 0.7071067811865476;

  /**
   * Square root of 2.
   */
  static final double SQRT2 = 1.4142135623730951;

  /**
   * Parses a [String] representation of an [int], and returns
   * an [int]. Throws a [BadNumberFormatException] if [str]
   * cannot be parsed as an [int].
   */
  static int parseInt(String str) native '''var ret = parseInt(str);
  if (isNaN(ret)) \$throw(new BadNumberFormatException(str));
  return ret;''' { throw new BadNumberFormatException(""); }

  /**
   * Parses a [String] representation of a [double], and returns
   * a [double]. Throws a [BadNumberFormatException] if [str] cannot
   * be parsed as a [double].
   */
  static double parseDouble(String str) native '''var ret = parseFloat(str);
  if (isNaN(ret) && str != 'NaN') \$throw(new BadNumberFormatException(str));
  return ret;''' { throw new BadNumberFormatException(""); }

  static num min(num a, num b) native '''if (a == b) return a;
  if (a < b) {
    if (isNaN(b)) return b;
    else return a;
  }
  if (isNaN(a)) return a;
  else return b;''';

  static num max(num a, num b) native 'return (a >= b) ? a : b;';

  /**
   * Returns the arc tangent of [a]/[b] with sign according to quadrant.
   */
  static double atan2(num a, num b) native;

  /**
   * If the [exponent] is an integer the result is of the same type as [x].
   * Otherwise it is a [double].
   */
  static num pow(num x, num exponent) native;

  /**
   * Returns a random double greater than or equal to 0.0 and less
   * than 1.0.
   */
  static double random() native;

  static double sin(num x) native;
  static double cos(num x) native;
  static double tan(num x) native;
  static double acos(num x) native;
  static double asin(num x) native;
  static double atan(num x) native;
  static double sqrt(num x) native;
  static double exp(num x) native;
  static double log(num x) native;
}

</script>
<script type="application//inert" id="lib_natives_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Native helpers generated by the compiler
// TODO(jmesserly): more natives should use this pattern

// Translate a JavaScript exception to a Dart exception
// TODO(jmesserly): cross browser support. This is Chrome specific.
_toDartException(e) native @"""
function attachStack(dartEx) {
  // TODO(jmesserly): setting the stack property is not a long term solution.
  var stack = e.stack;
  // The stack contains the error message, and the stack is all that is
  // printed (the exception's toString() is never called).  Make the Dart
  // exception's toString() be the dominant message.
  if (typeof stack == 'string') {
    var message = dartEx.toString();
    if (/^(Type|Range)Error:/.test(stack)) {
      // Indent JS message (it can be helpful) so new message stands out.
      stack = '    (' + stack.substring(0, stack.indexOf('\n')) + ')\n' +
              stack.substring(stack.indexOf('\n') + 1);
    }
    stack = message + '\n' + stack;
  }
  dartEx.stack = stack;
  return dartEx;
}

if (e instanceof TypeError) {
  switch(e.type) {
    case 'property_not_function':
    case 'called_non_callable':
      if (e.arguments[0] == null) {
        return attachStack(new NullPointerException());
      } else {
        return attachStack(new ObjectNotClosureException());
      }
      break;
    case 'non_object_property_call':
    case 'non_object_property_load':
      return attachStack(new NullPointerException());
      break;
    case 'undefined_method':
      var mname = e.arguments[0];
      if (typeof(mname) == 'string' && (mname.indexOf('call$') == 0
          || mname == 'call' || mname == 'apply')) {
        return attachStack(new ObjectNotClosureException());
      } else {
        // TODO(jmesserly): fix noSuchMethod on operators so we don't hit this
        return attachStack(new NoSuchMethodException('', e.arguments[0], []));
      }
      break;
  }
} else if (e instanceof RangeError) {
  if (e.message.indexOf('call stack') >= 0) {
    return attachStack(new StackOverflowException());
  }
}
return e;""" {
  // Ensure constructors are generated
  new ObjectNotClosureException();
  new NullPointerException();
  new NoSuchMethodException(null, null, null);
  new StackOverflowException();
}

// TODO(jmesserly): we shouldn't be relying on the e.stack property.
// Need to mangle it.
_stackTraceOf(e) native @"return  (e && e.stack) ? e.stack : null;";

</script>
<script type="application//inert" id="lib_num_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

interface num extends Comparable, Hashable {
  // Arithmetic operations.
  num operator +(num other);
  num operator -(num other);
  num operator *(num other);
  num operator %(num other);
  num operator /(num other);
  // Truncating division.
  num operator ~/(num other);
  // The unary '-' operator.
  num operator negate();
  num remainder(num other);

  // Relational operations.
  bool operator <(num other);
  bool operator <=(num other);
  bool operator >(num other);
  bool operator >=(num other);

  // Predicates.
  bool isEven();
  bool isOdd();
  bool isNaN();
  bool isNegative();
  bool isInfinite();

  num abs();
  num round();
  num floor();
  num ceil();
  num truncate();

  int toInt();
  double toDouble();

  String toStringAsFixed(int fractionDigits);
  String toStringAsExponential(int fractionDigits);
  String toStringAsPrecision(int precision);
  String toRadixString(int radix);

  // TODO(jmesserly): we need to do something in the Frog type system to know
  // to know that most int operations are closed over integers.

  // TODO(jimhug): Bit-operations stolen from int
  int operator &(int other);
  int operator |(int other);
  int operator ^(int other);
  int operator ~();
  int operator <<(int shiftAmount);
  int operator >>(int shiftAmount);

  // bit operation missing in corelib?
  int operator >>>(int shiftAmount);
}

</script>
<script type="application//inert" id="lib_string_base_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class StringBase {
  // TODO(jmesserly): this array copy is really unfortunate
  // TODO(jmesserly): check the performance of String.fromCharCode.apply
  // TODO(jmesserly): fix the generated JS name of factory ctors,
  // they shouldn't be duplicating the name.
  static String createFromCharCodes(List<int> charCodes) native @'''
if (Object.getPrototypeOf(charCodes) !== Array.prototype) {
  charCodes = new ListFactory.ListFactory$from$factory(charCodes);
}
return String.fromCharCode.apply(null, charCodes);
''' {
    new ListFactory.from(charCodes); // ensure List.from is generated
  }

  static String join(List<String> strings, String separator) {
    if (strings.length == 0) return '';
    String s = strings[0];
    for (int i = 1; i < strings.length; i++) {
      s = s + separator + strings[i];
    }
    return s;
  }

  static String concatAll(List<String> strings) => join(strings, "");
}

</script>
<script type="application//inert" id="lib_string_buffer_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The StringBuffer class is useful for concatenating strings
 * efficiently. Only on a call to [toString] are the strings
 * concatenated to a single String.
 */
class StringBufferImpl implements StringBuffer {
  /**
   * Creates the string buffer with an initial content.
   */
  StringBufferImpl([Object content = ""]) {
    clear();
    add(content);
  }

  /**
   * Returns the length of the buffer.
   */
  int get length() {
    return _length;
  }

  bool isEmpty() {
    return _length == 0;
  }

  /**
   * Adds [obj] to the buffer. Returns [this].
   */
  StringBuffer add(Object obj) {
    String str = obj.toString();
    if (str === null || str.isEmpty()) return this;
    _buffer.add(str);
    _length += str.length;
    return this;
  }

  /**
   * Adds all items in [objects] to the buffer. Returns [this].
   */
  StringBuffer addAll(Collection<Object> objects) {
    for (Object obj in objects) {
      add(obj);
    }
    return this;
  }

  /**
   * Adds the string representation of [charCode] to the buffer.
   * Returns [this].
   */
  StringBuffer addCharCode(int charCode) {
    return add(new String.fromCharCodes([charCode]));
  }

  /**
   * Clears the string buffer. Returns [this].
   */
  StringBuffer clear() {
    _buffer = new List<String>();
    _length = 0;
    return this;
  }

  /**
   * Returns the contents of buffer as a concatenated string.
   */
  String toString() {
    if (_buffer.length == 0) return "";
    if (_buffer.length == 1) return _buffer[0];
    String result = StringBase.concatAll(_buffer);
    _buffer.clear();
    _buffer.add(result);
    // Since we track the length at each add operation, there is no
    // need to update it in this function.
    return result;
  }

  List<String> _buffer;
  int _length;
}

</script>
<script type="application//inert" id="lib_string_implementation_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

//String.prototype.get$length = function() {
//  return this.length;
//}

// TODO(jimhug): Unify with code from compiler/lib/implementation.
class StringImplementation implements String native "String" {

  String operator[](int index) native;

  int charCodeAt(int index) native;

  final int length; //native since it's on a native type.

  bool operator ==(var other) native;

  bool endsWith(String other) native '''
  'use strict';
  if (other.length > this.length) return false;
  return other == this.substring(this.length - other.length);''';

  bool startsWith(String other) native '''
  'use strict';
  if (other.length > this.length) return false;
  return other == this.substring(0, other.length);''';

  int indexOf(String other, [int start]) native;
  int lastIndexOf(String other, [int start]) native;

  bool isEmpty() => length == 0;

  String concat(String other) native;

  String operator +(Object obj) native { obj.toString(); }

  String substring(int startIndex, [int endIndex = null]) native;

  String trim() native;

  // TODO(jmesserly): should support pattern too.
  bool contains(Pattern pattern, [int startIndex]) native
    "'use strict'; return this.indexOf(pattern, startIndex) >= 0;";

  String _replaceFirst(String from, String to) native
    "'use strict';return this.replace(from, to);";

  String _replaceRegExp(RegExp from, String to) native
    "'use strict';return this.replace(from.re, to);";

  String replaceFirst(Pattern from, String to) {
    if (from is String) return _replaceFirst(from, to);
    if (from is RegExp) return _replaceRegExp(from, to);
    for (var match in from.allMatches(this)) {
      // We just care about the first match
      return substring(0, match.start()) + to + substring(match.end());
    }
  }

  String _replaceAll(String from, String to) native @"""
'use strict';
from = new RegExp(from.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'g');
to = to.replace(/\$/g, '$$$$'); // Escape sequences are fun!
return this.replace(from, to);""";

  String replaceAll(Pattern from, String to) {
    if (from is String) return _replaceAll(from, to);
    if (from is RegExp) return _replaceRegExp(from.dynamic._global, to);
    var buffer = new StringBuffer();
    var lastMatchEnd = 0;
    for (var match in from.allMatches(this)) {
      buffer.add(substring(lastMatchEnd, match.start()));
      buffer.add(to);
      lastMatchEnd = match.end();
    }
    buffer.add(substring(lastMatchEnd));
  }

  // TODO(jimhug): Get correct reified generic list here.
  List<String> split(Pattern pattern) native {
    return []; // tell the compiler an array is created
  }

  /*
  Iterable<Match> allMatches(String str) {
    List<Match> result = [];
    if (this.isEmpty()) return result;
    int length = this.length;

    int ix = 0;
    while (ix < str.length) {
      int foundIx = str.indexOf(this, ix);
      if (foundIx < 0) break;
      // Call "toString" to coerce the "this" back to a primitive string.
      result.add(new _StringMatch(foundIx, str, this.toString()));
      ix = foundIx + length;
    }
    return result;
  }
  */

  List<String> splitChars() => split('');

  List<int> charCodes() {
    int len = length;
    List<int> result = new List<int>(len);
    for (int i = 0; i < len; i++) {
      result[i] = charCodeAt(i);
    }
    return result;
  }

  String toLowerCase() native;
  String toUpperCase() native;

  // TODO(jmesserly): we might want to optimize this further.
  // This is the [Jenkins hash function][1], but with masking to keep the
  // hash in the Smi range. I did some simple microbenchmarks to verify that
  // this performs adequately on the standard words list. Letting it spill over
  // into doubles and truncating at the end was ~2x worse, letting it box was
  // ~70x worse.
  //
  // [1]: http://en.wikipedia.org/wiki/Jenkins_hash_function
  int hashCode() native '''
    'use strict';
    var hash = 0;
    for (var i = 0; i < this.length; i++) {
      hash = 0x1fffffff & (hash + this.charCodeAt(i));
      hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));
      hash ^= hash >> 6;
    }

    hash = 0x1fffffff & (hash + (0x03ffffff & hash) << 3);
    hash ^= hash >> 11;
    return 0x1fffffff & (hash + (0x00003fff & hash) << 15);''';

  int compareTo(String other) native
    "'use strict'; return this == other ? 0 : this < other ? -1 : 1;";
}

/*
class _StringMatch implements Match {
  const _StringMatch(int this._start,
                     String this.str,
                     String this.pattern);

  int start() => _start;
  int end() => _start + pattern.length;
  String operator[](int g) => group(g);
  int groupCount() => 0;

  String group(int group) {
    if (group != 0) {
      throw new IndexOutOfRangeException(group);
    }
    return pattern;
  }

  List<String> groups(List<int> groups) {
    List<String> result = new List<String>();
    for (int g in groups) {
      result.add(group(g));
    }
    return result;
  }

  final int _start;
  final String str;
  final String pattern;
}
*/

</script>
<script type="application//inert" id="release_html_dart">
#library('html');

#import('dart:dom', prefix:'dom');
#import('dart:htmlimpl');
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// DO NOT EDIT
// Auto-generated Dart HTML library.





// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AnchorElement extends Element {

  String get accessKey();

  void set accessKey(String value);

  String get charset();

  void set charset(String value);

  String get coords();

  void set coords(String value);

  String get download();

  void set download(String value);

  String get hash();

  void set hash(String value);

  String get host();

  void set host(String value);

  String get hostname();

  void set hostname(String value);

  String get href();

  void set href(String value);

  String get hreflang();

  void set hreflang(String value);

  String get name();

  void set name(String value);

  String get origin();

  String get pathname();

  void set pathname(String value);

  String get ping();

  void set ping(String value);

  String get port();

  void set port(String value);

  String get protocol();

  void set protocol(String value);

  String get rel();

  void set rel(String value);

  String get rev();

  void set rev(String value);

  String get search();

  void set search(String value);

  String get shape();

  void set shape(String value);

  String get target();

  void set target(String value);

  String get text();

  String get type();

  void set type(String value);

  String getParameter(String name);

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Animation {

  num get delay();

  int get direction();

  num get duration();

  num get elapsedTime();

  void set elapsedTime(num value);

  bool get ended();

  int get fillMode();

  int get iterationCount();

  String get name();

  bool get paused();

  void pause();

  void play();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AnimationList {

  int get length();

  Animation item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AreaElement extends Element {

  String get accessKey();

  void set accessKey(String value);

  String get alt();

  void set alt(String value);

  String get coords();

  void set coords(String value);

  String get hash();

  String get host();

  String get hostname();

  String get href();

  void set href(String value);

  bool get noHref();

  void set noHref(bool value);

  String get pathname();

  String get ping();

  void set ping(String value);

  String get port();

  String get protocol();

  String get search();

  String get shape();

  void set shape(String value);

  String get target();

  void set target(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ArrayBuffer {

  int get byteLength();

  ArrayBuffer slice(int begin, [int end]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ArrayBufferView {

  ArrayBuffer get buffer();

  int get byteLength();

  int get byteOffset();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioBuffer {

  num get duration();

  num get gain();

  void set gain(num value);

  int get length();

  int get numberOfChannels();

  num get sampleRate();

  Float32Array getChannelData(int channelIndex);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool AudioBufferCallback(AudioBuffer audioBuffer);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioBufferSourceNode extends AudioSourceNode {

  AudioBuffer get buffer();

  void set buffer(AudioBuffer value);

  AudioGain get gain();

  bool get loop();

  void set loop(bool value);

  bool get looping();

  void set looping(bool value);

  AudioParam get playbackRate();

  void noteGrainOn(num when, num grainOffset, num grainDuration);

  void noteOff(num when);

  void noteOn(num when);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioChannelMerger extends AudioNode {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioChannelSplitter extends AudioNode {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioContext {

  num get currentTime();

  AudioDestinationNode get destination();

  AudioListener get listener();

  num get sampleRate();

  RealtimeAnalyserNode createAnalyser();

  BiquadFilterNode createBiquadFilter();

  AudioBuffer createBuffer();

  AudioBufferSourceNode createBufferSource();

  AudioChannelMerger createChannelMerger();

  AudioChannelSplitter createChannelSplitter();

  ConvolverNode createConvolver();

  DelayNode createDelayNode();

  DynamicsCompressorNode createDynamicsCompressor();

  AudioGainNode createGainNode();

  HighPass2FilterNode createHighPass2Filter();

  JavaScriptAudioNode createJavaScriptNode(int bufferSize);

  LowPass2FilterNode createLowPass2Filter();

  AudioPannerNode createPanner();

  WaveShaperNode createWaveShaper();

  void decodeAudioData(ArrayBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback]);

  void startRendering();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioDestinationNode extends AudioNode {

  int get numberOfChannels();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioElement extends MediaElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioGain extends AudioParam {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioGainNode extends AudioNode {

  AudioGain get gain();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioListener {

  num get dopplerFactor();

  void set dopplerFactor(num value);

  num get speedOfSound();

  void set speedOfSound(num value);

  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp);

  void setPosition(num x, num y, num z);

  void setVelocity(num x, num y, num z);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioNode {

  AudioContext get context();

  int get numberOfInputs();

  int get numberOfOutputs();

  void connect(AudioNode destination, [int output, int input]);

  void disconnect([int output]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioPannerNode extends AudioNode {

  static final int EQUALPOWER = 0;

  static final int HRTF = 1;

  static final int SOUNDFIELD = 2;

  AudioGain get coneGain();

  num get coneInnerAngle();

  void set coneInnerAngle(num value);

  num get coneOuterAngle();

  void set coneOuterAngle(num value);

  num get coneOuterGain();

  void set coneOuterGain(num value);

  AudioGain get distanceGain();

  int get distanceModel();

  void set distanceModel(int value);

  num get maxDistance();

  void set maxDistance(num value);

  int get panningModel();

  void set panningModel(int value);

  num get refDistance();

  void set refDistance(num value);

  num get rolloffFactor();

  void set rolloffFactor(num value);

  void setOrientation(num x, num y, num z);

  void setPosition(num x, num y, num z);

  void setVelocity(num x, num y, num z);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioParam {

  num get defaultValue();

  num get maxValue();

  num get minValue();

  String get name();

  int get units();

  num get value();

  void set value(num value);

  void cancelScheduledValues(num startTime);

  void exponentialRampToValueAtTime(num value, num time);

  void linearRampToValueAtTime(num value, num time);

  void setTargetValueAtTime(num targetValue, num time, num timeConstant);

  void setValueAtTime(num value, num time);

  void setValueCurveAtTime(Float32Array values, num time, num duration);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioProcessingEvent extends Event {

  AudioBuffer get inputBuffer();

  AudioBuffer get outputBuffer();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface AudioSourceNode extends AudioNode {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BRElement extends Element {

  String get clear();

  void set clear(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BarInfo {

  bool get visible();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BaseElement extends Element {

  String get href();

  void set href(String value);

  String get target();

  void set target(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BiquadFilterNode extends AudioNode {

  static final int ALLPASS = 7;

  static final int BANDPASS = 2;

  static final int HIGHPASS = 1;

  static final int HIGHSHELF = 4;

  static final int LOWPASS = 0;

  static final int LOWSHELF = 3;

  static final int NOTCH = 6;

  static final int PEAKING = 5;

  AudioParam get Q();

  AudioParam get frequency();

  AudioParam get gain();

  int get type();

  void set type(int value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Blob {

  int get size();

  String get type();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface BlobBuilder {

  void append(var blob_OR_value, [String endings]);

  Blob getBlob([String contentType]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ButtonElement extends Element {

  String get accessKey();

  void set accessKey(String value);

  bool get autofocus();

  void set autofocus(bool value);

  bool get disabled();

  void set disabled(bool value);

  FormElement get form();

  String get formAction();

  void set formAction(String value);

  String get formEnctype();

  void set formEnctype(String value);

  String get formMethod();

  void set formMethod(String value);

  bool get formNoValidate();

  void set formNoValidate(bool value);

  String get formTarget();

  void set formTarget(String value);

  ElementList get labels();

  String get name();

  void set name(String value);

  String get type();

  String get validationMessage();

  ValidityState get validity();

  String get value();

  void set value(String value);

  bool get willValidate();

  bool checkValidity();

  void click();

  void setCustomValidity(String error);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CDATASection extends Text {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSCharsetRule extends CSSRule {

  String get encoding();

  void set encoding(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSFontFaceRule extends CSSRule {

  CSSStyleDeclaration get style();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSImportRule extends CSSRule {

  String get href();

  MediaList get media();

  CSSStyleSheet get styleSheet();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSKeyframeRule extends CSSRule {

  String get keyText();

  void set keyText(String value);

  CSSStyleDeclaration get style();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSKeyframesRule extends CSSRule {

  CSSRuleList get cssRules();

  String get name();

  void set name(String value);

  void deleteRule(String key);

  CSSKeyframeRule findRule(String key);

  void insertRule(String rule);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSMatrix default CSSMatrixFactoryProvider {

  CSSMatrix([String spec]);

  num get a();

  void set a(num value);

  num get b();

  void set b(num value);

  num get c();

  void set c(num value);

  num get d();

  void set d(num value);

  num get e();

  void set e(num value);

  num get f();

  void set f(num value);

  num get m11();

  void set m11(num value);

  num get m12();

  void set m12(num value);

  num get m13();

  void set m13(num value);

  num get m14();

  void set m14(num value);

  num get m21();

  void set m21(num value);

  num get m22();

  void set m22(num value);

  num get m23();

  void set m23(num value);

  num get m24();

  void set m24(num value);

  num get m31();

  void set m31(num value);

  num get m32();

  void set m32(num value);

  num get m33();

  void set m33(num value);

  num get m34();

  void set m34(num value);

  num get m41();

  void set m41(num value);

  num get m42();

  void set m42(num value);

  num get m43();

  void set m43(num value);

  num get m44();

  void set m44(num value);

  CSSMatrix inverse();

  CSSMatrix multiply(CSSMatrix secondMatrix);

  CSSMatrix rotate(num rotX, num rotY, num rotZ);

  CSSMatrix rotateAxisAngle(num x, num y, num z, num angle);

  CSSMatrix scale(num scaleX, num scaleY, num scaleZ);

  void setMatrixValue(String string);

  CSSMatrix skewX(num angle);

  CSSMatrix skewY(num angle);

  String toString();

  CSSMatrix translate(num x, num y, num z);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSMediaRule extends CSSRule {

  CSSRuleList get cssRules();

  MediaList get media();

  void deleteRule(int index);

  int insertRule(String rule, int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSPageRule extends CSSRule {

  String get selectorText();

  void set selectorText(String value);

  CSSStyleDeclaration get style();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSPrimitiveValue extends CSSValue {

  static final int CSS_ATTR = 22;

  static final int CSS_CM = 6;

  static final int CSS_COUNTER = 23;

  static final int CSS_DEG = 11;

  static final int CSS_DIMENSION = 18;

  static final int CSS_EMS = 3;

  static final int CSS_EXS = 4;

  static final int CSS_GRAD = 13;

  static final int CSS_HZ = 16;

  static final int CSS_IDENT = 21;

  static final int CSS_IN = 8;

  static final int CSS_KHZ = 17;

  static final int CSS_MM = 7;

  static final int CSS_MS = 14;

  static final int CSS_NUMBER = 1;

  static final int CSS_PC = 10;

  static final int CSS_PERCENTAGE = 2;

  static final int CSS_PT = 9;

  static final int CSS_PX = 5;

  static final int CSS_RAD = 12;

  static final int CSS_RECT = 24;

  static final int CSS_RGBCOLOR = 25;

  static final int CSS_S = 15;

  static final int CSS_STRING = 19;

  static final int CSS_UNKNOWN = 0;

  static final int CSS_URI = 20;

  int get primitiveType();

  Counter getCounterValue();

  num getFloatValue(int unitType);

  RGBColor getRGBColorValue();

  Rect getRectValue();

  String getStringValue();

  void setFloatValue(int unitType, num floatValue);

  void setStringValue(int stringType, String stringValue);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSRule {

  static final int CHARSET_RULE = 2;

  static final int FONT_FACE_RULE = 5;

  static final int IMPORT_RULE = 3;

  static final int MEDIA_RULE = 4;

  static final int PAGE_RULE = 6;

  static final int STYLE_RULE = 1;

  static final int UNKNOWN_RULE = 0;

  static final int WEBKIT_KEYFRAMES_RULE = 8;

  static final int WEBKIT_KEYFRAME_RULE = 9;

  static final int WEBKIT_REGION_STYLE_RULE = 10;

  String get cssText();

  void set cssText(String value);

  CSSRule get parentRule();

  CSSStyleSheet get parentStyleSheet();

  int get type();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSRuleList {

  int get length();

  CSSRule item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSStyleRule extends CSSRule {

  String get selectorText();

  void set selectorText(String value);

  CSSStyleDeclaration get style();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSStyleSheet extends StyleSheet {

  CSSRuleList get cssRules();

  CSSRule get ownerRule();

  CSSRuleList get rules();

  int addRule(String selector, String style, [int index]);

  void deleteRule(int index);

  int insertRule(String rule, int index);

  void removeRule(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSTransformValue extends CSSValueList {

  int get operationType();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSUnknownRule extends CSSRule {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSValue {

  static final int CSS_CUSTOM = 3;

  static final int CSS_INHERIT = 0;

  static final int CSS_PRIMITIVE_VALUE = 1;

  static final int CSS_VALUE_LIST = 2;

  String get cssText();

  void set cssText(String value);

  int get cssValueType();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CSSValueList extends CSSValue {

  int get length();

  CSSValue item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasElement extends Element {

  int get height();

  void set height(int value);

  int get width();

  void set width(int value);

  CanvasRenderingContext getContext([String contextId]);

  String toDataURL(String type);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasGradient {

  void addColorStop(num offset, String color);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasPattern {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasPixelArray extends List<int> {

  int get length();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasRenderingContext {

  CanvasElement get canvas();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CanvasRenderingContext2D extends CanvasRenderingContext {

  Object get fillStyle();

  void set fillStyle(Object value);

  String get font();

  void set font(String value);

  num get globalAlpha();

  void set globalAlpha(num value);

  String get globalCompositeOperation();

  void set globalCompositeOperation(String value);

  String get lineCap();

  void set lineCap(String value);

  String get lineJoin();

  void set lineJoin(String value);

  num get lineWidth();

  void set lineWidth(num value);

  num get miterLimit();

  void set miterLimit(num value);

  num get shadowBlur();

  void set shadowBlur(num value);

  String get shadowColor();

  void set shadowColor(String value);

  num get shadowOffsetX();

  void set shadowOffsetX(num value);

  num get shadowOffsetY();

  void set shadowOffsetY(num value);

  Object get strokeStyle();

  void set strokeStyle(Object value);

  String get textAlign();

  void set textAlign(String value);

  String get textBaseline();

  void set textBaseline(String value);

  List get webkitLineDash();

  void set webkitLineDash(List value);

  num get webkitLineDashOffset();

  void set webkitLineDashOffset(num value);

  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise);

  void arcTo(num x1, num y1, num x2, num y2, num radius);

  void beginPath();

  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y);

  void clearRect(num x, num y, num width, num height);

  void clearShadow();

  void clip();

  void closePath();

  ImageData createImageData(var imagedata_OR_sw, [num sh]);

  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1);

  CanvasPattern createPattern(var canvas_OR_image, String repetitionType);

  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1);

  void drawImage(var canvas_OR_image, num sx_OR_x, num sy_OR_y, [num sw_OR_width, num height_OR_sh, num dx, num dy, num dw, num dh]);

  void drawImageFromRect(ImageElement image, [num sx, num sy, num sw, num sh, num dx, num dy, num dw, num dh, String compositeOperation]);

  void fill();

  void fillRect(num x, num y, num width, num height);

  void fillText(String text, num x, num y, [num maxWidth]);

  ImageData getImageData(num sx, num sy, num sw, num sh);

  bool isPointInPath(num x, num y);

  void lineTo(num x, num y);

  TextMetrics measureText(String text);

  void moveTo(num x, num y);

  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]);

  void quadraticCurveTo(num cpx, num cpy, num x, num y);

  void rect(num x, num y, num width, num height);

  void restore();

  void rotate(num angle);

  void save();

  void scale(num sx, num sy);

  void setAlpha(num alpha);

  void setCompositeOperation(String compositeOperation);

  void setFillColor(var c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  void setLineCap(String cap);

  void setLineJoin(String join);

  void setLineWidth(num width);

  void setMiterLimit(num limit);

  void setShadow(num width, num height, num blur, [var c_OR_color_OR_grayLevel_OR_r, num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  void setStrokeColor(var c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy);

  void stroke();

  void strokeRect(num x, num y, num width, num height, [num lineWidth]);

  void strokeText(String text, num x, num y, [num maxWidth]);

  void transform(num m11, num m12, num m21, num m22, num dx, num dy);

  void translate(num tx, num ty);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface CharacterData extends Node {

  String get data();

  void set data(String value);

  int get length();

  void appendData(String data);

  void deleteData(int offset, int length);

  void insertData(int offset, String data);

  void replaceData(int offset, int length, String data);

  String substringData(int offset, int length);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ClientRect {

  num get bottom();

  num get height();

  num get left();

  num get right();

  num get top();

  num get width();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ClientRectList {

  int get length();

  ClientRect item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Clipboard {

  String get dropEffect();

  void set dropEffect(String value);

  String get effectAllowed();

  void set effectAllowed(String value);

  FileList get files();

  DataTransferItemList get items();

  List get types();

  void clearData([String type]);

  void getData(String type);

  bool setData(String type, String data);

  void setDragImage(ImageElement image, int x, int y);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Comment extends CharacterData {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Console {

  void count();

  void debug(Object arg);

  void dir();

  void dirxml();

  void error(Object arg);

  void group();

  void groupCollapsed();

  void groupEnd();

  void info(Object arg);

  void log(Object arg);

  void markTimeline();

  void time(String title);

  void timeEnd(String title);

  void timeStamp();

  void trace(Object arg);

  void warn(Object arg);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ConvolverNode extends AudioNode {

  AudioBuffer get buffer();

  void set buffer(AudioBuffer value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Coordinates {

  num get accuracy();

  num get altitude();

  num get altitudeAccuracy();

  num get heading();

  num get latitude();

  num get longitude();

  num get speed();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Counter {

  String get identifier();

  String get listStyle();

  String get separator();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Crypto {

  void getRandomValues(ArrayBufferView array);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DListElement extends Element {

  bool get compact();

  void set compact(bool value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMException {

  static final int ABORT_ERR = 20;

  static final int DATA_CLONE_ERR = 25;

  static final int DOMSTRING_SIZE_ERR = 2;

  static final int HIERARCHY_REQUEST_ERR = 3;

  static final int INDEX_SIZE_ERR = 1;

  static final int INUSE_ATTRIBUTE_ERR = 10;

  static final int INVALID_ACCESS_ERR = 15;

  static final int INVALID_CHARACTER_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 13;

  static final int INVALID_NODE_TYPE_ERR = 24;

  static final int INVALID_STATE_ERR = 11;

  static final int NAMESPACE_ERR = 14;

  static final int NETWORK_ERR = 19;

  static final int NOT_FOUND_ERR = 8;

  static final int NOT_SUPPORTED_ERR = 9;

  static final int NO_DATA_ALLOWED_ERR = 6;

  static final int NO_MODIFICATION_ALLOWED_ERR = 7;

  static final int QUOTA_EXCEEDED_ERR = 22;

  static final int SECURITY_ERR = 18;

  static final int SYNTAX_ERR = 12;

  static final int TIMEOUT_ERR = 23;

  static final int TYPE_MISMATCH_ERR = 17;

  static final int URL_MISMATCH_ERR = 21;

  static final int VALIDATION_ERR = 16;

  static final int WRONG_DOCUMENT_ERR = 4;

  int get code();

  String get message();

  String get name();

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMFileSystem {

  String get name();

  DirectoryEntry get root();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMFileSystemSync {

  String get name();

  DirectoryEntrySync get root();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMFormData {

  void append(String name, String value, String filename);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMMimeType {

  String get description();

  DOMPlugin get enabledPlugin();

  String get suffixes();

  String get type();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMMimeTypeArray {

  int get length();

  DOMMimeType item(int index);

  DOMMimeType namedItem(String name);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMParser {

  Document parseFromString(String str, String contentType);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMPlugin {

  String get description();

  String get filename();

  int get length();

  String get name();

  DOMMimeType item(int index);

  DOMMimeType namedItem(String name);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMPluginArray {

  int get length();

  DOMPlugin item(int index);

  DOMPlugin namedItem(String name);

  void refresh(bool reload);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMSelection {

  Node get anchorNode();

  int get anchorOffset();

  Node get baseNode();

  int get baseOffset();

  Node get extentNode();

  int get extentOffset();

  Node get focusNode();

  int get focusOffset();

  bool get isCollapsed();

  int get rangeCount();

  String get type();

  void addRange(Range range);

  void collapse(Node node, int index);

  void collapseToEnd();

  void collapseToStart();

  bool containsNode(Node node, bool allowPartial);

  void deleteFromDocument();

  void empty();

  void extend(Node node, int offset);

  Range getRangeAt(int index);

  void modify(String alter, String direction, String granularity);

  void removeAllRanges();

  void selectAllChildren(Node node);

  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset);

  void setPosition(Node node, int offset);

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMSettableTokenList extends DOMTokenList {

  String get value();

  void set value(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMTokenList {

  int get length();

  void add(String token);

  bool contains(String token);

  String item(int index);

  void remove(String token);

  String toString();

  bool toggle(String token);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DOMURL {

  String createObjectURL(Blob blob);

  void revokeObjectURL(String url);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DataListElement extends Element {

  ElementList get options();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DataTransferItem {

  String get kind();

  String get type();

  Blob getAsFile();

  void getAsString(StringCallback callback);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DataTransferItemList {

  int get length();

  void add(String data, String type);

  void clear();

  DataTransferItem item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DataView extends ArrayBufferView {

  num getFloat32(int byteOffset, [bool littleEndian]);

  num getFloat64(int byteOffset, [bool littleEndian]);

  int getInt16(int byteOffset, [bool littleEndian]);

  int getInt32(int byteOffset, [bool littleEndian]);

  int getInt8();

  int getUint16(int byteOffset, [bool littleEndian]);

  int getUint32(int byteOffset, [bool littleEndian]);

  int getUint8();

  void setFloat32(int byteOffset, num value, [bool littleEndian]);

  void setFloat64(int byteOffset, num value, [bool littleEndian]);

  void setInt16(int byteOffset, int value, [bool littleEndian]);

  void setInt32(int byteOffset, int value, [bool littleEndian]);

  void setInt8();

  void setUint16(int byteOffset, int value, [bool littleEndian]);

  void setUint32(int byteOffset, int value, [bool littleEndian]);

  void setUint8();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DelayNode extends AudioNode {

  AudioParam get delayTime();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DetailsElement extends Element {

  bool get open();

  void set open(bool value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DirectoryEntry extends Entry {

  DirectoryReader createReader();

  void getDirectory(String path, [Flags flags, EntryCallback successCallback, ErrorCallback errorCallback]);

  void getFile(String path, [Flags flags, EntryCallback successCallback, ErrorCallback errorCallback]);

  void removeRecursively([VoidCallback successCallback, ErrorCallback errorCallback]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DirectoryEntrySync extends EntrySync {

  DirectoryReaderSync createReader();

  DirectoryEntrySync getDirectory(String path, Flags flags);

  FileEntrySync getFile(String path, Flags flags);

  void removeRecursively();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DirectoryReader {

  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DirectoryReaderSync {

  EntryArraySync readEntries();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DivElement extends Element {

  String get align();

  void set align(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface DynamicsCompressorNode extends AudioNode {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ElementTimeControl {

  void beginElement();

  void beginElementAt(num offset);

  void endElement();

  void endElementAt(num offset);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EmbedElement extends Element {

  String get align();

  void set align(String value);

  String get height();

  void set height(String value);

  String get name();

  void set name(String value);

  String get src();

  void set src(String value);

  String get type();

  void set type(String value);

  String get width();

  void set width(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Entity extends Node {

  String get notationName();

  String get publicId();

  String get systemId();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EntityReference extends Node {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool EntriesCallback(EntryArray entries);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Entry {

  DOMFileSystem get filesystem();

  String get fullPath();

  bool get isDirectory();

  bool get isFile();

  String get name();

  void copyTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]);

  void getMetadata([MetadataCallback successCallback, ErrorCallback errorCallback]);

  void getParent([EntryCallback successCallback, ErrorCallback errorCallback]);

  void moveTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]);

  void remove([VoidCallback successCallback, ErrorCallback errorCallback]);

  String toURL();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EntryArray {

  int get length();

  Entry item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EntryArraySync {

  int get length();

  EntrySync item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool EntryCallback(Entry entry);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EntrySync {

  DOMFileSystemSync get filesystem();

  String get fullPath();

  bool get isDirectory();

  bool get isFile();

  String get name();

  EntrySync copyTo(DirectoryEntrySync parent, String name);

  Metadata getMetadata();

  DirectoryEntrySync getParent();

  EntrySync moveTo(DirectoryEntrySync parent, String name);

  void remove();

  String toURL();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool ErrorCallback(FileError error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EventException {

  static final int DISPATCH_REQUEST_ERR = 1;

  static final int UNSPECIFIED_EVENT_TYPE_ERR = 0;

  int get code();

  String get message();

  String get name();

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FieldSetElement extends Element {

  FormElement get form();

  String get validationMessage();

  ValidityState get validity();

  bool get willValidate();

  bool checkValidity();

  void setCustomValidity(String error);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface File extends Blob {

  String get fileName();

  int get fileSize();

  Date get lastModifiedDate();

  String get name();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileCallback(File file);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileEntry extends Entry {

  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback]);

  void file(FileCallback successCallback, [ErrorCallback errorCallback]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileEntrySync extends EntrySync {

  FileWriterSync createWriter();

  File file();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileError {

  static final int ABORT_ERR = 3;

  static final int ENCODING_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 9;

  static final int INVALID_STATE_ERR = 7;

  static final int NOT_FOUND_ERR = 1;

  static final int NOT_READABLE_ERR = 4;

  static final int NO_MODIFICATION_ALLOWED_ERR = 6;

  static final int PATH_EXISTS_ERR = 12;

  static final int QUOTA_EXCEEDED_ERR = 10;

  static final int SECURITY_ERR = 2;

  static final int SYNTAX_ERR = 8;

  static final int TYPE_MISMATCH_ERR = 11;

  int get code();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileException {

  static final int ABORT_ERR = 3;

  static final int ENCODING_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 9;

  static final int INVALID_STATE_ERR = 7;

  static final int NOT_FOUND_ERR = 1;

  static final int NOT_READABLE_ERR = 4;

  static final int NO_MODIFICATION_ALLOWED_ERR = 6;

  static final int PATH_EXISTS_ERR = 12;

  static final int QUOTA_EXCEEDED_ERR = 10;

  static final int SECURITY_ERR = 2;

  static final int SYNTAX_ERR = 8;

  static final int TYPE_MISMATCH_ERR = 11;

  int get code();

  String get message();

  String get name();

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileList {

  int get length();

  File item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileReader default FileReaderFactoryProvider {

  FileReader();

  static final int DONE = 2;

  static final int EMPTY = 0;

  static final int LOADING = 1;

  FileError get error();

  int get readyState();

  String get result();

  void abort();

  void readAsArrayBuffer(Blob blob);

  void readAsBinaryString(Blob blob);

  void readAsDataURL(Blob blob);

  void readAsText(Blob blob, [String encoding]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileReaderSync {

  ArrayBuffer readAsArrayBuffer(Blob blob);

  String readAsBinaryString(Blob blob);

  String readAsDataURL(Blob blob);

  String readAsText(Blob blob, [String encoding]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileSystemCallback(DOMFileSystem fileSystem);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileWriter {

  static final int DONE = 2;

  static final int INIT = 0;

  static final int WRITING = 1;

  FileError get error();

  int get length();

  int get position();

  int get readyState();

  void abort();

  void seek(int position);

  void truncate(int size);

  void write(Blob data);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileWriterCallback(FileWriter fileWriter);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FileWriterSync {

  int get length();

  int get position();

  void seek(int position);

  void truncate(int size);

  void write(Blob data);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Flags {

  bool get create();

  void set create(bool value);

  bool get exclusive();

  void set exclusive(bool value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Float32Array extends ArrayBufferView {

  static final int BYTES_PER_ELEMENT = 4;

  int get length();

  Float32Array subarray(int start, [int end]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Float64Array extends ArrayBufferView {

  static final int BYTES_PER_ELEMENT = 8;

  int get length();

  Float64Array subarray(int start, [int end]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FontElement extends Element {

  String get color();

  void set color(String value);

  String get face();

  void set face(String value);

  String get size();

  void set size(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface FormElement extends Element {

  String get acceptCharset();

  void set acceptCharset(String value);

  String get action();

  void set action(String value);

  String get autocomplete();

  void set autocomplete(String value);

  String get encoding();

  void set encoding(String value);

  String get enctype();

  void set enctype(String value);

  int get length();

  String get method();

  void set method(String value);

  String get name();

  void set name(String value);

  bool get noValidate();

  void set noValidate(bool value);

  String get target();

  void set target(String value);

  bool checkValidity();

  void reset();

  void submit();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Geolocation {

  void clearWatch(int watchId);

  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback]);

  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Geoposition {

  Coordinates get coords();

  int get timestamp();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HRElement extends Element {

  String get align();

  void set align(String value);

  bool get noShade();

  void set noShade(bool value);

  String get size();

  void set size(String value);

  String get width();

  void set width(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HTMLAllCollection {

  int get length();

  Node item(int index);

  Node namedItem(String name);

  ElementList tags(String name);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HeadElement extends Element {

  String get profile();

  void set profile(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HeadingElement extends Element {

  String get align();

  void set align(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface HighPass2FilterNode extends AudioNode {

  AudioParam get cutoff();

  AudioParam get resonance();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface History {

  int get length();

  void back();

  void forward();

  void go(int distance);

  void pushState(Object data, String title, [String url]);

  void replaceState(Object data, String title, [String url]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBAny {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBCursor {

  static final int NEXT = 0;

  static final int NEXT_NO_DUPLICATE = 1;

  static final int PREV = 2;

  static final int PREV_NO_DUPLICATE = 3;

  int get direction();

  IDBKey get key();

  IDBKey get primaryKey();

  IDBAny get source();

  void continueFunction([IDBKey key]);

  IDBRequest delete();

  IDBRequest update(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBCursorWithValue extends IDBCursor {

  IDBAny get value();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBDatabase {

  String get name();

  String get version();

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  void close();

  IDBObjectStore createObjectStore(String name);

  void deleteObjectStore(String name);

  bool dispatchEvent(Event evt);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);

  IDBVersionChangeRequest setVersion(String version);

  IDBTransaction transaction(String storeName, int mode);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBDatabaseError {

  int get code();

  void set code(int value);

  String get message();

  void set message(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBDatabaseException {

  static final int ABORT_ERR = 13;

  static final int CONSTRAINT_ERR = 4;

  static final int DATA_ERR = 5;

  static final int DEADLOCK_ERR = 11;

  static final int NON_TRANSIENT_ERR = 2;

  static final int NOT_ALLOWED_ERR = 6;

  static final int NOT_FOUND_ERR = 3;

  static final int NO_ERR = 0;

  static final int READ_ONLY_ERR = 12;

  static final int RECOVERABLE_ERR = 8;

  static final int SERIAL_ERR = 7;

  static final int TIMEOUT_ERR = 10;

  static final int TRANSIENT_ERR = 9;

  static final int UNKNOWN_ERR = 1;

  int get code();

  String get message();

  String get name();

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBFactory {

  int cmp(IDBKey first, IDBKey second);

  IDBVersionChangeRequest deleteDatabase(String name);

  IDBRequest getDatabaseNames();

  IDBRequest open(String name);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBIndex {

  String get keyPath();

  String get name();

  IDBObjectStore get objectStore();

  bool get unique();

  IDBRequest getObject(IDBKey key);

  IDBRequest getKey(IDBKey key);

  IDBRequest openCursor([IDBKeyRange range, int direction]);

  IDBRequest openKeyCursor([IDBKeyRange range, int direction]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBKey {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBKeyRange {

  IDBKey get lower();

  bool get lowerOpen();

  IDBKey get upper();

  bool get upperOpen();

  IDBKeyRange bound(IDBKey lower, IDBKey upper, [bool lowerOpen, bool upperOpen]);

  IDBKeyRange lowerBound(IDBKey bound, [bool open]);

  IDBKeyRange only(IDBKey value);

  IDBKeyRange upperBound(IDBKey bound, [bool open]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBObjectStore {

  String get keyPath();

  String get name();

  IDBTransaction get transaction();

  IDBRequest add(String value, [IDBKey key]);

  IDBRequest clear();

  IDBIndex createIndex(String name, String keyPath);

  IDBRequest delete(IDBKey key);

  void deleteIndex(String name);

  IDBRequest getObject(IDBKey key);

  IDBIndex index(String name);

  IDBRequest openCursor([IDBKeyRange range, int direction]);

  IDBRequest put(String value, [IDBKey key]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBRequest {

  static final int DONE = 2;

  static final int LOADING = 1;

  int get errorCode();

  int get readyState();

  IDBAny get result();

  IDBAny get source();

  IDBTransaction get transaction();

  String get webkitErrorMessage();

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  bool dispatchEvent(Event evt);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBTransaction {

  static final int READ_ONLY = 0;

  static final int READ_WRITE = 1;

  static final int VERSION_CHANGE = 2;

  IDBDatabase get db();

  int get mode();

  void abort();

  void addEventListener(String type, EventListener listener, [bool useCapture]);

  bool dispatchEvent(Event evt);

  IDBObjectStore objectStore(String name);

  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBVersionChangeEvent extends Event {

  String get version();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IDBVersionChangeRequest extends IDBRequest {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface IFrameElement extends Element {

  String get align();

  void set align(String value);

  Document get contentDocument();

  Window get contentWindow();

  String get frameBorder();

  void set frameBorder(String value);

  String get height();

  void set height(String value);

  String get longDesc();

  void set longDesc(String value);

  String get marginHeight();

  void set marginHeight(String value);

  String get marginWidth();

  void set marginWidth(String value);

  String get name();

  void set name(String value);

  String get sandbox();

  void set sandbox(String value);

  String get scrolling();

  void set scrolling(String value);

  String get src();

  void set src(String value);

  String get width();

  void set width(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ImageData {

  CanvasPixelArray get data();

  int get height();

  int get width();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ImageElement extends Element {

  String get align();

  void set align(String value);

  String get alt();

  void set alt(String value);

  String get border();

  void set border(String value);

  bool get complete();

  String get crossOrigin();

  void set crossOrigin(String value);

  int get height();

  void set height(int value);

  int get hspace();

  void set hspace(int value);

  bool get isMap();

  void set isMap(bool value);

  String get longDesc();

  void set longDesc(String value);

  String get lowsrc();

  void set lowsrc(String value);

  String get name();

  void set name(String value);

  int get naturalHeight();

  int get naturalWidth();

  String get src();

  void set src(String value);

  String get useMap();

  void set useMap(String value);

  int get vspace();

  void set vspace(int value);

  int get width();

  void set width(int value);

  int get x();

  int get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface InputElement extends Element {

  String get accept();

  void set accept(String value);

  String get accessKey();

  void set accessKey(String value);

  String get align();

  void set align(String value);

  String get alt();

  void set alt(String value);

  String get autocomplete();

  void set autocomplete(String value);

  bool get autofocus();

  void set autofocus(bool value);

  bool get checked();

  void set checked(bool value);

  bool get defaultChecked();

  void set defaultChecked(bool value);

  String get defaultValue();

  void set defaultValue(String value);

  bool get disabled();

  void set disabled(bool value);

  FileList get files();

  FormElement get form();

  String get formAction();

  void set formAction(String value);

  String get formEnctype();

  void set formEnctype(String value);

  String get formMethod();

  void set formMethod(String value);

  bool get formNoValidate();

  void set formNoValidate(bool value);

  String get formTarget();

  void set formTarget(String value);

  bool get incremental();

  void set incremental(bool value);

  bool get indeterminate();

  void set indeterminate(bool value);

  ElementList get labels();

  Element get list();

  String get max();

  void set max(String value);

  int get maxLength();

  void set maxLength(int value);

  String get min();

  void set min(String value);

  bool get multiple();

  void set multiple(bool value);

  String get name();

  void set name(String value);

  String get pattern();

  void set pattern(String value);

  String get placeholder();

  void set placeholder(String value);

  bool get readOnly();

  void set readOnly(bool value);

  bool get required();

  void set required(bool value);

  OptionElement get selectedOption();

  String get selectionDirection();

  void set selectionDirection(String value);

  int get selectionEnd();

  void set selectionEnd(int value);

  int get selectionStart();

  void set selectionStart(int value);

  int get size();

  void set size(int value);

  String get src();

  void set src(String value);

  String get step();

  void set step(String value);

  String get type();

  void set type(String value);

  String get useMap();

  void set useMap(String value);

  String get validationMessage();

  ValidityState get validity();

  String get value();

  void set value(String value);

  Date get valueAsDate();

  void set valueAsDate(Date value);

  num get valueAsNumber();

  void set valueAsNumber(num value);

  bool get webkitGrammar();

  void set webkitGrammar(bool value);

  bool get webkitSpeech();

  void set webkitSpeech(bool value);

  bool get webkitdirectory();

  void set webkitdirectory(bool value);

  bool get willValidate();

  bool checkValidity();

  void click();

  void select();

  void setCustomValidity(String error);

  void setSelectionRange(int start, int end, [String direction]);

  void stepDown([int n]);

  void stepUp([int n]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Int16Array extends ArrayBufferView {

  static final int BYTES_PER_ELEMENT = 2;

  int get length();

  Int16Array subarray(int start, [int end]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Int32Array extends ArrayBufferView {

  static final int BYTES_PER_ELEMENT = 4;

  int get length();

  Int32Array subarray(int start, [int end]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Int8Array extends ArrayBufferView {

  static final int BYTES_PER_ELEMENT = 1;

  int get length();

  Int8Array subarray(int start, [int end]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface JavaScriptAudioNode extends AudioNode {

  int get bufferSize();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface KeygenElement extends Element {

  bool get autofocus();

  void set autofocus(bool value);

  String get challenge();

  void set challenge(String value);

  bool get disabled();

  void set disabled(bool value);

  FormElement get form();

  String get keytype();

  void set keytype(String value);

  ElementList get labels();

  String get name();

  void set name(String value);

  String get type();

  String get validationMessage();

  ValidityState get validity();

  bool get willValidate();

  bool checkValidity();

  void setCustomValidity(String error);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LIElement extends Element {

  String get type();

  void set type(String value);

  int get value();

  void set value(int value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LabelElement extends Element {

  String get accessKey();

  void set accessKey(String value);

  Element get control();

  FormElement get form();

  String get htmlFor();

  void set htmlFor(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LegendElement extends Element {

  String get accessKey();

  void set accessKey(String value);

  String get align();

  void set align(String value);

  FormElement get form();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LinkElement extends Element {

  String get charset();

  void set charset(String value);

  bool get disabled();

  void set disabled(bool value);

  String get href();

  void set href(String value);

  String get hreflang();

  void set hreflang(String value);

  String get media();

  void set media(String value);

  String get rel();

  void set rel(String value);

  String get rev();

  void set rev(String value);

  StyleSheet get sheet();

  DOMSettableTokenList get sizes();

  void set sizes(DOMSettableTokenList value);

  String get target();

  void set target(String value);

  String get type();

  void set type(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Location {

  String get hash();

  void set hash(String value);

  String get host();

  void set host(String value);

  String get hostname();

  void set hostname(String value);

  String get href();

  void set href(String value);

  String get origin();

  String get pathname();

  void set pathname(String value);

  String get port();

  void set port(String value);

  String get protocol();

  void set protocol(String value);

  String get search();

  void set search(String value);

  void assign(String url);

  String getParameter(String name);

  void reload();

  void replace(String url);

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LoseContext {

  void loseContext();

  void restoreContext();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface LowPass2FilterNode extends AudioNode {

  AudioParam get cutoff();

  AudioParam get resonance();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MapElement extends Element {

  ElementList get areas();

  String get name();

  void set name(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MarqueeElement extends Element {

  String get behavior();

  void set behavior(String value);

  String get bgColor();

  void set bgColor(String value);

  String get direction();

  void set direction(String value);

  String get height();

  void set height(String value);

  int get hspace();

  void set hspace(int value);

  int get loop();

  void set loop(int value);

  int get scrollAmount();

  void set scrollAmount(int value);

  int get scrollDelay();

  void set scrollDelay(int value);

  bool get trueSpeed();

  void set trueSpeed(bool value);

  int get vspace();

  void set vspace(int value);

  String get width();

  void set width(String value);

  void start();

  void stop();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaElement extends Element {

  bool get autoplay();

  void set autoplay(bool value);

  TimeRanges get buffered();

  bool get controls();

  void set controls(bool value);

  String get currentSrc();

  num get currentTime();

  void set currentTime(num value);

  bool get defaultMuted();

  void set defaultMuted(bool value);

  num get defaultPlaybackRate();

  void set defaultPlaybackRate(num value);

  num get duration();

  bool get ended();

  MediaError get error();

  num get initialTime();

  bool get loop();

  void set loop(bool value);

  bool get muted();

  void set muted(bool value);

  int get networkState();

  bool get paused();

  num get playbackRate();

  void set playbackRate(num value);

  TimeRanges get played();

  String get preload();

  void set preload(String value);

  int get readyState();

  TimeRanges get seekable();

  bool get seeking();

  String get src();

  void set src(String value);

  num get startTime();

  num get volume();

  void set volume(num value);

  int get webkitAudioDecodedByteCount();

  bool get webkitClosedCaptionsVisible();

  void set webkitClosedCaptionsVisible(bool value);

  bool get webkitHasClosedCaptions();

  bool get webkitPreservesPitch();

  void set webkitPreservesPitch(bool value);

  int get webkitVideoDecodedByteCount();

  String canPlayType(String type);

  void load();

  void pause();

  void play();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaElementAudioSourceNode extends AudioSourceNode {

  MediaElement get mediaElement();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaError {

  static final int MEDIA_ERR_ABORTED = 1;

  static final int MEDIA_ERR_DECODE = 3;

  static final int MEDIA_ERR_NETWORK = 2;

  static final int MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

  int get code();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaList extends List<String> {

  int get length();

  String get mediaText();

  void set mediaText(String value);

  void appendMedium(String newMedium);

  void deleteMedium(String oldMedium);

  String item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaQueryList {

  bool get matches();

  String get media();

  void addListener(MediaQueryListListener listener);

  void removeListener(MediaQueryListListener listener);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MediaQueryListListener {

  void queryChanged(MediaQueryList list);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MenuElement extends Element {

  bool get compact();

  void set compact(bool value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MessageChannel {

  MessagePort get port1();

  MessagePort get port2();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MetaElement extends Element {

  String get content();

  void set content(String value);

  String get httpEquiv();

  void set httpEquiv(String value);

  String get name();

  void set name(String value);

  String get scheme();

  void set scheme(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Metadata {

  Date get modificationTime();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool MetadataCallback(Metadata metadata);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MeterElement extends Element {

  FormElement get form();

  num get high();

  void set high(num value);

  ElementList get labels();

  num get low();

  void set low(num value);

  num get max();

  void set max(num value);

  num get min();

  void set min(num value);

  num get optimum();

  void set optimum(num value);

  num get value();

  void set value(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ModElement extends Element {

  String get cite();

  void set cite(String value);

  String get dateTime();

  void set dateTime(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MutationCallback {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface MutationRecord {

  ElementList get addedNodes();

  String get attributeName();

  String get attributeNamespace();

  Node get nextSibling();

  String get oldValue();

  Node get previousSibling();

  ElementList get removedNodes();

  Node get target();

  String get type();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Navigator {

  String get appCodeName();

  String get appName();

  String get appVersion();

  bool get cookieEnabled();

  String get language();

  DOMMimeTypeArray get mimeTypes();

  bool get onLine();

  String get platform();

  DOMPluginArray get plugins();

  String get product();

  String get productSub();

  String get userAgent();

  String get vendor();

  String get vendorSub();

  void getStorageUpdates();

  bool javaEnabled();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface NavigatorUserMediaError {

  static final int PERMISSION_DENIED = 1;

  int get code();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool NavigatorUserMediaErrorCallback(NavigatorUserMediaError error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface NavigatorUserMediaSuccessCallback {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Notation extends Node {

  String get publicId();

  String get systemId();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface NotificationCenter {

  int checkPermission();

  Notification createHTMLNotification(String url);

  Notification createNotification(String iconUrl, String title, String body);

  void requestPermission(VoidCallback callback);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OESStandardDerivatives {

  static final int FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OESTextureFloat {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OESVertexArrayObject {

  static final int VERTEX_ARRAY_BINDING_OES = 0x85B5;

  void bindVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);

  WebGLVertexArrayObjectOES createVertexArrayOES();

  void deleteVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);

  bool isVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OListElement extends Element {

  bool get compact();

  void set compact(bool value);

  int get start();

  void set start(int value);

  String get type();

  void set type(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OfflineAudioCompletionEvent extends Event {

  AudioBuffer get renderedBuffer();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OperationNotAllowedException {

  static final int NOT_ALLOWED_ERR = 1;

  int get code();

  String get message();

  String get name();

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OptGroupElement extends Element {

  bool get disabled();

  void set disabled(bool value);

  String get label();

  void set label(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OptionElement extends Element {

  bool get defaultSelected();

  void set defaultSelected(bool value);

  bool get disabled();

  void set disabled(bool value);

  FormElement get form();

  int get index();

  String get label();

  void set label(String value);

  bool get selected();

  void set selected(bool value);

  String get text();

  void set text(String value);

  String get value();

  void set value(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface OutputElement extends Element {

  String get defaultValue();

  void set defaultValue(String value);

  FormElement get form();

  DOMSettableTokenList get htmlFor();

  void set htmlFor(DOMSettableTokenList value);

  ElementList get labels();

  String get name();

  void set name(String value);

  String get type();

  String get validationMessage();

  ValidityState get validity();

  String get value();

  void set value(String value);

  bool get willValidate();

  bool checkValidity();

  void setCustomValidity(String error);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ParagraphElement extends Element {

  String get align();

  void set align(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ParamElement extends Element {

  String get name();

  void set name(String value);

  String get type();

  void set type(String value);

  String get value();

  void set value(String value);

  String get valueType();

  void set valueType(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Point default PointFactoryProvider {

  Point(num x, num y);

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool PositionCallback(Geoposition position);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface PositionError {

  static final int PERMISSION_DENIED = 1;

  static final int POSITION_UNAVAILABLE = 2;

  static final int TIMEOUT = 3;

  int get code();

  String get message();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool PositionErrorCallback(PositionError error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface PreElement extends Element {

  int get width();

  void set width(int value);

  bool get wrap();

  void set wrap(bool value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ProcessingInstruction extends Node {

  String get data();

  void set data(String value);

  StyleSheet get sheet();

  String get target();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ProgressElement extends Element {

  FormElement get form();

  ElementList get labels();

  num get max();

  void set max(num value);

  num get position();

  num get value();

  void set value(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface QuoteElement extends Element {

  String get cite();

  void set cite(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface RGBColor {

  CSSPrimitiveValue get blue();

  CSSPrimitiveValue get green();

  CSSPrimitiveValue get red();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Range {

  static final int END_TO_END = 2;

  static final int END_TO_START = 3;

  static final int NODE_AFTER = 1;

  static final int NODE_BEFORE = 0;

  static final int NODE_BEFORE_AND_AFTER = 2;

  static final int NODE_INSIDE = 3;

  static final int START_TO_END = 1;

  static final int START_TO_START = 0;

  bool get collapsed();

  Node get commonAncestorContainer();

  Node get endContainer();

  int get endOffset();

  Node get startContainer();

  int get startOffset();

  DocumentFragment cloneContents();

  Range cloneRange();

  void collapse(bool toStart);

  int compareNode(Node refNode);

  int comparePoint(Node refNode, int offset);

  DocumentFragment createContextualFragment(String html);

  void deleteContents();

  void detach();

  void expand(String unit);

  DocumentFragment extractContents();

  ClientRect getBoundingClientRect();

  ClientRectList getClientRects();

  void insertNode(Node newNode);

  bool intersectsNode(Node refNode);

  bool isPointInRange(Node refNode, int offset);

  void selectNode(Node refNode);

  void selectNodeContents(Node refNode);

  void setEnd(Node refNode, int offset);

  void setEndAfter(Node refNode);

  void setEndBefore(Node refNode);

  void setStart(Node refNode, int offset);

  void setStartAfter(Node refNode);

  void setStartBefore(Node refNode);

  void surroundContents(Node newParent);

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface RangeException {

  static final int BAD_BOUNDARYPOINTS_ERR = 1;

  static final int INVALID_NODE_TYPE_ERR = 2;

  int get code();

  String get message();

  String get name();

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface RealtimeAnalyserNode extends AudioNode {

  int get fftSize();

  void set fftSize(int value);

  int get frequencyBinCount();

  num get maxDecibels();

  void set maxDecibels(num value);

  num get minDecibels();

  void set minDecibels(num value);

  num get smoothingTimeConstant();

  void set smoothingTimeConstant(num value);

  void getByteFrequencyData(Uint8Array array);

  void getByteTimeDomainData(Uint8Array array);

  void getFloatFrequencyData(Float32Array array);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Rect {

  CSSPrimitiveValue get bottom();

  CSSPrimitiveValue get left();

  CSSPrimitiveValue get right();

  CSSPrimitiveValue get top();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGAnimatedString get target();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAltGlyphDefElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAltGlyphElement extends SVGTextPositioningElement, SVGURIReference {

  String get format();

  void set format(String value);

  String get glyphRef();

  void set glyphRef(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAltGlyphItemElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAngle {

  static final int SVG_ANGLETYPE_DEG = 2;

  static final int SVG_ANGLETYPE_GRAD = 4;

  static final int SVG_ANGLETYPE_RAD = 3;

  static final int SVG_ANGLETYPE_UNKNOWN = 0;

  static final int SVG_ANGLETYPE_UNSPECIFIED = 1;

  int get unitType();

  num get value();

  void set value(num value);

  String get valueAsString();

  void set valueAsString(String value);

  num get valueInSpecifiedUnits();

  void set valueInSpecifiedUnits(num value);

  void convertToSpecifiedUnits(int unitType);

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimateColorElement extends SVGAnimationElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimateElement extends SVGAnimationElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimateMotionElement extends SVGAnimationElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimateTransformElement extends SVGAnimationElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedAngle {

  SVGAngle get animVal();

  SVGAngle get baseVal();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedBoolean {

  bool get animVal();

  bool get baseVal();

  void set baseVal(bool value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedEnumeration {

  int get animVal();

  int get baseVal();

  void set baseVal(int value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedInteger {

  int get animVal();

  int get baseVal();

  void set baseVal(int value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedLength {

  SVGLength get animVal();

  SVGLength get baseVal();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedLengthList {

  SVGLengthList get animVal();

  SVGLengthList get baseVal();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedNumber {

  num get animVal();

  num get baseVal();

  void set baseVal(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedNumberList {

  SVGNumberList get animVal();

  SVGNumberList get baseVal();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedPreserveAspectRatio {

  SVGPreserveAspectRatio get animVal();

  SVGPreserveAspectRatio get baseVal();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedRect {

  SVGRect get animVal();

  SVGRect get baseVal();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedString {

  String get animVal();

  String get baseVal();

  void set baseVal(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimatedTransformList {

  SVGTransformList get animVal();

  SVGTransformList get baseVal();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGAnimationElement extends SVGElement, SVGTests, SVGExternalResourcesRequired, ElementTimeControl {

  SVGElement get targetElement();

  num getCurrentTime();

  num getSimpleDuration();

  num getStartTime();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGCircleElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGAnimatedLength get cx();

  SVGAnimatedLength get cy();

  SVGAnimatedLength get r();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGClipPathElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGAnimatedEnumeration get clipPathUnits();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGColor extends CSSValue {

  static final int SVG_COLORTYPE_CURRENTCOLOR = 3;

  static final int SVG_COLORTYPE_RGBCOLOR = 1;

  static final int SVG_COLORTYPE_RGBCOLOR_ICCCOLOR = 2;

  static final int SVG_COLORTYPE_UNKNOWN = 0;

  int get colorType();

  RGBColor get rgbColor();

  void setColor(int colorType, String rgbColor, String iccColor);

  void setRGBColor(String rgbColor);

  void setRGBColorICCColor(String rgbColor, String iccColor);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGComponentTransferFunctionElement extends SVGElement {

  static final int SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE = 3;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_GAMMA = 5;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY = 1;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_LINEAR = 4;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_TABLE = 2;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN = 0;

  SVGAnimatedNumber get amplitude();

  SVGAnimatedNumber get exponent();

  SVGAnimatedNumber get intercept();

  SVGAnimatedNumber get offset();

  SVGAnimatedNumber get slope();

  SVGAnimatedNumberList get tableValues();

  SVGAnimatedEnumeration get type();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGCursorElement extends SVGElement, SVGURIReference, SVGTests, SVGExternalResourcesRequired {

  SVGAnimatedLength get x();

  SVGAnimatedLength get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGDefsElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGDescElement extends SVGElement, SVGLangSpace, SVGStylable {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGElementInstanceList {

  int get length();

  SVGElementInstance item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGEllipseElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGAnimatedLength get cx();

  SVGAnimatedLength get cy();

  SVGAnimatedLength get rx();

  SVGAnimatedLength get ry();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGException {

  static final int SVG_INVALID_VALUE_ERR = 1;

  static final int SVG_MATRIX_NOT_INVERTABLE = 2;

  static final int SVG_WRONG_TYPE_ERR = 0;

  int get code();

  String get message();

  String get name();

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGExternalResourcesRequired {

  SVGAnimatedBoolean get externalResourcesRequired();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEBlendElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_FEBLEND_MODE_DARKEN = 4;

  static final int SVG_FEBLEND_MODE_LIGHTEN = 5;

  static final int SVG_FEBLEND_MODE_MULTIPLY = 2;

  static final int SVG_FEBLEND_MODE_NORMAL = 1;

  static final int SVG_FEBLEND_MODE_SCREEN = 3;

  static final int SVG_FEBLEND_MODE_UNKNOWN = 0;

  SVGAnimatedString get in1();

  SVGAnimatedString get in2();

  SVGAnimatedEnumeration get mode();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEColorMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3;

  static final int SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4;

  static final int SVG_FECOLORMATRIX_TYPE_MATRIX = 1;

  static final int SVG_FECOLORMATRIX_TYPE_SATURATE = 2;

  static final int SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0;

  SVGAnimatedString get in1();

  SVGAnimatedEnumeration get type();

  SVGAnimatedNumberList get values();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEComponentTransferElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  SVGAnimatedString get in1();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEConvolveMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_EDGEMODE_DUPLICATE = 1;

  static final int SVG_EDGEMODE_NONE = 3;

  static final int SVG_EDGEMODE_UNKNOWN = 0;

  static final int SVG_EDGEMODE_WRAP = 2;

  SVGAnimatedNumber get bias();

  SVGAnimatedNumber get divisor();

  SVGAnimatedEnumeration get edgeMode();

  SVGAnimatedString get in1();

  SVGAnimatedNumberList get kernelMatrix();

  SVGAnimatedNumber get kernelUnitLengthX();

  SVGAnimatedNumber get kernelUnitLengthY();

  SVGAnimatedInteger get orderX();

  SVGAnimatedInteger get orderY();

  SVGAnimatedBoolean get preserveAlpha();

  SVGAnimatedInteger get targetX();

  SVGAnimatedInteger get targetY();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEDiffuseLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  SVGAnimatedNumber get diffuseConstant();

  SVGAnimatedString get in1();

  SVGAnimatedNumber get kernelUnitLengthX();

  SVGAnimatedNumber get kernelUnitLengthY();

  SVGAnimatedNumber get surfaceScale();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEDisplacementMapElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_CHANNEL_A = 4;

  static final int SVG_CHANNEL_B = 3;

  static final int SVG_CHANNEL_G = 2;

  static final int SVG_CHANNEL_R = 1;

  static final int SVG_CHANNEL_UNKNOWN = 0;

  SVGAnimatedString get in1();

  SVGAnimatedString get in2();

  SVGAnimatedNumber get scale();

  SVGAnimatedEnumeration get xChannelSelector();

  SVGAnimatedEnumeration get yChannelSelector();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEDistantLightElement extends SVGElement {

  SVGAnimatedNumber get azimuth();

  SVGAnimatedNumber get elevation();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEDropShadowElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  SVGAnimatedNumber get dx();

  SVGAnimatedNumber get dy();

  SVGAnimatedString get in1();

  SVGAnimatedNumber get stdDeviationX();

  SVGAnimatedNumber get stdDeviationY();

  void setStdDeviation(num stdDeviationX, num stdDeviationY);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEFloodElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEFuncAElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEFuncBElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEFuncGElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEFuncRElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEGaussianBlurElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  SVGAnimatedString get in1();

  SVGAnimatedNumber get stdDeviationX();

  SVGAnimatedNumber get stdDeviationY();

  void setStdDeviation(num stdDeviationX, num stdDeviationY);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEImageElement extends SVGElement, SVGURIReference, SVGLangSpace, SVGExternalResourcesRequired, SVGFilterPrimitiveStandardAttributes {

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEMergeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEMergeNodeElement extends SVGElement {

  SVGAnimatedString get in1();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEOffsetElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  SVGAnimatedNumber get dx();

  SVGAnimatedNumber get dy();

  SVGAnimatedString get in1();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFEPointLightElement extends SVGElement {

  SVGAnimatedNumber get x();

  SVGAnimatedNumber get y();

  SVGAnimatedNumber get z();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFESpecularLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  SVGAnimatedString get in1();

  SVGAnimatedNumber get specularConstant();

  SVGAnimatedNumber get specularExponent();

  SVGAnimatedNumber get surfaceScale();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFESpotLightElement extends SVGElement {

  SVGAnimatedNumber get limitingConeAngle();

  SVGAnimatedNumber get pointsAtX();

  SVGAnimatedNumber get pointsAtY();

  SVGAnimatedNumber get pointsAtZ();

  SVGAnimatedNumber get specularExponent();

  SVGAnimatedNumber get x();

  SVGAnimatedNumber get y();

  SVGAnimatedNumber get z();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFETileElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  SVGAnimatedString get in1();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFETurbulenceElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_STITCHTYPE_NOSTITCH = 2;

  static final int SVG_STITCHTYPE_STITCH = 1;

  static final int SVG_STITCHTYPE_UNKNOWN = 0;

  static final int SVG_TURBULENCE_TYPE_FRACTALNOISE = 1;

  static final int SVG_TURBULENCE_TYPE_TURBULENCE = 2;

  static final int SVG_TURBULENCE_TYPE_UNKNOWN = 0;

  SVGAnimatedNumber get baseFrequencyX();

  SVGAnimatedNumber get baseFrequencyY();

  SVGAnimatedInteger get numOctaves();

  SVGAnimatedNumber get seed();

  SVGAnimatedEnumeration get stitchTiles();

  SVGAnimatedEnumeration get type();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFilterElement extends SVGElement, SVGURIReference, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  SVGAnimatedInteger get filterResX();

  SVGAnimatedInteger get filterResY();

  SVGAnimatedEnumeration get filterUnits();

  SVGAnimatedLength get height();

  SVGAnimatedEnumeration get primitiveUnits();

  SVGAnimatedLength get width();

  SVGAnimatedLength get x();

  SVGAnimatedLength get y();

  void setFilterRes(int filterResX, int filterResY);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFilterPrimitiveStandardAttributes extends SVGStylable {

  SVGAnimatedLength get height();

  SVGAnimatedString get result();

  SVGAnimatedLength get width();

  SVGAnimatedLength get x();

  SVGAnimatedLength get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFitToViewBox {

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio();

  SVGAnimatedRect get viewBox();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontFaceElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontFaceFormatElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontFaceNameElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontFaceSrcElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGFontFaceUriElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGForeignObjectElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGAnimatedLength get height();

  SVGAnimatedLength get width();

  SVGAnimatedLength get x();

  SVGAnimatedLength get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGGElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGGlyphElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGGlyphRefElement extends SVGElement, SVGURIReference, SVGStylable {

  num get dx();

  void set dx(num value);

  num get dy();

  void set dy(num value);

  String get format();

  void set format(String value);

  String get glyphRef();

  void set glyphRef(String value);

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGGradientElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired, SVGStylable {

  static final int SVG_SPREADMETHOD_PAD = 1;

  static final int SVG_SPREADMETHOD_REFLECT = 2;

  static final int SVG_SPREADMETHOD_REPEAT = 3;

  static final int SVG_SPREADMETHOD_UNKNOWN = 0;

  SVGAnimatedTransformList get gradientTransform();

  SVGAnimatedEnumeration get gradientUnits();

  SVGAnimatedEnumeration get spreadMethod();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGHKernElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGImageElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGAnimatedLength get height();

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio();

  SVGAnimatedLength get width();

  SVGAnimatedLength get x();

  SVGAnimatedLength get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLangSpace {

  String get xmllang();

  void set xmllang(String value);

  String get xmlspace();

  void set xmlspace(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLength {

  static final int SVG_LENGTHTYPE_CM = 6;

  static final int SVG_LENGTHTYPE_EMS = 3;

  static final int SVG_LENGTHTYPE_EXS = 4;

  static final int SVG_LENGTHTYPE_IN = 8;

  static final int SVG_LENGTHTYPE_MM = 7;

  static final int SVG_LENGTHTYPE_NUMBER = 1;

  static final int SVG_LENGTHTYPE_PC = 10;

  static final int SVG_LENGTHTYPE_PERCENTAGE = 2;

  static final int SVG_LENGTHTYPE_PT = 9;

  static final int SVG_LENGTHTYPE_PX = 5;

  static final int SVG_LENGTHTYPE_UNKNOWN = 0;

  int get unitType();

  num get value();

  void set value(num value);

  String get valueAsString();

  void set valueAsString(String value);

  num get valueInSpecifiedUnits();

  void set valueInSpecifiedUnits(num value);

  void convertToSpecifiedUnits(int unitType);

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLengthList {

  int get numberOfItems();

  SVGLength appendItem(SVGLength item);

  void clear();

  SVGLength getItem(int index);

  SVGLength initialize(SVGLength item);

  SVGLength insertItemBefore(SVGLength item, int index);

  SVGLength removeItem(int index);

  SVGLength replaceItem(SVGLength item, int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLineElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGAnimatedLength get x1();

  SVGAnimatedLength get x2();

  SVGAnimatedLength get y1();

  SVGAnimatedLength get y2();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLinearGradientElement extends SVGGradientElement {

  SVGAnimatedLength get x1();

  SVGAnimatedLength get x2();

  SVGAnimatedLength get y1();

  SVGAnimatedLength get y2();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGLocatable {

  SVGElement get farthestViewportElement();

  SVGElement get nearestViewportElement();

  SVGRect getBBox();

  SVGMatrix getCTM();

  SVGMatrix getScreenCTM();

  SVGMatrix getTransformToElement(SVGElement element);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMPathElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMarkerElement extends SVGElement, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {

  static final int SVG_MARKERUNITS_STROKEWIDTH = 2;

  static final int SVG_MARKERUNITS_UNKNOWN = 0;

  static final int SVG_MARKERUNITS_USERSPACEONUSE = 1;

  static final int SVG_MARKER_ORIENT_ANGLE = 2;

  static final int SVG_MARKER_ORIENT_AUTO = 1;

  static final int SVG_MARKER_ORIENT_UNKNOWN = 0;

  SVGAnimatedLength get markerHeight();

  SVGAnimatedEnumeration get markerUnits();

  SVGAnimatedLength get markerWidth();

  SVGAnimatedAngle get orientAngle();

  SVGAnimatedEnumeration get orientType();

  SVGAnimatedLength get refX();

  SVGAnimatedLength get refY();

  void setOrientToAngle(SVGAngle angle);

  void setOrientToAuto();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMaskElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  SVGAnimatedLength get height();

  SVGAnimatedEnumeration get maskContentUnits();

  SVGAnimatedEnumeration get maskUnits();

  SVGAnimatedLength get width();

  SVGAnimatedLength get x();

  SVGAnimatedLength get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMatrix {

  num get a();

  void set a(num value);

  num get b();

  void set b(num value);

  num get c();

  void set c(num value);

  num get d();

  void set d(num value);

  num get e();

  void set e(num value);

  num get f();

  void set f(num value);

  SVGMatrix flipX();

  SVGMatrix flipY();

  SVGMatrix inverse();

  SVGMatrix multiply(SVGMatrix secondMatrix);

  SVGMatrix rotate(num angle);

  SVGMatrix rotateFromVector(num x, num y);

  SVGMatrix scale(num scaleFactor);

  SVGMatrix scaleNonUniform(num scaleFactorX, num scaleFactorY);

  SVGMatrix skewX(num angle);

  SVGMatrix skewY(num angle);

  SVGMatrix translate(num x, num y);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMetadataElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGMissingGlyphElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGNumber {

  num get value();

  void set value(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGNumberList {

  int get numberOfItems();

  SVGNumber appendItem(SVGNumber item);

  void clear();

  SVGNumber getItem(int index);

  SVGNumber initialize(SVGNumber item);

  SVGNumber insertItemBefore(SVGNumber item, int index);

  SVGNumber removeItem(int index);

  SVGNumber replaceItem(SVGNumber item, int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPaint extends SVGColor {

  static final int SVG_PAINTTYPE_CURRENTCOLOR = 102;

  static final int SVG_PAINTTYPE_NONE = 101;

  static final int SVG_PAINTTYPE_RGBCOLOR = 1;

  static final int SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR = 2;

  static final int SVG_PAINTTYPE_UNKNOWN = 0;

  static final int SVG_PAINTTYPE_URI = 107;

  static final int SVG_PAINTTYPE_URI_CURRENTCOLOR = 104;

  static final int SVG_PAINTTYPE_URI_NONE = 103;

  static final int SVG_PAINTTYPE_URI_RGBCOLOR = 105;

  static final int SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR = 106;

  int get paintType();

  String get uri();

  void setPaint(int paintType, String uri, String rgbColor, String iccColor);

  void setUri(String uri);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGPathSegList get animatedNormalizedPathSegList();

  SVGPathSegList get animatedPathSegList();

  SVGPathSegList get normalizedPathSegList();

  SVGAnimatedNumber get pathLength();

  SVGPathSegList get pathSegList();

  SVGPathSegArcAbs createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag);

  SVGPathSegArcRel createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag);

  SVGPathSegClosePath createSVGPathSegClosePath();

  SVGPathSegCurvetoCubicAbs createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2);

  SVGPathSegCurvetoCubicRel createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2);

  SVGPathSegCurvetoCubicSmoothAbs createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2);

  SVGPathSegCurvetoCubicSmoothRel createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2);

  SVGPathSegCurvetoQuadraticAbs createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1);

  SVGPathSegCurvetoQuadraticRel createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1);

  SVGPathSegCurvetoQuadraticSmoothAbs createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y);

  SVGPathSegCurvetoQuadraticSmoothRel createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y);

  SVGPathSegLinetoAbs createSVGPathSegLinetoAbs(num x, num y);

  SVGPathSegLinetoHorizontalAbs createSVGPathSegLinetoHorizontalAbs(num x);

  SVGPathSegLinetoHorizontalRel createSVGPathSegLinetoHorizontalRel(num x);

  SVGPathSegLinetoRel createSVGPathSegLinetoRel(num x, num y);

  SVGPathSegLinetoVerticalAbs createSVGPathSegLinetoVerticalAbs(num y);

  SVGPathSegLinetoVerticalRel createSVGPathSegLinetoVerticalRel(num y);

  SVGPathSegMovetoAbs createSVGPathSegMovetoAbs(num x, num y);

  SVGPathSegMovetoRel createSVGPathSegMovetoRel(num x, num y);

  int getPathSegAtLength(num distance);

  SVGPoint getPointAtLength(num distance);

  num getTotalLength();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSeg {

  static final int PATHSEG_ARC_ABS = 10;

  static final int PATHSEG_ARC_REL = 11;

  static final int PATHSEG_CLOSEPATH = 1;

  static final int PATHSEG_CURVETO_CUBIC_ABS = 6;

  static final int PATHSEG_CURVETO_CUBIC_REL = 7;

  static final int PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;

  static final int PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;

  static final int PATHSEG_CURVETO_QUADRATIC_ABS = 8;

  static final int PATHSEG_CURVETO_QUADRATIC_REL = 9;

  static final int PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;

  static final int PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;

  static final int PATHSEG_LINETO_ABS = 4;

  static final int PATHSEG_LINETO_HORIZONTAL_ABS = 12;

  static final int PATHSEG_LINETO_HORIZONTAL_REL = 13;

  static final int PATHSEG_LINETO_REL = 5;

  static final int PATHSEG_LINETO_VERTICAL_ABS = 14;

  static final int PATHSEG_LINETO_VERTICAL_REL = 15;

  static final int PATHSEG_MOVETO_ABS = 2;

  static final int PATHSEG_MOVETO_REL = 3;

  static final int PATHSEG_UNKNOWN = 0;

  int get pathSegType();

  String get pathSegTypeAsLetter();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegArcAbs extends SVGPathSeg {

  num get angle();

  void set angle(num value);

  bool get largeArcFlag();

  void set largeArcFlag(bool value);

  num get r1();

  void set r1(num value);

  num get r2();

  void set r2(num value);

  bool get sweepFlag();

  void set sweepFlag(bool value);

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegArcRel extends SVGPathSeg {

  num get angle();

  void set angle(num value);

  bool get largeArcFlag();

  void set largeArcFlag(bool value);

  num get r1();

  void set r1(num value);

  num get r2();

  void set r2(num value);

  bool get sweepFlag();

  void set sweepFlag(bool value);

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegClosePath extends SVGPathSeg {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoCubicAbs extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get x1();

  void set x1(num value);

  num get x2();

  void set x2(num value);

  num get y();

  void set y(num value);

  num get y1();

  void set y1(num value);

  num get y2();

  void set y2(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoCubicRel extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get x1();

  void set x1(num value);

  num get x2();

  void set x2(num value);

  num get y();

  void set y(num value);

  num get y1();

  void set y1(num value);

  num get y2();

  void set y2(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoCubicSmoothAbs extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get x2();

  void set x2(num value);

  num get y();

  void set y(num value);

  num get y2();

  void set y2(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoCubicSmoothRel extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get x2();

  void set x2(num value);

  num get y();

  void set y(num value);

  num get y2();

  void set y2(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoQuadraticAbs extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get x1();

  void set x1(num value);

  num get y();

  void set y(num value);

  num get y1();

  void set y1(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoQuadraticRel extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get x1();

  void set x1(num value);

  num get y();

  void set y(num value);

  num get y1();

  void set y1(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoQuadraticSmoothAbs extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegCurvetoQuadraticSmoothRel extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoAbs extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoHorizontalAbs extends SVGPathSeg {

  num get x();

  void set x(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoHorizontalRel extends SVGPathSeg {

  num get x();

  void set x(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoRel extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoVerticalAbs extends SVGPathSeg {

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegLinetoVerticalRel extends SVGPathSeg {

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegList {

  int get numberOfItems();

  SVGPathSeg appendItem(SVGPathSeg newItem);

  void clear();

  SVGPathSeg getItem(int index);

  SVGPathSeg initialize(SVGPathSeg newItem);

  SVGPathSeg insertItemBefore(SVGPathSeg newItem, int index);

  SVGPathSeg removeItem(int index);

  SVGPathSeg replaceItem(SVGPathSeg newItem, int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegMovetoAbs extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPathSegMovetoRel extends SVGPathSeg {

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPatternElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {

  SVGAnimatedLength get height();

  SVGAnimatedEnumeration get patternContentUnits();

  SVGAnimatedTransformList get patternTransform();

  SVGAnimatedEnumeration get patternUnits();

  SVGAnimatedLength get width();

  SVGAnimatedLength get x();

  SVGAnimatedLength get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPoint {

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);

  SVGPoint matrixTransform(SVGMatrix matrix);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPointList {

  int get numberOfItems();

  SVGPoint appendItem(SVGPoint item);

  void clear();

  SVGPoint getItem(int index);

  SVGPoint initialize(SVGPoint item);

  SVGPoint insertItemBefore(SVGPoint item, int index);

  SVGPoint removeItem(int index);

  SVGPoint replaceItem(SVGPoint item, int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPolygonElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGPointList get animatedPoints();

  SVGPointList get points();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPolylineElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGPointList get animatedPoints();

  SVGPointList get points();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGPreserveAspectRatio {

  static final int SVG_MEETORSLICE_MEET = 1;

  static final int SVG_MEETORSLICE_SLICE = 2;

  static final int SVG_MEETORSLICE_UNKNOWN = 0;

  static final int SVG_PRESERVEASPECTRATIO_NONE = 1;

  static final int SVG_PRESERVEASPECTRATIO_UNKNOWN = 0;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMID = 7;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMID = 6;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMAX = 8;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMID = 5;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMIN = 2;

  int get align();

  void set align(int value);

  int get meetOrSlice();

  void set meetOrSlice(int value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGRadialGradientElement extends SVGGradientElement {

  SVGAnimatedLength get cx();

  SVGAnimatedLength get cy();

  SVGAnimatedLength get fx();

  SVGAnimatedLength get fy();

  SVGAnimatedLength get r();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGRect {

  num get height();

  void set height(num value);

  num get width();

  void set width(num value);

  num get x();

  void set x(num value);

  num get y();

  void set y(num value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGRectElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGAnimatedLength get height();

  SVGAnimatedLength get rx();

  SVGAnimatedLength get ry();

  SVGAnimatedLength get width();

  SVGAnimatedLength get x();

  SVGAnimatedLength get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGRenderingIntent {

  static final int RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = 5;

  static final int RENDERING_INTENT_AUTO = 1;

  static final int RENDERING_INTENT_PERCEPTUAL = 2;

  static final int RENDERING_INTENT_RELATIVE_COLORIMETRIC = 3;

  static final int RENDERING_INTENT_SATURATION = 4;

  static final int RENDERING_INTENT_UNKNOWN = 0;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGScriptElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired {

  String get type();

  void set type(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGSetElement extends SVGAnimationElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGStopElement extends SVGElement, SVGStylable {

  SVGAnimatedNumber get offset();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGStringList {

  int get numberOfItems();

  String appendItem(String item);

  void clear();

  String getItem(int index);

  String initialize(String item);

  String insertItemBefore(String item, int index);

  String removeItem(int index);

  String replaceItem(String item, int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGStylable {

  SVGAnimatedString get className();

  CSSStyleDeclaration get style();

  CSSValue getPresentationAttribute(String name);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGStyleElement extends SVGElement, SVGLangSpace {

  String get media();

  void set media(String value);

  String get title();

  void set title(String value);

  String get type();

  void set type(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGSwitchElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGSymbolElement extends SVGElement, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTRefElement extends SVGTextPositioningElement, SVGURIReference {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTSpanElement extends SVGTextPositioningElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTests {

  SVGStringList get requiredExtensions();

  SVGStringList get requiredFeatures();

  SVGStringList get systemLanguage();

  bool hasExtension(String extension);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTextContentElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  static final int LENGTHADJUST_SPACING = 1;

  static final int LENGTHADJUST_SPACINGANDGLYPHS = 2;

  static final int LENGTHADJUST_UNKNOWN = 0;

  SVGAnimatedEnumeration get lengthAdjust();

  SVGAnimatedLength get textLength();

  int getCharNumAtPosition(SVGPoint point);

  num getComputedTextLength();

  SVGPoint getEndPositionOfChar(int offset);

  SVGRect getExtentOfChar(int offset);

  int getNumberOfChars();

  num getRotationOfChar(int offset);

  SVGPoint getStartPositionOfChar(int offset);

  num getSubStringLength(int offset, int length);

  void selectSubString(int offset, int length);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTextElement extends SVGTextPositioningElement, SVGTransformable {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTextPathElement extends SVGTextContentElement, SVGURIReference {

  static final int TEXTPATH_METHODTYPE_ALIGN = 1;

  static final int TEXTPATH_METHODTYPE_STRETCH = 2;

  static final int TEXTPATH_METHODTYPE_UNKNOWN = 0;

  static final int TEXTPATH_SPACINGTYPE_AUTO = 1;

  static final int TEXTPATH_SPACINGTYPE_EXACT = 2;

  static final int TEXTPATH_SPACINGTYPE_UNKNOWN = 0;

  SVGAnimatedEnumeration get method();

  SVGAnimatedEnumeration get spacing();

  SVGAnimatedLength get startOffset();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTextPositioningElement extends SVGTextContentElement {

  SVGAnimatedLengthList get dx();

  SVGAnimatedLengthList get dy();

  SVGAnimatedNumberList get rotate();

  SVGAnimatedLengthList get x();

  SVGAnimatedLengthList get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTitleElement extends SVGElement, SVGLangSpace, SVGStylable {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTransform {

  static final int SVG_TRANSFORM_MATRIX = 1;

  static final int SVG_TRANSFORM_ROTATE = 4;

  static final int SVG_TRANSFORM_SCALE = 3;

  static final int SVG_TRANSFORM_SKEWX = 5;

  static final int SVG_TRANSFORM_SKEWY = 6;

  static final int SVG_TRANSFORM_TRANSLATE = 2;

  static final int SVG_TRANSFORM_UNKNOWN = 0;

  num get angle();

  SVGMatrix get matrix();

  int get type();

  void setMatrix(SVGMatrix matrix);

  void setRotate(num angle, num cx, num cy);

  void setScale(num sx, num sy);

  void setSkewX(num angle);

  void setSkewY(num angle);

  void setTranslate(num tx, num ty);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTransformList {

  int get numberOfItems();

  SVGTransform appendItem(SVGTransform item);

  void clear();

  SVGTransform consolidate();

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix);

  SVGTransform getItem(int index);

  SVGTransform initialize(SVGTransform item);

  SVGTransform insertItemBefore(SVGTransform item, int index);

  SVGTransform removeItem(int index);

  SVGTransform replaceItem(SVGTransform item, int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGTransformable extends SVGLocatable {

  SVGAnimatedTransformList get transform();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGURIReference {

  SVGAnimatedString get href();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGUnitTypes {

  static final int SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;

  static final int SVG_UNIT_TYPE_UNKNOWN = 0;

  static final int SVG_UNIT_TYPE_USERSPACEONUSE = 1;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGUseElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  SVGElementInstance get animatedInstanceRoot();

  SVGAnimatedLength get height();

  SVGElementInstance get instanceRoot();

  SVGAnimatedLength get width();

  SVGAnimatedLength get x();

  SVGAnimatedLength get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGVKernElement extends SVGElement {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGViewElement extends SVGElement, SVGExternalResourcesRequired, SVGFitToViewBox, SVGZoomAndPan {

  SVGStringList get viewTarget();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGViewSpec extends SVGZoomAndPan, SVGFitToViewBox {

  String get preserveAspectRatioString();

  SVGTransformList get transform();

  String get transformString();

  String get viewBoxString();

  SVGElement get viewTarget();

  String get viewTargetString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGZoomAndPan {

  static final int SVG_ZOOMANDPAN_DISABLE = 1;

  static final int SVG_ZOOMANDPAN_MAGNIFY = 2;

  static final int SVG_ZOOMANDPAN_UNKNOWN = 0;

  int get zoomAndPan();

  void set zoomAndPan(int value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGZoomEvent extends UIEvent {

  num get newScale();

  SVGPoint get newTranslate();

  num get previousScale();

  SVGPoint get previousTranslate();

  SVGRect get zoomRectScreen();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Screen {

  int get availHeight();

  int get availLeft();

  int get availTop();

  int get availWidth();

  int get colorDepth();

  int get height();

  int get pixelDepth();

  int get width();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ScriptElement extends Element {

  bool get async();

  void set async(bool value);

  String get charset();

  void set charset(String value);

  bool get defer();

  void set defer(bool value);

  String get event();

  void set event(String value);

  String get htmlFor();

  void set htmlFor(String value);

  String get src();

  void set src(String value);

  String get text();

  void set text(String value);

  String get type();

  void set type(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SelectElement extends Element {

  bool get autofocus();

  void set autofocus(bool value);

  bool get disabled();

  void set disabled(bool value);

  FormElement get form();

  ElementList get labels();

  int get length();

  void set length(int value);

  bool get multiple();

  void set multiple(bool value);

  String get name();

  void set name(String value);

  ElementList get options();

  bool get required();

  void set required(bool value);

  int get selectedIndex();

  void set selectedIndex(int value);

  int get size();

  void set size(int value);

  String get type();

  String get validationMessage();

  ValidityState get validity();

  String get value();

  void set value(String value);

  bool get willValidate();

  void add(Element element, Element before);

  bool checkValidity();

  Node item(int index);

  Node namedItem(String name);

  void setCustomValidity(String error);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SourceElement extends Element {

  String get media();

  void set media(String value);

  String get src();

  void set src(String value);

  String get type();

  void set type(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpanElement extends Element {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechInputEvent extends Event {

  SpeechInputResultList get results();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechInputResult {

  num get confidence();

  String get utterance();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SpeechInputResultList {

  int get length();

  SpeechInputResult item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Storage {

  int get length();

  void clear();

  String getItem(String key);

  String key(int index);

  void removeItem(String key);

  void setItem(String key, String data);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface StorageInfo {

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback, StorageInfoErrorCallback errorCallback]);

  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback, StorageInfoErrorCallback errorCallback]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoErrorCallback(DOMException error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoQuotaCallback(int grantedQuotaInBytes);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoUsageCallback(int currentUsageInBytes, int currentQuotaInBytes);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StringCallback(String data);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface StyleElement extends Element {

  bool get disabled();

  void set disabled(bool value);

  String get media();

  void set media(String value);

  StyleSheet get sheet();

  String get type();

  void set type(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface StyleMedia {

  String get type();

  bool matchMedium(String mediaquery);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface StyleSheet {

  bool get disabled();

  void set disabled(bool value);

  String get href();

  MediaList get media();

  Node get ownerNode();

  StyleSheet get parentStyleSheet();

  String get title();

  String get type();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface StyleSheetList extends List<StyleSheet> {

  int get length();

  StyleSheet item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableCaptionElement extends Element {

  String get align();

  void set align(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableCellElement extends Element {

  String get abbr();

  void set abbr(String value);

  String get align();

  void set align(String value);

  String get axis();

  void set axis(String value);

  String get bgColor();

  void set bgColor(String value);

  int get cellIndex();

  String get ch();

  void set ch(String value);

  String get chOff();

  void set chOff(String value);

  int get colSpan();

  void set colSpan(int value);

  String get headers();

  void set headers(String value);

  String get height();

  void set height(String value);

  bool get noWrap();

  void set noWrap(bool value);

  int get rowSpan();

  void set rowSpan(int value);

  String get scope();

  void set scope(String value);

  String get vAlign();

  void set vAlign(String value);

  String get width();

  void set width(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableColElement extends Element {

  String get align();

  void set align(String value);

  String get ch();

  void set ch(String value);

  String get chOff();

  void set chOff(String value);

  int get span();

  void set span(int value);

  String get vAlign();

  void set vAlign(String value);

  String get width();

  void set width(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableElement extends Element {

  String get align();

  void set align(String value);

  String get bgColor();

  void set bgColor(String value);

  String get border();

  void set border(String value);

  TableCaptionElement get caption();

  void set caption(TableCaptionElement value);

  String get cellPadding();

  void set cellPadding(String value);

  String get cellSpacing();

  void set cellSpacing(String value);

  String get frame();

  void set frame(String value);

  ElementList get rows();

  String get rules();

  void set rules(String value);

  String get summary();

  void set summary(String value);

  ElementList get tBodies();

  TableSectionElement get tFoot();

  void set tFoot(TableSectionElement value);

  TableSectionElement get tHead();

  void set tHead(TableSectionElement value);

  String get width();

  void set width(String value);

  Element createCaption();

  Element createTFoot();

  Element createTHead();

  void deleteCaption();

  void deleteRow(int index);

  void deleteTFoot();

  void deleteTHead();

  Element insertRow(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableRowElement extends Element {

  String get align();

  void set align(String value);

  String get bgColor();

  void set bgColor(String value);

  ElementList get cells();

  String get ch();

  void set ch(String value);

  String get chOff();

  void set chOff(String value);

  int get rowIndex();

  int get sectionRowIndex();

  String get vAlign();

  void set vAlign(String value);

  void deleteCell(int index);

  Element insertCell(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TableSectionElement extends Element {

  String get align();

  void set align(String value);

  String get ch();

  void set ch(String value);

  String get chOff();

  void set chOff(String value);

  ElementList get rows();

  String get vAlign();

  void set vAlign(String value);

  void deleteRow(int index);

  Element insertRow(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextAreaElement extends Element {

  String get accessKey();

  void set accessKey(String value);

  bool get autofocus();

  void set autofocus(bool value);

  int get cols();

  void set cols(int value);

  String get defaultValue();

  void set defaultValue(String value);

  bool get disabled();

  void set disabled(bool value);

  FormElement get form();

  ElementList get labels();

  int get maxLength();

  void set maxLength(int value);

  String get name();

  void set name(String value);

  String get placeholder();

  void set placeholder(String value);

  bool get readOnly();

  void set readOnly(bool value);

  bool get required();

  void set required(bool value);

  int get rows();

  void set rows(int value);

  String get selectionDirection();

  void set selectionDirection(String value);

  int get selectionEnd();

  void set selectionEnd(int value);

  int get selectionStart();

  void set selectionStart(int value);

  int get textLength();

  String get type();

  String get validationMessage();

  ValidityState get validity();

  String get value();

  void set value(String value);

  bool get willValidate();

  String get wrap();

  void set wrap(String value);

  bool checkValidity();

  void select();

  void setCustomValidity(String error);

  void setSelectionRange(int start, int end, [String direction]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextMetrics {

  num get width();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextTrack {

  static final int Disabled = 0;

  static final int Error = 3;

  static final int Hidden = 1;

  static final int Loaded = 2;

  static final int Loading = 1;

  static final int None = 0;

  static final int Showing = 2;

  TextTrackCueList get activeCues();

  TextTrackCueList get cues();

  String get kind();

  String get label();

  String get language();

  int get mode();

  void set mode(int value);

  int get readyState();

  void addCue(TextTrackCue cue);

  void removeCue(TextTrackCue cue);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextTrackCue {

  String get alignment();

  String get direction();

  num get endTime();

  String get id();

  int get linePosition();

  bool get pauseOnExit();

  int get size();

  bool get snapToLines();

  num get startTime();

  int get textPosition();

  TextTrack get track();

  DocumentFragment getCueAsHTML();

  String getCueAsSource();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TextTrackCueList {

  int get length();

  TextTrackCue getCueById(String id);

  TextTrackCue item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TimeRanges {

  int get length();

  num end(int index);

  num start(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TitleElement extends Element {

  String get text();

  void set text(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Touch {

  int get clientX();

  int get clientY();

  int get identifier();

  int get pageX();

  int get pageY();

  int get screenX();

  int get screenY();

  EventTarget get target();

  num get webkitForce();

  int get webkitRadiusX();

  int get webkitRadiusY();

  num get webkitRotationAngle();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TouchList extends List<Touch> {

  int get length();

  Touch item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface TrackElement extends Element {

  bool get isDefault();

  void set isDefault(bool value);

  String get kind();

  void set kind(String value);

  String get label();

  void set label(String value);

  String get src();

  void set src(String value);

  String get srclang();

  void set srclang(String value);

  TextTrack get track();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface UListElement extends Element {

  bool get compact();

  void set compact(bool value);

  String get type();

  void set type(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Uint16Array extends ArrayBufferView {

  static final int BYTES_PER_ELEMENT = 2;

  int get length();

  Uint16Array subarray(int start, [int end]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Uint32Array extends ArrayBufferView {

  static final int BYTES_PER_ELEMENT = 4;

  int get length();

  Uint32Array subarray(int start, [int end]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface Uint8Array extends ArrayBufferView {

  static final int BYTES_PER_ELEMENT = 1;

  int get length();

  Uint8Array subarray(int start, [int end]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface UnknownElement extends Element {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ValidityState {

  bool get customError();

  bool get patternMismatch();

  bool get rangeOverflow();

  bool get rangeUnderflow();

  bool get stepMismatch();

  bool get tooLong();

  bool get typeMismatch();

  bool get valid();

  bool get valueMissing();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface VideoElement extends MediaElement {

  int get height();

  void set height(int value);

  String get poster();

  void set poster(String value);

  int get videoHeight();

  int get videoWidth();

  int get webkitDecodedFrameCount();

  bool get webkitDisplayingFullscreen();

  int get webkitDroppedFrameCount();

  bool get webkitSupportsFullscreen();

  int get width();

  void set width(int value);

  void webkitEnterFullScreen();

  void webkitEnterFullscreen();

  void webkitExitFullScreen();

  void webkitExitFullscreen();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface VoidCallback {

  void handleEvent();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WaveShaperNode extends AudioNode {

  Float32Array get curve();

  void set curve(Float32Array value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLActiveInfo {

  String get name();

  int get size();

  int get type();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLBuffer {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLContextAttributes {

  bool get alpha();

  void set alpha(bool value);

  bool get antialias();

  void set antialias(bool value);

  bool get depth();

  void set depth(bool value);

  bool get premultipliedAlpha();

  void set premultipliedAlpha(bool value);

  bool get preserveDrawingBuffer();

  void set preserveDrawingBuffer(bool value);

  bool get stencil();

  void set stencil(bool value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLContextEvent extends Event {

  String get statusMessage();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLDebugRendererInfo {

  static final int UNMASKED_RENDERER_WEBGL = 0x9246;

  static final int UNMASKED_VENDOR_WEBGL = 0x9245;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLDebugShaders {

  String getTranslatedShaderSource(WebGLShader shader);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLFramebuffer {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLProgram {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLRenderbuffer {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLRenderingContext extends CanvasRenderingContext {

  static final int ACTIVE_ATTRIBUTES = 0x8B89;

  static final int ACTIVE_TEXTURE = 0x84E0;

  static final int ACTIVE_UNIFORMS = 0x8B86;

  static final int ALIASED_LINE_WIDTH_RANGE = 0x846E;

  static final int ALIASED_POINT_SIZE_RANGE = 0x846D;

  static final int ALPHA = 0x1906;

  static final int ALPHA_BITS = 0x0D55;

  static final int ALWAYS = 0x0207;

  static final int ARRAY_BUFFER = 0x8892;

  static final int ARRAY_BUFFER_BINDING = 0x8894;

  static final int ATTACHED_SHADERS = 0x8B85;

  static final int BACK = 0x0405;

  static final int BLEND = 0x0BE2;

  static final int BLEND_COLOR = 0x8005;

  static final int BLEND_DST_ALPHA = 0x80CA;

  static final int BLEND_DST_RGB = 0x80C8;

  static final int BLEND_EQUATION = 0x8009;

  static final int BLEND_EQUATION_ALPHA = 0x883D;

  static final int BLEND_EQUATION_RGB = 0x8009;

  static final int BLEND_SRC_ALPHA = 0x80CB;

  static final int BLEND_SRC_RGB = 0x80C9;

  static final int BLUE_BITS = 0x0D54;

  static final int BOOL = 0x8B56;

  static final int BOOL_VEC2 = 0x8B57;

  static final int BOOL_VEC3 = 0x8B58;

  static final int BOOL_VEC4 = 0x8B59;

  static final int BROWSER_DEFAULT_WEBGL = 0x9244;

  static final int BUFFER_SIZE = 0x8764;

  static final int BUFFER_USAGE = 0x8765;

  static final int BYTE = 0x1400;

  static final int CCW = 0x0901;

  static final int CLAMP_TO_EDGE = 0x812F;

  static final int COLOR_ATTACHMENT0 = 0x8CE0;

  static final int COLOR_BUFFER_BIT = 0x00004000;

  static final int COLOR_CLEAR_VALUE = 0x0C22;

  static final int COLOR_WRITEMASK = 0x0C23;

  static final int COMPILE_STATUS = 0x8B81;

  static final int COMPRESSED_TEXTURE_FORMATS = 0x86A3;

  static final int CONSTANT_ALPHA = 0x8003;

  static final int CONSTANT_COLOR = 0x8001;

  static final int CONTEXT_LOST_WEBGL = 0x9242;

  static final int CULL_FACE = 0x0B44;

  static final int CULL_FACE_MODE = 0x0B45;

  static final int CURRENT_PROGRAM = 0x8B8D;

  static final int CURRENT_VERTEX_ATTRIB = 0x8626;

  static final int CW = 0x0900;

  static final int DECR = 0x1E03;

  static final int DECR_WRAP = 0x8508;

  static final int DELETE_STATUS = 0x8B80;

  static final int DEPTH_ATTACHMENT = 0x8D00;

  static final int DEPTH_BITS = 0x0D56;

  static final int DEPTH_BUFFER_BIT = 0x00000100;

  static final int DEPTH_CLEAR_VALUE = 0x0B73;

  static final int DEPTH_COMPONENT = 0x1902;

  static final int DEPTH_COMPONENT16 = 0x81A5;

  static final int DEPTH_FUNC = 0x0B74;

  static final int DEPTH_RANGE = 0x0B70;

  static final int DEPTH_STENCIL = 0x84F9;

  static final int DEPTH_STENCIL_ATTACHMENT = 0x821A;

  static final int DEPTH_TEST = 0x0B71;

  static final int DEPTH_WRITEMASK = 0x0B72;

  static final int DITHER = 0x0BD0;

  static final int DONT_CARE = 0x1100;

  static final int DST_ALPHA = 0x0304;

  static final int DST_COLOR = 0x0306;

  static final int DYNAMIC_DRAW = 0x88E8;

  static final int ELEMENT_ARRAY_BUFFER = 0x8893;

  static final int ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;

  static final int EQUAL = 0x0202;

  static final int FASTEST = 0x1101;

  static final int FLOAT = 0x1406;

  static final int FLOAT_MAT2 = 0x8B5A;

  static final int FLOAT_MAT3 = 0x8B5B;

  static final int FLOAT_MAT4 = 0x8B5C;

  static final int FLOAT_VEC2 = 0x8B50;

  static final int FLOAT_VEC3 = 0x8B51;

  static final int FLOAT_VEC4 = 0x8B52;

  static final int FRAGMENT_SHADER = 0x8B30;

  static final int FRAMEBUFFER = 0x8D40;

  static final int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;

  static final int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;

  static final int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;

  static final int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;

  static final int FRAMEBUFFER_BINDING = 0x8CA6;

  static final int FRAMEBUFFER_COMPLETE = 0x8CD5;

  static final int FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;

  static final int FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;

  static final int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;

  static final int FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

  static final int FRONT = 0x0404;

  static final int FRONT_AND_BACK = 0x0408;

  static final int FRONT_FACE = 0x0B46;

  static final int FUNC_ADD = 0x8006;

  static final int FUNC_REVERSE_SUBTRACT = 0x800B;

  static final int FUNC_SUBTRACT = 0x800A;

  static final int GENERATE_MIPMAP_HINT = 0x8192;

  static final int GEQUAL = 0x0206;

  static final int GREATER = 0x0204;

  static final int GREEN_BITS = 0x0D53;

  static final int HIGH_FLOAT = 0x8DF2;

  static final int HIGH_INT = 0x8DF5;

  static final int INCR = 0x1E02;

  static final int INCR_WRAP = 0x8507;

  static final int INT = 0x1404;

  static final int INT_VEC2 = 0x8B53;

  static final int INT_VEC3 = 0x8B54;

  static final int INT_VEC4 = 0x8B55;

  static final int INVALID_ENUM = 0x0500;

  static final int INVALID_FRAMEBUFFER_OPERATION = 0x0506;

  static final int INVALID_OPERATION = 0x0502;

  static final int INVALID_VALUE = 0x0501;

  static final int INVERT = 0x150A;

  static final int KEEP = 0x1E00;

  static final int LEQUAL = 0x0203;

  static final int LESS = 0x0201;

  static final int LINEAR = 0x2601;

  static final int LINEAR_MIPMAP_LINEAR = 0x2703;

  static final int LINEAR_MIPMAP_NEAREST = 0x2701;

  static final int LINES = 0x0001;

  static final int LINE_LOOP = 0x0002;

  static final int LINE_STRIP = 0x0003;

  static final int LINE_WIDTH = 0x0B21;

  static final int LINK_STATUS = 0x8B82;

  static final int LOW_FLOAT = 0x8DF0;

  static final int LOW_INT = 0x8DF3;

  static final int LUMINANCE = 0x1909;

  static final int LUMINANCE_ALPHA = 0x190A;

  static final int MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;

  static final int MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;

  static final int MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;

  static final int MAX_RENDERBUFFER_SIZE = 0x84E8;

  static final int MAX_TEXTURE_IMAGE_UNITS = 0x8872;

  static final int MAX_TEXTURE_SIZE = 0x0D33;

  static final int MAX_VARYING_VECTORS = 0x8DFC;

  static final int MAX_VERTEX_ATTRIBS = 0x8869;

  static final int MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;

  static final int MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;

  static final int MAX_VIEWPORT_DIMS = 0x0D3A;

  static final int MEDIUM_FLOAT = 0x8DF1;

  static final int MEDIUM_INT = 0x8DF4;

  static final int MIRRORED_REPEAT = 0x8370;

  static final int NEAREST = 0x2600;

  static final int NEAREST_MIPMAP_LINEAR = 0x2702;

  static final int NEAREST_MIPMAP_NEAREST = 0x2700;

  static final int NEVER = 0x0200;

  static final int NICEST = 0x1102;

  static final int NONE = 0;

  static final int NOTEQUAL = 0x0205;

  static final int NO_ERROR = 0;

  static final int NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;

  static final int ONE = 1;

  static final int ONE_MINUS_CONSTANT_ALPHA = 0x8004;

  static final int ONE_MINUS_CONSTANT_COLOR = 0x8002;

  static final int ONE_MINUS_DST_ALPHA = 0x0305;

  static final int ONE_MINUS_DST_COLOR = 0x0307;

  static final int ONE_MINUS_SRC_ALPHA = 0x0303;

  static final int ONE_MINUS_SRC_COLOR = 0x0301;

  static final int OUT_OF_MEMORY = 0x0505;

  static final int PACK_ALIGNMENT = 0x0D05;

  static final int POINTS = 0x0000;

  static final int POLYGON_OFFSET_FACTOR = 0x8038;

  static final int POLYGON_OFFSET_FILL = 0x8037;

  static final int POLYGON_OFFSET_UNITS = 0x2A00;

  static final int RED_BITS = 0x0D52;

  static final int RENDERBUFFER = 0x8D41;

  static final int RENDERBUFFER_ALPHA_SIZE = 0x8D53;

  static final int RENDERBUFFER_BINDING = 0x8CA7;

  static final int RENDERBUFFER_BLUE_SIZE = 0x8D52;

  static final int RENDERBUFFER_DEPTH_SIZE = 0x8D54;

  static final int RENDERBUFFER_GREEN_SIZE = 0x8D51;

  static final int RENDERBUFFER_HEIGHT = 0x8D43;

  static final int RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;

  static final int RENDERBUFFER_RED_SIZE = 0x8D50;

  static final int RENDERBUFFER_STENCIL_SIZE = 0x8D55;

  static final int RENDERBUFFER_WIDTH = 0x8D42;

  static final int RENDERER = 0x1F01;

  static final int REPEAT = 0x2901;

  static final int REPLACE = 0x1E01;

  static final int RGB = 0x1907;

  static final int RGB565 = 0x8D62;

  static final int RGB5_A1 = 0x8057;

  static final int RGBA = 0x1908;

  static final int RGBA4 = 0x8056;

  static final int SAMPLER_2D = 0x8B5E;

  static final int SAMPLER_CUBE = 0x8B60;

  static final int SAMPLES = 0x80A9;

  static final int SAMPLE_ALPHA_TO_COVERAGE = 0x809E;

  static final int SAMPLE_BUFFERS = 0x80A8;

  static final int SAMPLE_COVERAGE = 0x80A0;

  static final int SAMPLE_COVERAGE_INVERT = 0x80AB;

  static final int SAMPLE_COVERAGE_VALUE = 0x80AA;

  static final int SCISSOR_BOX = 0x0C10;

  static final int SCISSOR_TEST = 0x0C11;

  static final int SHADER_COMPILER = 0x8DFA;

  static final int SHADER_TYPE = 0x8B4F;

  static final int SHADING_LANGUAGE_VERSION = 0x8B8C;

  static final int SHORT = 0x1402;

  static final int SRC_ALPHA = 0x0302;

  static final int SRC_ALPHA_SATURATE = 0x0308;

  static final int SRC_COLOR = 0x0300;

  static final int STATIC_DRAW = 0x88E4;

  static final int STENCIL_ATTACHMENT = 0x8D20;

  static final int STENCIL_BACK_FAIL = 0x8801;

  static final int STENCIL_BACK_FUNC = 0x8800;

  static final int STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;

  static final int STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;

  static final int STENCIL_BACK_REF = 0x8CA3;

  static final int STENCIL_BACK_VALUE_MASK = 0x8CA4;

  static final int STENCIL_BACK_WRITEMASK = 0x8CA5;

  static final int STENCIL_BITS = 0x0D57;

  static final int STENCIL_BUFFER_BIT = 0x00000400;

  static final int STENCIL_CLEAR_VALUE = 0x0B91;

  static final int STENCIL_FAIL = 0x0B94;

  static final int STENCIL_FUNC = 0x0B92;

  static final int STENCIL_INDEX = 0x1901;

  static final int STENCIL_INDEX8 = 0x8D48;

  static final int STENCIL_PASS_DEPTH_FAIL = 0x0B95;

  static final int STENCIL_PASS_DEPTH_PASS = 0x0B96;

  static final int STENCIL_REF = 0x0B97;

  static final int STENCIL_TEST = 0x0B90;

  static final int STENCIL_VALUE_MASK = 0x0B93;

  static final int STENCIL_WRITEMASK = 0x0B98;

  static final int STREAM_DRAW = 0x88E0;

  static final int SUBPIXEL_BITS = 0x0D50;

  static final int TEXTURE = 0x1702;

  static final int TEXTURE0 = 0x84C0;

  static final int TEXTURE1 = 0x84C1;

  static final int TEXTURE10 = 0x84CA;

  static final int TEXTURE11 = 0x84CB;

  static final int TEXTURE12 = 0x84CC;

  static final int TEXTURE13 = 0x84CD;

  static final int TEXTURE14 = 0x84CE;

  static final int TEXTURE15 = 0x84CF;

  static final int TEXTURE16 = 0x84D0;

  static final int TEXTURE17 = 0x84D1;

  static final int TEXTURE18 = 0x84D2;

  static final int TEXTURE19 = 0x84D3;

  static final int TEXTURE2 = 0x84C2;

  static final int TEXTURE20 = 0x84D4;

  static final int TEXTURE21 = 0x84D5;

  static final int TEXTURE22 = 0x84D6;

  static final int TEXTURE23 = 0x84D7;

  static final int TEXTURE24 = 0x84D8;

  static final int TEXTURE25 = 0x84D9;

  static final int TEXTURE26 = 0x84DA;

  static final int TEXTURE27 = 0x84DB;

  static final int TEXTURE28 = 0x84DC;

  static final int TEXTURE29 = 0x84DD;

  static final int TEXTURE3 = 0x84C3;

  static final int TEXTURE30 = 0x84DE;

  static final int TEXTURE31 = 0x84DF;

  static final int TEXTURE4 = 0x84C4;

  static final int TEXTURE5 = 0x84C5;

  static final int TEXTURE6 = 0x84C6;

  static final int TEXTURE7 = 0x84C7;

  static final int TEXTURE8 = 0x84C8;

  static final int TEXTURE9 = 0x84C9;

  static final int TEXTURE_2D = 0x0DE1;

  static final int TEXTURE_BINDING_2D = 0x8069;

  static final int TEXTURE_BINDING_CUBE_MAP = 0x8514;

  static final int TEXTURE_CUBE_MAP = 0x8513;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;

  static final int TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;

  static final int TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;

  static final int TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;

  static final int TEXTURE_MAG_FILTER = 0x2800;

  static final int TEXTURE_MIN_FILTER = 0x2801;

  static final int TEXTURE_WRAP_S = 0x2802;

  static final int TEXTURE_WRAP_T = 0x2803;

  static final int TRIANGLES = 0x0004;

  static final int TRIANGLE_FAN = 0x0006;

  static final int TRIANGLE_STRIP = 0x0005;

  static final int UNPACK_ALIGNMENT = 0x0CF5;

  static final int UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;

  static final int UNPACK_FLIP_Y_WEBGL = 0x9240;

  static final int UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;

  static final int UNSIGNED_BYTE = 0x1401;

  static final int UNSIGNED_INT = 0x1405;

  static final int UNSIGNED_SHORT = 0x1403;

  static final int UNSIGNED_SHORT_4_4_4_4 = 0x8033;

  static final int UNSIGNED_SHORT_5_5_5_1 = 0x8034;

  static final int UNSIGNED_SHORT_5_6_5 = 0x8363;

  static final int VALIDATE_STATUS = 0x8B83;

  static final int VENDOR = 0x1F00;

  static final int VERSION = 0x1F02;

  static final int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;

  static final int VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;

  static final int VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;

  static final int VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;

  static final int VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;

  static final int VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;

  static final int VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;

  static final int VERTEX_SHADER = 0x8B31;

  static final int VIEWPORT = 0x0BA2;

  static final int ZERO = 0;

  int get drawingBufferHeight();

  int get drawingBufferWidth();

  void activeTexture(int texture);

  void attachShader(WebGLProgram program, WebGLShader shader);

  void bindAttribLocation(WebGLProgram program, int index, String name);

  void bindBuffer(int target, WebGLBuffer buffer);

  void bindFramebuffer(int target, WebGLFramebuffer framebuffer);

  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer);

  void bindTexture(int target, WebGLTexture texture);

  void blendColor(num red, num green, num blue, num alpha);

  void blendEquation(int mode);

  void blendEquationSeparate(int modeRGB, int modeAlpha);

  void blendFunc(int sfactor, int dfactor);

  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha);

  void bufferData(int target, var data_OR_size, int usage);

  void bufferSubData(int target, int offset, var data);

  int checkFramebufferStatus(int target);

  void clear(int mask);

  void clearColor(num red, num green, num blue, num alpha);

  void clearDepth(num depth);

  void clearStencil(int s);

  void colorMask(bool red, bool green, bool blue, bool alpha);

  void compileShader(WebGLShader shader);

  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border);

  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height);

  WebGLBuffer createBuffer();

  WebGLFramebuffer createFramebuffer();

  WebGLProgram createProgram();

  WebGLRenderbuffer createRenderbuffer();

  WebGLShader createShader(int type);

  WebGLTexture createTexture();

  void cullFace(int mode);

  void deleteBuffer(WebGLBuffer buffer);

  void deleteFramebuffer(WebGLFramebuffer framebuffer);

  void deleteProgram(WebGLProgram program);

  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer);

  void deleteShader(WebGLShader shader);

  void deleteTexture(WebGLTexture texture);

  void depthFunc(int func);

  void depthMask(bool flag);

  void depthRange(num zNear, num zFar);

  void detachShader(WebGLProgram program, WebGLShader shader);

  void disable(int cap);

  void disableVertexAttribArray(int index);

  void drawArrays(int mode, int first, int count);

  void drawElements(int mode, int count, int type, int offset);

  void enable(int cap);

  void enableVertexAttribArray(int index);

  void finish();

  void flush();

  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer);

  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level);

  void frontFace(int mode);

  void generateMipmap(int target);

  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index);

  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index);

  void getAttachedShaders(WebGLProgram program);

  int getAttribLocation(WebGLProgram program, String name);

  Object getBufferParameter(int target, int pname);

  WebGLContextAttributes getContextAttributes();

  int getError();

  Object getExtension(String name);

  Object getFramebufferAttachmentParameter(int target, int attachment, int pname);

  Object getParameter(int pname);

  String getProgramInfoLog(WebGLProgram program);

  Object getProgramParameter(WebGLProgram program, int pname);

  Object getRenderbufferParameter(int target, int pname);

  String getShaderInfoLog(WebGLShader shader);

  Object getShaderParameter(WebGLShader shader, int pname);

  String getShaderSource(WebGLShader shader);

  Object getTexParameter(int target, int pname);

  Object getUniform(WebGLProgram program, WebGLUniformLocation location);

  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name);

  Object getVertexAttrib(int index, int pname);

  int getVertexAttribOffset(int index, int pname);

  void hint(int target, int mode);

  bool isBuffer(WebGLBuffer buffer);

  bool isContextLost();

  bool isEnabled(int cap);

  bool isFramebuffer(WebGLFramebuffer framebuffer);

  bool isProgram(WebGLProgram program);

  bool isRenderbuffer(WebGLRenderbuffer renderbuffer);

  bool isShader(WebGLShader shader);

  bool isTexture(WebGLTexture texture);

  void lineWidth(num width);

  void linkProgram(WebGLProgram program);

  void pixelStorei(int pname, int param);

  void polygonOffset(num factor, num units);

  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels);

  void releaseShaderCompiler();

  void renderbufferStorage(int target, int internalformat, int width, int height);

  void sampleCoverage(num value, bool invert);

  void scissor(int x, int y, int width, int height);

  void shaderSource(WebGLShader shader, String string);

  void stencilFunc(int func, int ref, int mask);

  void stencilFuncSeparate(int face, int func, int ref, int mask);

  void stencilMask(int mask);

  void stencilMaskSeparate(int face, int mask);

  void stencilOp(int fail, int zfail, int zpass);

  void stencilOpSeparate(int face, int fail, int zfail, int zpass);

  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, var border_OR_canvas_OR_image_OR_pixels, [int format, int type, ArrayBufferView pixels]);

  void texParameterf(int target, int pname, num param);

  void texParameteri(int target, int pname, int param);

  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, var canvas_OR_format_OR_image_OR_pixels, [int type, ArrayBufferView pixels]);

  void uniform1f(WebGLUniformLocation location, num x);

  void uniform1fv(WebGLUniformLocation location, Float32Array v);

  void uniform1i(WebGLUniformLocation location, int x);

  void uniform1iv(WebGLUniformLocation location, Int32Array v);

  void uniform2f(WebGLUniformLocation location, num x, num y);

  void uniform2fv(WebGLUniformLocation location, Float32Array v);

  void uniform2i(WebGLUniformLocation location, int x, int y);

  void uniform2iv(WebGLUniformLocation location, Int32Array v);

  void uniform3f(WebGLUniformLocation location, num x, num y, num z);

  void uniform3fv(WebGLUniformLocation location, Float32Array v);

  void uniform3i(WebGLUniformLocation location, int x, int y, int z);

  void uniform3iv(WebGLUniformLocation location, Int32Array v);

  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w);

  void uniform4fv(WebGLUniformLocation location, Float32Array v);

  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w);

  void uniform4iv(WebGLUniformLocation location, Int32Array v);

  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  void useProgram(WebGLProgram program);

  void validateProgram(WebGLProgram program);

  void vertexAttrib1f(int indx, num x);

  void vertexAttrib1fv(int indx, Float32Array values);

  void vertexAttrib2f(int indx, num x, num y);

  void vertexAttrib2fv(int indx, Float32Array values);

  void vertexAttrib3f(int indx, num x, num y, num z);

  void vertexAttrib3fv(int indx, Float32Array values);

  void vertexAttrib4f(int indx, num x, num y, num z, num w);

  void vertexAttrib4fv(int indx, Float32Array values);

  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset);

  void viewport(int x, int y, int width, int height);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLShader {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLTexture {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLUniformLocation {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebGLVertexArrayObjectOES {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebKitCSSFilterValue extends CSSValueList {

  static final int CSS_FILTER_BLUR = 9;

  static final int CSS_FILTER_DROP_SHADOW = 11;

  static final int CSS_FILTER_GAMMA = 8;

  static final int CSS_FILTER_GRAYSCALE = 2;

  static final int CSS_FILTER_HUE_ROTATE = 5;

  static final int CSS_FILTER_INVERT = 6;

  static final int CSS_FILTER_OPACITY = 7;

  static final int CSS_FILTER_REFERENCE = 1;

  static final int CSS_FILTER_SATURATE = 4;

  static final int CSS_FILTER_SEPIA = 3;

  static final int CSS_FILTER_SHARPEN = 10;

  int get operationType();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface WebKitMutationObserver {

  void disconnect();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface XMLHttpRequestException {

  static final int ABORT_ERR = 102;

  static final int NETWORK_ERR = 101;

  int get code();

  String get message();

  String get name();

  String toString();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface AbstractWorkerEvents extends Events {
  EventListenerList get error();
}

interface AbstractWorker extends EventTarget {
  AbstractWorkerEvents get on();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface AnimationEvent extends Event default AnimationEventWrappingImplementation {

  AnimationEvent(String type, String propertyName, double elapsedTime,
      [bool canBubble, bool cancelable]);

  String get animationName();

  num get elapsedTime();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface BeforeLoadEvent extends Event default BeforeLoadEventWrappingImplementation {

  BeforeLoadEvent(String type, String url, [bool canBubble, bool cancelable]);

  String get url();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface BodyElementEvents extends ElementEvents {
  EventListenerList get beforeUnload();
  EventListenerList get hashChange();
  EventListenerList get message();
  EventListenerList get offline();
  EventListenerList get online();
  EventListenerList get orientationChange();
  EventListenerList get popState();
  EventListenerList get resize();
  EventListenerList get storage();
  EventListenerList get unLoad();
}

interface BodyElement extends Element {
  BodyElementEvents get on();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface CloseEvent extends Event default CloseEventWrappingImplementation {

  CloseEvent(String type, int code, String reason,
      [bool canBubble, bool cancelable, bool wasClean]);

  int get code();

  String get reason();

  bool get wasClean();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface CompositionEvent extends UIEvent default CompositionEventWrappingImplementation {

  CompositionEvent(String type, Window view, String data, [bool canBubble,
      bool cancelable]);

  String get data();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit.
// This file was generated by html/scripts/css_code_generator.py

// Source of CSS properties:
//   Source/WebCore/css/CSSPropertyNames.in

// TODO(jacobr): add versions that take numeric values in px, miliseconds, etc.

interface CSSStyleDeclaration default CSSStyleDeclarationWrappingImplementation {

  CSSStyleDeclaration();

  CSSStyleDeclaration.css(String css);

  String get cssText();

  void set cssText(String value);

  int get length();

  CSSRule get parentRule();

  CSSValue getPropertyCSSValue(String propertyName);

  String getPropertyPriority(String propertyName);

  String getPropertyShorthand(String propertyName);

  String getPropertyValue(String propertyName);

  bool isPropertyImplicit(String propertyName);

  String item(int index);

  String removeProperty(String propertyName);

  void setProperty(String propertyName, String value, [String priority]);

  /** Gets the value of "animation" */
  String get animation();

  /** Sets the value of "animation" */
  void set animation(String value);

  /** Gets the value of "animation-delay" */
  String get animationDelay();

  /** Sets the value of "animation-delay" */
  void set animationDelay(String value);

  /** Gets the value of "animation-direction" */
  String get animationDirection();

  /** Sets the value of "animation-direction" */
  void set animationDirection(String value);

  /** Gets the value of "animation-duration" */
  String get animationDuration();

  /** Sets the value of "animation-duration" */
  void set animationDuration(String value);

  /** Gets the value of "animation-fill-mode" */
  String get animationFillMode();

  /** Sets the value of "animation-fill-mode" */
  void set animationFillMode(String value);

  /** Gets the value of "animation-iteration-count" */
  String get animationIterationCount();

  /** Sets the value of "animation-iteration-count" */
  void set animationIterationCount(String value);

  /** Gets the value of "animation-name" */
  String get animationName();

  /** Sets the value of "animation-name" */
  void set animationName(String value);

  /** Gets the value of "animation-play-state" */
  String get animationPlayState();

  /** Sets the value of "animation-play-state" */
  void set animationPlayState(String value);

  /** Gets the value of "animation-timing-function" */
  String get animationTimingFunction();

  /** Sets the value of "animation-timing-function" */
  void set animationTimingFunction(String value);

  /** Gets the value of "appearance" */
  String get appearance();

  /** Sets the value of "appearance" */
  void set appearance(String value);

  /** Gets the value of "backface-visibility" */
  String get backfaceVisibility();

  /** Sets the value of "backface-visibility" */
  void set backfaceVisibility(String value);

  /** Gets the value of "background" */
  String get background();

  /** Sets the value of "background" */
  void set background(String value);

  /** Gets the value of "background-attachment" */
  String get backgroundAttachment();

  /** Sets the value of "background-attachment" */
  void set backgroundAttachment(String value);

  /** Gets the value of "background-clip" */
  String get backgroundClip();

  /** Sets the value of "background-clip" */
  void set backgroundClip(String value);

  /** Gets the value of "background-color" */
  String get backgroundColor();

  /** Sets the value of "background-color" */
  void set backgroundColor(String value);

  /** Gets the value of "background-composite" */
  String get backgroundComposite();

  /** Sets the value of "background-composite" */
  void set backgroundComposite(String value);

  /** Gets the value of "background-image" */
  String get backgroundImage();

  /** Sets the value of "background-image" */
  void set backgroundImage(String value);

  /** Gets the value of "background-origin" */
  String get backgroundOrigin();

  /** Sets the value of "background-origin" */
  void set backgroundOrigin(String value);

  /** Gets the value of "background-position" */
  String get backgroundPosition();

  /** Sets the value of "background-position" */
  void set backgroundPosition(String value);

  /** Gets the value of "background-position-x" */
  String get backgroundPositionX();

  /** Sets the value of "background-position-x" */
  void set backgroundPositionX(String value);

  /** Gets the value of "background-position-y" */
  String get backgroundPositionY();

  /** Sets the value of "background-position-y" */
  void set backgroundPositionY(String value);

  /** Gets the value of "background-repeat" */
  String get backgroundRepeat();

  /** Sets the value of "background-repeat" */
  void set backgroundRepeat(String value);

  /** Gets the value of "background-repeat-x" */
  String get backgroundRepeatX();

  /** Sets the value of "background-repeat-x" */
  void set backgroundRepeatX(String value);

  /** Gets the value of "background-repeat-y" */
  String get backgroundRepeatY();

  /** Sets the value of "background-repeat-y" */
  void set backgroundRepeatY(String value);

  /** Gets the value of "background-size" */
  String get backgroundSize();

  /** Sets the value of "background-size" */
  void set backgroundSize(String value);

  /** Gets the value of "border" */
  String get border();

  /** Sets the value of "border" */
  void set border(String value);

  /** Gets the value of "border-after" */
  String get borderAfter();

  /** Sets the value of "border-after" */
  void set borderAfter(String value);

  /** Gets the value of "border-after-color" */
  String get borderAfterColor();

  /** Sets the value of "border-after-color" */
  void set borderAfterColor(String value);

  /** Gets the value of "border-after-style" */
  String get borderAfterStyle();

  /** Sets the value of "border-after-style" */
  void set borderAfterStyle(String value);

  /** Gets the value of "border-after-width" */
  String get borderAfterWidth();

  /** Sets the value of "border-after-width" */
  void set borderAfterWidth(String value);

  /** Gets the value of "border-before" */
  String get borderBefore();

  /** Sets the value of "border-before" */
  void set borderBefore(String value);

  /** Gets the value of "border-before-color" */
  String get borderBeforeColor();

  /** Sets the value of "border-before-color" */
  void set borderBeforeColor(String value);

  /** Gets the value of "border-before-style" */
  String get borderBeforeStyle();

  /** Sets the value of "border-before-style" */
  void set borderBeforeStyle(String value);

  /** Gets the value of "border-before-width" */
  String get borderBeforeWidth();

  /** Sets the value of "border-before-width" */
  void set borderBeforeWidth(String value);

  /** Gets the value of "border-bottom" */
  String get borderBottom();

  /** Sets the value of "border-bottom" */
  void set borderBottom(String value);

  /** Gets the value of "border-bottom-color" */
  String get borderBottomColor();

  /** Sets the value of "border-bottom-color" */
  void set borderBottomColor(String value);

  /** Gets the value of "border-bottom-left-radius" */
  String get borderBottomLeftRadius();

  /** Sets the value of "border-bottom-left-radius" */
  void set borderBottomLeftRadius(String value);

  /** Gets the value of "border-bottom-right-radius" */
  String get borderBottomRightRadius();

  /** Sets the value of "border-bottom-right-radius" */
  void set borderBottomRightRadius(String value);

  /** Gets the value of "border-bottom-style" */
  String get borderBottomStyle();

  /** Sets the value of "border-bottom-style" */
  void set borderBottomStyle(String value);

  /** Gets the value of "border-bottom-width" */
  String get borderBottomWidth();

  /** Sets the value of "border-bottom-width" */
  void set borderBottomWidth(String value);

  /** Gets the value of "border-collapse" */
  String get borderCollapse();

  /** Sets the value of "border-collapse" */
  void set borderCollapse(String value);

  /** Gets the value of "border-color" */
  String get borderColor();

  /** Sets the value of "border-color" */
  void set borderColor(String value);

  /** Gets the value of "border-end" */
  String get borderEnd();

  /** Sets the value of "border-end" */
  void set borderEnd(String value);

  /** Gets the value of "border-end-color" */
  String get borderEndColor();

  /** Sets the value of "border-end-color" */
  void set borderEndColor(String value);

  /** Gets the value of "border-end-style" */
  String get borderEndStyle();

  /** Sets the value of "border-end-style" */
  void set borderEndStyle(String value);

  /** Gets the value of "border-end-width" */
  String get borderEndWidth();

  /** Sets the value of "border-end-width" */
  void set borderEndWidth(String value);

  /** Gets the value of "border-fit" */
  String get borderFit();

  /** Sets the value of "border-fit" */
  void set borderFit(String value);

  /** Gets the value of "border-horizontal-spacing" */
  String get borderHorizontalSpacing();

  /** Sets the value of "border-horizontal-spacing" */
  void set borderHorizontalSpacing(String value);

  /** Gets the value of "border-image" */
  String get borderImage();

  /** Sets the value of "border-image" */
  void set borderImage(String value);

  /** Gets the value of "border-image-outset" */
  String get borderImageOutset();

  /** Sets the value of "border-image-outset" */
  void set borderImageOutset(String value);

  /** Gets the value of "border-image-repeat" */
  String get borderImageRepeat();

  /** Sets the value of "border-image-repeat" */
  void set borderImageRepeat(String value);

  /** Gets the value of "border-image-slice" */
  String get borderImageSlice();

  /** Sets the value of "border-image-slice" */
  void set borderImageSlice(String value);

  /** Gets the value of "border-image-source" */
  String get borderImageSource();

  /** Sets the value of "border-image-source" */
  void set borderImageSource(String value);

  /** Gets the value of "border-image-width" */
  String get borderImageWidth();

  /** Sets the value of "border-image-width" */
  void set borderImageWidth(String value);

  /** Gets the value of "border-left" */
  String get borderLeft();

  /** Sets the value of "border-left" */
  void set borderLeft(String value);

  /** Gets the value of "border-left-color" */
  String get borderLeftColor();

  /** Sets the value of "border-left-color" */
  void set borderLeftColor(String value);

  /** Gets the value of "border-left-style" */
  String get borderLeftStyle();

  /** Sets the value of "border-left-style" */
  void set borderLeftStyle(String value);

  /** Gets the value of "border-left-width" */
  String get borderLeftWidth();

  /** Sets the value of "border-left-width" */
  void set borderLeftWidth(String value);

  /** Gets the value of "border-radius" */
  String get borderRadius();

  /** Sets the value of "border-radius" */
  void set borderRadius(String value);

  /** Gets the value of "border-right" */
  String get borderRight();

  /** Sets the value of "border-right" */
  void set borderRight(String value);

  /** Gets the value of "border-right-color" */
  String get borderRightColor();

  /** Sets the value of "border-right-color" */
  void set borderRightColor(String value);

  /** Gets the value of "border-right-style" */
  String get borderRightStyle();

  /** Sets the value of "border-right-style" */
  void set borderRightStyle(String value);

  /** Gets the value of "border-right-width" */
  String get borderRightWidth();

  /** Sets the value of "border-right-width" */
  void set borderRightWidth(String value);

  /** Gets the value of "border-spacing" */
  String get borderSpacing();

  /** Sets the value of "border-spacing" */
  void set borderSpacing(String value);

  /** Gets the value of "border-start" */
  String get borderStart();

  /** Sets the value of "border-start" */
  void set borderStart(String value);

  /** Gets the value of "border-start-color" */
  String get borderStartColor();

  /** Sets the value of "border-start-color" */
  void set borderStartColor(String value);

  /** Gets the value of "border-start-style" */
  String get borderStartStyle();

  /** Sets the value of "border-start-style" */
  void set borderStartStyle(String value);

  /** Gets the value of "border-start-width" */
  String get borderStartWidth();

  /** Sets the value of "border-start-width" */
  void set borderStartWidth(String value);

  /** Gets the value of "border-style" */
  String get borderStyle();

  /** Sets the value of "border-style" */
  void set borderStyle(String value);

  /** Gets the value of "border-top" */
  String get borderTop();

  /** Sets the value of "border-top" */
  void set borderTop(String value);

  /** Gets the value of "border-top-color" */
  String get borderTopColor();

  /** Sets the value of "border-top-color" */
  void set borderTopColor(String value);

  /** Gets the value of "border-top-left-radius" */
  String get borderTopLeftRadius();

  /** Sets the value of "border-top-left-radius" */
  void set borderTopLeftRadius(String value);

  /** Gets the value of "border-top-right-radius" */
  String get borderTopRightRadius();

  /** Sets the value of "border-top-right-radius" */
  void set borderTopRightRadius(String value);

  /** Gets the value of "border-top-style" */
  String get borderTopStyle();

  /** Sets the value of "border-top-style" */
  void set borderTopStyle(String value);

  /** Gets the value of "border-top-width" */
  String get borderTopWidth();

  /** Sets the value of "border-top-width" */
  void set borderTopWidth(String value);

  /** Gets the value of "border-vertical-spacing" */
  String get borderVerticalSpacing();

  /** Sets the value of "border-vertical-spacing" */
  void set borderVerticalSpacing(String value);

  /** Gets the value of "border-width" */
  String get borderWidth();

  /** Sets the value of "border-width" */
  void set borderWidth(String value);

  /** Gets the value of "bottom" */
  String get bottom();

  /** Sets the value of "bottom" */
  void set bottom(String value);

  /** Gets the value of "box-align" */
  String get boxAlign();

  /** Sets the value of "box-align" */
  void set boxAlign(String value);

  /** Gets the value of "box-direction" */
  String get boxDirection();

  /** Sets the value of "box-direction" */
  void set boxDirection(String value);

  /** Gets the value of "box-flex" */
  String get boxFlex();

  /** Sets the value of "box-flex" */
  void set boxFlex(String value);

  /** Gets the value of "box-flex-group" */
  String get boxFlexGroup();

  /** Sets the value of "box-flex-group" */
  void set boxFlexGroup(String value);

  /** Gets the value of "box-lines" */
  String get boxLines();

  /** Sets the value of "box-lines" */
  void set boxLines(String value);

  /** Gets the value of "box-ordinal-group" */
  String get boxOrdinalGroup();

  /** Sets the value of "box-ordinal-group" */
  void set boxOrdinalGroup(String value);

  /** Gets the value of "box-orient" */
  String get boxOrient();

  /** Sets the value of "box-orient" */
  void set boxOrient(String value);

  /** Gets the value of "box-pack" */
  String get boxPack();

  /** Sets the value of "box-pack" */
  void set boxPack(String value);

  /** Gets the value of "box-reflect" */
  String get boxReflect();

  /** Sets the value of "box-reflect" */
  void set boxReflect(String value);

  /** Gets the value of "box-shadow" */
  String get boxShadow();

  /** Sets the value of "box-shadow" */
  void set boxShadow(String value);

  /** Gets the value of "box-sizing" */
  String get boxSizing();

  /** Sets the value of "box-sizing" */
  void set boxSizing(String value);

  /** Gets the value of "caption-side" */
  String get captionSide();

  /** Sets the value of "caption-side" */
  void set captionSide(String value);

  /** Gets the value of "clear" */
  String get clear();

  /** Sets the value of "clear" */
  void set clear(String value);

  /** Gets the value of "clip" */
  String get clip();

  /** Sets the value of "clip" */
  void set clip(String value);

  /** Gets the value of "color" */
  String get color();

  /** Sets the value of "color" */
  void set color(String value);

  /** Gets the value of "color-correction" */
  String get colorCorrection();

  /** Sets the value of "color-correction" */
  void set colorCorrection(String value);

  /** Gets the value of "column-break-after" */
  String get columnBreakAfter();

  /** Sets the value of "column-break-after" */
  void set columnBreakAfter(String value);

  /** Gets the value of "column-break-before" */
  String get columnBreakBefore();

  /** Sets the value of "column-break-before" */
  void set columnBreakBefore(String value);

  /** Gets the value of "column-break-inside" */
  String get columnBreakInside();

  /** Sets the value of "column-break-inside" */
  void set columnBreakInside(String value);

  /** Gets the value of "column-count" */
  String get columnCount();

  /** Sets the value of "column-count" */
  void set columnCount(String value);

  /** Gets the value of "column-gap" */
  String get columnGap();

  /** Sets the value of "column-gap" */
  void set columnGap(String value);

  /** Gets the value of "column-rule" */
  String get columnRule();

  /** Sets the value of "column-rule" */
  void set columnRule(String value);

  /** Gets the value of "column-rule-color" */
  String get columnRuleColor();

  /** Sets the value of "column-rule-color" */
  void set columnRuleColor(String value);

  /** Gets the value of "column-rule-style" */
  String get columnRuleStyle();

  /** Sets the value of "column-rule-style" */
  void set columnRuleStyle(String value);

  /** Gets the value of "column-rule-width" */
  String get columnRuleWidth();

  /** Sets the value of "column-rule-width" */
  void set columnRuleWidth(String value);

  /** Gets the value of "column-span" */
  String get columnSpan();

  /** Sets the value of "column-span" */
  void set columnSpan(String value);

  /** Gets the value of "column-width" */
  String get columnWidth();

  /** Sets the value of "column-width" */
  void set columnWidth(String value);

  /** Gets the value of "columns" */
  String get columns();

  /** Sets the value of "columns" */
  void set columns(String value);

  /** Gets the value of "content" */
  String get content();

  /** Sets the value of "content" */
  void set content(String value);

  /** Gets the value of "counter-increment" */
  String get counterIncrement();

  /** Sets the value of "counter-increment" */
  void set counterIncrement(String value);

  /** Gets the value of "counter-reset" */
  String get counterReset();

  /** Sets the value of "counter-reset" */
  void set counterReset(String value);

  /** Gets the value of "cursor" */
  String get cursor();

  /** Sets the value of "cursor" */
  void set cursor(String value);

  /** Gets the value of "direction" */
  String get direction();

  /** Sets the value of "direction" */
  void set direction(String value);

  /** Gets the value of "display" */
  String get display();

  /** Sets the value of "display" */
  void set display(String value);

  /** Gets the value of "empty-cells" */
  String get emptyCells();

  /** Sets the value of "empty-cells" */
  void set emptyCells(String value);

  /** Gets the value of "filter" */
  String get filter();

  /** Sets the value of "filter" */
  void set filter(String value);

  /** Gets the value of "flex-align" */
  String get flexAlign();

  /** Sets the value of "flex-align" */
  void set flexAlign(String value);

  /** Gets the value of "flex-flow" */
  String get flexFlow();

  /** Sets the value of "flex-flow" */
  void set flexFlow(String value);

  /** Gets the value of "flex-order" */
  String get flexOrder();

  /** Sets the value of "flex-order" */
  void set flexOrder(String value);

  /** Gets the value of "flex-pack" */
  String get flexPack();

  /** Sets the value of "flex-pack" */
  void set flexPack(String value);

  /** Gets the value of "float" */
  String get float();

  /** Sets the value of "float" */
  void set float(String value);

  /** Gets the value of "flow-from" */
  String get flowFrom();

  /** Sets the value of "flow-from" */
  void set flowFrom(String value);

  /** Gets the value of "flow-into" */
  String get flowInto();

  /** Sets the value of "flow-into" */
  void set flowInto(String value);

  /** Gets the value of "font" */
  String get font();

  /** Sets the value of "font" */
  void set font(String value);

  /** Gets the value of "font-family" */
  String get fontFamily();

  /** Sets the value of "font-family" */
  void set fontFamily(String value);

  /** Gets the value of "font-feature-settings" */
  String get fontFeatureSettings();

  /** Sets the value of "font-feature-settings" */
  void set fontFeatureSettings(String value);

  /** Gets the value of "font-size" */
  String get fontSize();

  /** Sets the value of "font-size" */
  void set fontSize(String value);

  /** Gets the value of "font-size-delta" */
  String get fontSizeDelta();

  /** Sets the value of "font-size-delta" */
  void set fontSizeDelta(String value);

  /** Gets the value of "font-smoothing" */
  String get fontSmoothing();

  /** Sets the value of "font-smoothing" */
  void set fontSmoothing(String value);

  /** Gets the value of "font-stretch" */
  String get fontStretch();

  /** Sets the value of "font-stretch" */
  void set fontStretch(String value);

  /** Gets the value of "font-style" */
  String get fontStyle();

  /** Sets the value of "font-style" */
  void set fontStyle(String value);

  /** Gets the value of "font-variant" */
  String get fontVariant();

  /** Sets the value of "font-variant" */
  void set fontVariant(String value);

  /** Gets the value of "font-weight" */
  String get fontWeight();

  /** Sets the value of "font-weight" */
  void set fontWeight(String value);

  /** Gets the value of "height" */
  String get height();

  /** Sets the value of "height" */
  void set height(String value);

  /** Gets the value of "highlight" */
  String get highlight();

  /** Sets the value of "highlight" */
  void set highlight(String value);

  /** Gets the value of "hyphenate-character" */
  String get hyphenateCharacter();

  /** Sets the value of "hyphenate-character" */
  void set hyphenateCharacter(String value);

  /** Gets the value of "hyphenate-limit-after" */
  String get hyphenateLimitAfter();

  /** Sets the value of "hyphenate-limit-after" */
  void set hyphenateLimitAfter(String value);

  /** Gets the value of "hyphenate-limit-before" */
  String get hyphenateLimitBefore();

  /** Sets the value of "hyphenate-limit-before" */
  void set hyphenateLimitBefore(String value);

  /** Gets the value of "hyphenate-limit-lines" */
  String get hyphenateLimitLines();

  /** Sets the value of "hyphenate-limit-lines" */
  void set hyphenateLimitLines(String value);

  /** Gets the value of "hyphens" */
  String get hyphens();

  /** Sets the value of "hyphens" */
  void set hyphens(String value);

  /** Gets the value of "image-rendering" */
  String get imageRendering();

  /** Sets the value of "image-rendering" */
  void set imageRendering(String value);

  /** Gets the value of "left" */
  String get left();

  /** Sets the value of "left" */
  void set left(String value);

  /** Gets the value of "letter-spacing" */
  String get letterSpacing();

  /** Sets the value of "letter-spacing" */
  void set letterSpacing(String value);

  /** Gets the value of "line-box-contain" */
  String get lineBoxContain();

  /** Sets the value of "line-box-contain" */
  void set lineBoxContain(String value);

  /** Gets the value of "line-break" */
  String get lineBreak();

  /** Sets the value of "line-break" */
  void set lineBreak(String value);

  /** Gets the value of "line-clamp" */
  String get lineClamp();

  /** Sets the value of "line-clamp" */
  void set lineClamp(String value);

  /** Gets the value of "line-height" */
  String get lineHeight();

  /** Sets the value of "line-height" */
  void set lineHeight(String value);

  /** Gets the value of "list-style" */
  String get listStyle();

  /** Sets the value of "list-style" */
  void set listStyle(String value);

  /** Gets the value of "list-style-image" */
  String get listStyleImage();

  /** Sets the value of "list-style-image" */
  void set listStyleImage(String value);

  /** Gets the value of "list-style-position" */
  String get listStylePosition();

  /** Sets the value of "list-style-position" */
  void set listStylePosition(String value);

  /** Gets the value of "list-style-type" */
  String get listStyleType();

  /** Sets the value of "list-style-type" */
  void set listStyleType(String value);

  /** Gets the value of "locale" */
  String get locale();

  /** Sets the value of "locale" */
  void set locale(String value);

  /** Gets the value of "logical-height" */
  String get logicalHeight();

  /** Sets the value of "logical-height" */
  void set logicalHeight(String value);

  /** Gets the value of "logical-width" */
  String get logicalWidth();

  /** Sets the value of "logical-width" */
  void set logicalWidth(String value);

  /** Gets the value of "margin" */
  String get margin();

  /** Sets the value of "margin" */
  void set margin(String value);

  /** Gets the value of "margin-after" */
  String get marginAfter();

  /** Sets the value of "margin-after" */
  void set marginAfter(String value);

  /** Gets the value of "margin-after-collapse" */
  String get marginAfterCollapse();

  /** Sets the value of "margin-after-collapse" */
  void set marginAfterCollapse(String value);

  /** Gets the value of "margin-before" */
  String get marginBefore();

  /** Sets the value of "margin-before" */
  void set marginBefore(String value);

  /** Gets the value of "margin-before-collapse" */
  String get marginBeforeCollapse();

  /** Sets the value of "margin-before-collapse" */
  void set marginBeforeCollapse(String value);

  /** Gets the value of "margin-bottom" */
  String get marginBottom();

  /** Sets the value of "margin-bottom" */
  void set marginBottom(String value);

  /** Gets the value of "margin-bottom-collapse" */
  String get marginBottomCollapse();

  /** Sets the value of "margin-bottom-collapse" */
  void set marginBottomCollapse(String value);

  /** Gets the value of "margin-collapse" */
  String get marginCollapse();

  /** Sets the value of "margin-collapse" */
  void set marginCollapse(String value);

  /** Gets the value of "margin-end" */
  String get marginEnd();

  /** Sets the value of "margin-end" */
  void set marginEnd(String value);

  /** Gets the value of "margin-left" */
  String get marginLeft();

  /** Sets the value of "margin-left" */
  void set marginLeft(String value);

  /** Gets the value of "margin-right" */
  String get marginRight();

  /** Sets the value of "margin-right" */
  void set marginRight(String value);

  /** Gets the value of "margin-start" */
  String get marginStart();

  /** Sets the value of "margin-start" */
  void set marginStart(String value);

  /** Gets the value of "margin-top" */
  String get marginTop();

  /** Sets the value of "margin-top" */
  void set marginTop(String value);

  /** Gets the value of "margin-top-collapse" */
  String get marginTopCollapse();

  /** Sets the value of "margin-top-collapse" */
  void set marginTopCollapse(String value);

  /** Gets the value of "marquee" */
  String get marquee();

  /** Sets the value of "marquee" */
  void set marquee(String value);

  /** Gets the value of "marquee-direction" */
  String get marqueeDirection();

  /** Sets the value of "marquee-direction" */
  void set marqueeDirection(String value);

  /** Gets the value of "marquee-increment" */
  String get marqueeIncrement();

  /** Sets the value of "marquee-increment" */
  void set marqueeIncrement(String value);

  /** Gets the value of "marquee-repetition" */
  String get marqueeRepetition();

  /** Sets the value of "marquee-repetition" */
  void set marqueeRepetition(String value);

  /** Gets the value of "marquee-speed" */
  String get marqueeSpeed();

  /** Sets the value of "marquee-speed" */
  void set marqueeSpeed(String value);

  /** Gets the value of "marquee-style" */
  String get marqueeStyle();

  /** Sets the value of "marquee-style" */
  void set marqueeStyle(String value);

  /** Gets the value of "mask" */
  String get mask();

  /** Sets the value of "mask" */
  void set mask(String value);

  /** Gets the value of "mask-attachment" */
  String get maskAttachment();

  /** Sets the value of "mask-attachment" */
  void set maskAttachment(String value);

  /** Gets the value of "mask-box-image" */
  String get maskBoxImage();

  /** Sets the value of "mask-box-image" */
  void set maskBoxImage(String value);

  /** Gets the value of "mask-box-image-outset" */
  String get maskBoxImageOutset();

  /** Sets the value of "mask-box-image-outset" */
  void set maskBoxImageOutset(String value);

  /** Gets the value of "mask-box-image-repeat" */
  String get maskBoxImageRepeat();

  /** Sets the value of "mask-box-image-repeat" */
  void set maskBoxImageRepeat(String value);

  /** Gets the value of "mask-box-image-slice" */
  String get maskBoxImageSlice();

  /** Sets the value of "mask-box-image-slice" */
  void set maskBoxImageSlice(String value);

  /** Gets the value of "mask-box-image-source" */
  String get maskBoxImageSource();

  /** Sets the value of "mask-box-image-source" */
  void set maskBoxImageSource(String value);

  /** Gets the value of "mask-box-image-width" */
  String get maskBoxImageWidth();

  /** Sets the value of "mask-box-image-width" */
  void set maskBoxImageWidth(String value);

  /** Gets the value of "mask-clip" */
  String get maskClip();

  /** Sets the value of "mask-clip" */
  void set maskClip(String value);

  /** Gets the value of "mask-composite" */
  String get maskComposite();

  /** Sets the value of "mask-composite" */
  void set maskComposite(String value);

  /** Gets the value of "mask-image" */
  String get maskImage();

  /** Sets the value of "mask-image" */
  void set maskImage(String value);

  /** Gets the value of "mask-origin" */
  String get maskOrigin();

  /** Sets the value of "mask-origin" */
  void set maskOrigin(String value);

  /** Gets the value of "mask-position" */
  String get maskPosition();

  /** Sets the value of "mask-position" */
  void set maskPosition(String value);

  /** Gets the value of "mask-position-x" */
  String get maskPositionX();

  /** Sets the value of "mask-position-x" */
  void set maskPositionX(String value);

  /** Gets the value of "mask-position-y" */
  String get maskPositionY();

  /** Sets the value of "mask-position-y" */
  void set maskPositionY(String value);

  /** Gets the value of "mask-repeat" */
  String get maskRepeat();

  /** Sets the value of "mask-repeat" */
  void set maskRepeat(String value);

  /** Gets the value of "mask-repeat-x" */
  String get maskRepeatX();

  /** Sets the value of "mask-repeat-x" */
  void set maskRepeatX(String value);

  /** Gets the value of "mask-repeat-y" */
  String get maskRepeatY();

  /** Sets the value of "mask-repeat-y" */
  void set maskRepeatY(String value);

  /** Gets the value of "mask-size" */
  String get maskSize();

  /** Sets the value of "mask-size" */
  void set maskSize(String value);

  /** Gets the value of "match-nearest-mail-blockquote-color" */
  String get matchNearestMailBlockquoteColor();

  /** Sets the value of "match-nearest-mail-blockquote-color" */
  void set matchNearestMailBlockquoteColor(String value);

  /** Gets the value of "max-height" */
  String get maxHeight();

  /** Sets the value of "max-height" */
  void set maxHeight(String value);

  /** Gets the value of "max-logical-height" */
  String get maxLogicalHeight();

  /** Sets the value of "max-logical-height" */
  void set maxLogicalHeight(String value);

  /** Gets the value of "max-logical-width" */
  String get maxLogicalWidth();

  /** Sets the value of "max-logical-width" */
  void set maxLogicalWidth(String value);

  /** Gets the value of "max-width" */
  String get maxWidth();

  /** Sets the value of "max-width" */
  void set maxWidth(String value);

  /** Gets the value of "min-height" */
  String get minHeight();

  /** Sets the value of "min-height" */
  void set minHeight(String value);

  /** Gets the value of "min-logical-height" */
  String get minLogicalHeight();

  /** Sets the value of "min-logical-height" */
  void set minLogicalHeight(String value);

  /** Gets the value of "min-logical-width" */
  String get minLogicalWidth();

  /** Sets the value of "min-logical-width" */
  void set minLogicalWidth(String value);

  /** Gets the value of "min-width" */
  String get minWidth();

  /** Sets the value of "min-width" */
  void set minWidth(String value);

  /** Gets the value of "nbsp-mode" */
  String get nbspMode();

  /** Sets the value of "nbsp-mode" */
  void set nbspMode(String value);

  /** Gets the value of "opacity" */
  String get opacity();

  /** Sets the value of "opacity" */
  void set opacity(String value);

  /** Gets the value of "orphans" */
  String get orphans();

  /** Sets the value of "orphans" */
  void set orphans(String value);

  /** Gets the value of "outline" */
  String get outline();

  /** Sets the value of "outline" */
  void set outline(String value);

  /** Gets the value of "outline-color" */
  String get outlineColor();

  /** Sets the value of "outline-color" */
  void set outlineColor(String value);

  /** Gets the value of "outline-offset" */
  String get outlineOffset();

  /** Sets the value of "outline-offset" */
  void set outlineOffset(String value);

  /** Gets the value of "outline-style" */
  String get outlineStyle();

  /** Sets the value of "outline-style" */
  void set outlineStyle(String value);

  /** Gets the value of "outline-width" */
  String get outlineWidth();

  /** Sets the value of "outline-width" */
  void set outlineWidth(String value);

  /** Gets the value of "overflow" */
  String get overflow();

  /** Sets the value of "overflow" */
  void set overflow(String value);

  /** Gets the value of "overflow-x" */
  String get overflowX();

  /** Sets the value of "overflow-x" */
  void set overflowX(String value);

  /** Gets the value of "overflow-y" */
  String get overflowY();

  /** Sets the value of "overflow-y" */
  void set overflowY(String value);

  /** Gets the value of "padding" */
  String get padding();

  /** Sets the value of "padding" */
  void set padding(String value);

  /** Gets the value of "padding-after" */
  String get paddingAfter();

  /** Sets the value of "padding-after" */
  void set paddingAfter(String value);

  /** Gets the value of "padding-before" */
  String get paddingBefore();

  /** Sets the value of "padding-before" */
  void set paddingBefore(String value);

  /** Gets the value of "padding-bottom" */
  String get paddingBottom();

  /** Sets the value of "padding-bottom" */
  void set paddingBottom(String value);

  /** Gets the value of "padding-end" */
  String get paddingEnd();

  /** Sets the value of "padding-end" */
  void set paddingEnd(String value);

  /** Gets the value of "padding-left" */
  String get paddingLeft();

  /** Sets the value of "padding-left" */
  void set paddingLeft(String value);

  /** Gets the value of "padding-right" */
  String get paddingRight();

  /** Sets the value of "padding-right" */
  void set paddingRight(String value);

  /** Gets the value of "padding-start" */
  String get paddingStart();

  /** Sets the value of "padding-start" */
  void set paddingStart(String value);

  /** Gets the value of "padding-top" */
  String get paddingTop();

  /** Sets the value of "padding-top" */
  void set paddingTop(String value);

  /** Gets the value of "page" */
  String get page();

  /** Sets the value of "page" */
  void set page(String value);

  /** Gets the value of "page-break-after" */
  String get pageBreakAfter();

  /** Sets the value of "page-break-after" */
  void set pageBreakAfter(String value);

  /** Gets the value of "page-break-before" */
  String get pageBreakBefore();

  /** Sets the value of "page-break-before" */
  void set pageBreakBefore(String value);

  /** Gets the value of "page-break-inside" */
  String get pageBreakInside();

  /** Sets the value of "page-break-inside" */
  void set pageBreakInside(String value);

  /** Gets the value of "perspective" */
  String get perspective();

  /** Sets the value of "perspective" */
  void set perspective(String value);

  /** Gets the value of "perspective-origin" */
  String get perspectiveOrigin();

  /** Sets the value of "perspective-origin" */
  void set perspectiveOrigin(String value);

  /** Gets the value of "perspective-origin-x" */
  String get perspectiveOriginX();

  /** Sets the value of "perspective-origin-x" */
  void set perspectiveOriginX(String value);

  /** Gets the value of "perspective-origin-y" */
  String get perspectiveOriginY();

  /** Sets the value of "perspective-origin-y" */
  void set perspectiveOriginY(String value);

  /** Gets the value of "pointer-events" */
  String get pointerEvents();

  /** Sets the value of "pointer-events" */
  void set pointerEvents(String value);

  /** Gets the value of "position" */
  String get position();

  /** Sets the value of "position" */
  void set position(String value);

  /** Gets the value of "quotes" */
  String get quotes();

  /** Sets the value of "quotes" */
  void set quotes(String value);

  /** Gets the value of "region-break-after" */
  String get regionBreakAfter();

  /** Sets the value of "region-break-after" */
  void set regionBreakAfter(String value);

  /** Gets the value of "region-break-before" */
  String get regionBreakBefore();

  /** Sets the value of "region-break-before" */
  void set regionBreakBefore(String value);

  /** Gets the value of "region-break-inside" */
  String get regionBreakInside();

  /** Sets the value of "region-break-inside" */
  void set regionBreakInside(String value);

  /** Gets the value of "region-overflow" */
  String get regionOverflow();

  /** Sets the value of "region-overflow" */
  void set regionOverflow(String value);

  /** Gets the value of "resize" */
  String get resize();

  /** Sets the value of "resize" */
  void set resize(String value);

  /** Gets the value of "right" */
  String get right();

  /** Sets the value of "right" */
  void set right(String value);

  /** Gets the value of "rtl-ordering" */
  String get rtlOrdering();

  /** Sets the value of "rtl-ordering" */
  void set rtlOrdering(String value);

  /** Gets the value of "size" */
  String get size();

  /** Sets the value of "size" */
  void set size(String value);

  /** Gets the value of "speak" */
  String get speak();

  /** Sets the value of "speak" */
  void set speak(String value);

  /** Gets the value of "src" */
  String get src();

  /** Sets the value of "src" */
  void set src(String value);

  /** Gets the value of "table-layout" */
  String get tableLayout();

  /** Sets the value of "table-layout" */
  void set tableLayout(String value);

  /** Gets the value of "tap-highlight-color" */
  String get tapHighlightColor();

  /** Sets the value of "tap-highlight-color" */
  void set tapHighlightColor(String value);

  /** Gets the value of "text-align" */
  String get textAlign();

  /** Sets the value of "text-align" */
  void set textAlign(String value);

  /** Gets the value of "text-combine" */
  String get textCombine();

  /** Sets the value of "text-combine" */
  void set textCombine(String value);

  /** Gets the value of "text-decoration" */
  String get textDecoration();

  /** Sets the value of "text-decoration" */
  void set textDecoration(String value);

  /** Gets the value of "text-decorations-in-effect" */
  String get textDecorationsInEffect();

  /** Sets the value of "text-decorations-in-effect" */
  void set textDecorationsInEffect(String value);

  /** Gets the value of "text-emphasis" */
  String get textEmphasis();

  /** Sets the value of "text-emphasis" */
  void set textEmphasis(String value);

  /** Gets the value of "text-emphasis-color" */
  String get textEmphasisColor();

  /** Sets the value of "text-emphasis-color" */
  void set textEmphasisColor(String value);

  /** Gets the value of "text-emphasis-position" */
  String get textEmphasisPosition();

  /** Sets the value of "text-emphasis-position" */
  void set textEmphasisPosition(String value);

  /** Gets the value of "text-emphasis-style" */
  String get textEmphasisStyle();

  /** Sets the value of "text-emphasis-style" */
  void set textEmphasisStyle(String value);

  /** Gets the value of "text-fill-color" */
  String get textFillColor();

  /** Sets the value of "text-fill-color" */
  void set textFillColor(String value);

  /** Gets the value of "text-indent" */
  String get textIndent();

  /** Sets the value of "text-indent" */
  void set textIndent(String value);

  /** Gets the value of "text-line-through" */
  String get textLineThrough();

  /** Sets the value of "text-line-through" */
  void set textLineThrough(String value);

  /** Gets the value of "text-line-through-color" */
  String get textLineThroughColor();

  /** Sets the value of "text-line-through-color" */
  void set textLineThroughColor(String value);

  /** Gets the value of "text-line-through-mode" */
  String get textLineThroughMode();

  /** Sets the value of "text-line-through-mode" */
  void set textLineThroughMode(String value);

  /** Gets the value of "text-line-through-style" */
  String get textLineThroughStyle();

  /** Sets the value of "text-line-through-style" */
  void set textLineThroughStyle(String value);

  /** Gets the value of "text-line-through-width" */
  String get textLineThroughWidth();

  /** Sets the value of "text-line-through-width" */
  void set textLineThroughWidth(String value);

  /** Gets the value of "text-orientation" */
  String get textOrientation();

  /** Sets the value of "text-orientation" */
  void set textOrientation(String value);

  /** Gets the value of "text-overflow" */
  String get textOverflow();

  /** Sets the value of "text-overflow" */
  void set textOverflow(String value);

  /** Gets the value of "text-overline" */
  String get textOverline();

  /** Sets the value of "text-overline" */
  void set textOverline(String value);

  /** Gets the value of "text-overline-color" */
  String get textOverlineColor();

  /** Sets the value of "text-overline-color" */
  void set textOverlineColor(String value);

  /** Gets the value of "text-overline-mode" */
  String get textOverlineMode();

  /** Sets the value of "text-overline-mode" */
  void set textOverlineMode(String value);

  /** Gets the value of "text-overline-style" */
  String get textOverlineStyle();

  /** Sets the value of "text-overline-style" */
  void set textOverlineStyle(String value);

  /** Gets the value of "text-overline-width" */
  String get textOverlineWidth();

  /** Sets the value of "text-overline-width" */
  void set textOverlineWidth(String value);

  /** Gets the value of "text-rendering" */
  String get textRendering();

  /** Sets the value of "text-rendering" */
  void set textRendering(String value);

  /** Gets the value of "text-security" */
  String get textSecurity();

  /** Sets the value of "text-security" */
  void set textSecurity(String value);

  /** Gets the value of "text-shadow" */
  String get textShadow();

  /** Sets the value of "text-shadow" */
  void set textShadow(String value);

  /** Gets the value of "text-size-adjust" */
  String get textSizeAdjust();

  /** Sets the value of "text-size-adjust" */
  void set textSizeAdjust(String value);

  /** Gets the value of "text-stroke" */
  String get textStroke();

  /** Sets the value of "text-stroke" */
  void set textStroke(String value);

  /** Gets the value of "text-stroke-color" */
  String get textStrokeColor();

  /** Sets the value of "text-stroke-color" */
  void set textStrokeColor(String value);

  /** Gets the value of "text-stroke-width" */
  String get textStrokeWidth();

  /** Sets the value of "text-stroke-width" */
  void set textStrokeWidth(String value);

  /** Gets the value of "text-transform" */
  String get textTransform();

  /** Sets the value of "text-transform" */
  void set textTransform(String value);

  /** Gets the value of "text-underline" */
  String get textUnderline();

  /** Sets the value of "text-underline" */
  void set textUnderline(String value);

  /** Gets the value of "text-underline-color" */
  String get textUnderlineColor();

  /** Sets the value of "text-underline-color" */
  void set textUnderlineColor(String value);

  /** Gets the value of "text-underline-mode" */
  String get textUnderlineMode();

  /** Sets the value of "text-underline-mode" */
  void set textUnderlineMode(String value);

  /** Gets the value of "text-underline-style" */
  String get textUnderlineStyle();

  /** Sets the value of "text-underline-style" */
  void set textUnderlineStyle(String value);

  /** Gets the value of "text-underline-width" */
  String get textUnderlineWidth();

  /** Sets the value of "text-underline-width" */
  void set textUnderlineWidth(String value);

  /** Gets the value of "top" */
  String get top();

  /** Sets the value of "top" */
  void set top(String value);

  /** Gets the value of "transform" */
  String get transform();

  /** Sets the value of "transform" */
  void set transform(String value);

  /** Gets the value of "transform-origin" */
  String get transformOrigin();

  /** Sets the value of "transform-origin" */
  void set transformOrigin(String value);

  /** Gets the value of "transform-origin-x" */
  String get transformOriginX();

  /** Sets the value of "transform-origin-x" */
  void set transformOriginX(String value);

  /** Gets the value of "transform-origin-y" */
  String get transformOriginY();

  /** Sets the value of "transform-origin-y" */
  void set transformOriginY(String value);

  /** Gets the value of "transform-origin-z" */
  String get transformOriginZ();

  /** Sets the value of "transform-origin-z" */
  void set transformOriginZ(String value);

  /** Gets the value of "transform-style" */
  String get transformStyle();

  /** Sets the value of "transform-style" */
  void set transformStyle(String value);

  /** Gets the value of "transition" */
  String get transition();

  /** Sets the value of "transition" */
  void set transition(String value);

  /** Gets the value of "transition-delay" */
  String get transitionDelay();

  /** Sets the value of "transition-delay" */
  void set transitionDelay(String value);

  /** Gets the value of "transition-duration" */
  String get transitionDuration();

  /** Sets the value of "transition-duration" */
  void set transitionDuration(String value);

  /** Gets the value of "transition-property" */
  String get transitionProperty();

  /** Sets the value of "transition-property" */
  void set transitionProperty(String value);

  /** Gets the value of "transition-timing-function" */
  String get transitionTimingFunction();

  /** Sets the value of "transition-timing-function" */
  void set transitionTimingFunction(String value);

  /** Gets the value of "unicode-bidi" */
  String get unicodeBidi();

  /** Sets the value of "unicode-bidi" */
  void set unicodeBidi(String value);

  /** Gets the value of "unicode-range" */
  String get unicodeRange();

  /** Sets the value of "unicode-range" */
  void set unicodeRange(String value);

  /** Gets the value of "user-drag" */
  String get userDrag();

  /** Sets the value of "user-drag" */
  void set userDrag(String value);

  /** Gets the value of "user-modify" */
  String get userModify();

  /** Sets the value of "user-modify" */
  void set userModify(String value);

  /** Gets the value of "user-select" */
  String get userSelect();

  /** Sets the value of "user-select" */
  void set userSelect(String value);

  /** Gets the value of "vertical-align" */
  String get verticalAlign();

  /** Sets the value of "vertical-align" */
  void set verticalAlign(String value);

  /** Gets the value of "visibility" */
  String get visibility();

  /** Sets the value of "visibility" */
  void set visibility(String value);

  /** Gets the value of "white-space" */
  String get whiteSpace();

  /** Sets the value of "white-space" */
  void set whiteSpace(String value);

  /** Gets the value of "widows" */
  String get widows();

  /** Sets the value of "widows" */
  void set widows(String value);

  /** Gets the value of "width" */
  String get width();

  /** Sets the value of "width" */
  void set width(String value);

  /** Gets the value of "word-break" */
  String get wordBreak();

  /** Sets the value of "word-break" */
  void set wordBreak(String value);

  /** Gets the value of "word-spacing" */
  String get wordSpacing();

  /** Sets the value of "word-spacing" */
  void set wordSpacing(String value);

  /** Gets the value of "word-wrap" */
  String get wordWrap();

  /** Sets the value of "word-wrap" */
  void set wordWrap(String value);

  /** Gets the value of "wrap-shape" */
  String get wrapShape();

  /** Sets the value of "wrap-shape" */
  void set wrapShape(String value);

  /** Gets the value of "writing-mode" */
  String get writingMode();

  /** Sets the value of "writing-mode" */
  void set writingMode(String value);

  /** Gets the value of "z-index" */
  String get zIndex();

  /** Sets the value of "z-index" */
  void set zIndex(String value);

  /** Gets the value of "zoom" */
  String get zoom();

  /** Sets the value of "zoom" */
  void set zoom(String value);

}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface CustomEvent extends Event default CustomEventWrappingImplementation {

  CustomEvent(String type, [bool canBubble, bool cancelable, Object detail]);

  String get detail();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface DeviceMotionEvent extends Event default DeviceMotionEventWrappingImplementation {

  // TODO(nweiz): Add more arguments to the constructor when we support
  // DeviceMotionEvent more thoroughly.
  DeviceMotionEvent(String type, [bool canBubble, bool cancelable]);

  num get interval();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface DeviceOrientationEvent extends Event default DeviceOrientationEventWrappingImplementation {

  DeviceOrientationEvent(String type, double alpha, double beta, double gamma,
      [bool canBubble, bool cancelable]);

  num get alpha();

  num get beta();

  num get gamma();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface DocumentEvents extends ElementEvents {
  EventListenerList get readyStateChange();
  EventListenerList get selectionChange();
  EventListenerList get contentLoaded();
}

// TODO(jacobr): add DocumentFragment ctor
// add something smarted for document.domain
interface Document extends Element /*, common.NodeSelector */ {

  // TODO(jacobr): remove.
  Event createEvent(String eventType);

  Element get activeElement();

  // TODO(jacobr): add
  // Map<String, Class> tags;

  Element get body();

  void set body(Element value);

  String get charset();

  void set charset(String value);

  // FIXME(slightlyoff): FIX COOKIES, MMM...COOKIES. ME WANT COOKIES!!
  //                     Map<String, CookieList> cookies
  //                     Map<String, Cookie> CookieList
  String get cookie();

  void set cookie(String value);

  Window get window();

  String get domain();

  HeadElement get head();

  String get lastModified();

  // TODO(jacobr): remove once on.contentLoaded is changed to return a Future.
  String get readyState();

  String get referrer();

  StyleSheetList get styleSheets();

  // TODO(jacobr): should this be removed? Users could write document.query("title").text instead.
  String get title();

  void set title(String value);

  bool get webkitHidden();

  String get webkitVisibilityState();

  Future<Range> caretRangeFromPoint([int x, int y]);

  Future<Element> elementFromPoint([int x, int y]);

  bool execCommand([String command, bool userInterface, String value]);

  // TODO(jacobr): remove once a new API is specified
  CanvasRenderingContext getCSSCanvasContext(String contextId, String name,
                                             int width, int height);

  bool queryCommandEnabled([String command]);

  bool queryCommandIndeterm([String command]);

  bool queryCommandState([String command]);

  bool queryCommandSupported([String command]);

  String queryCommandValue([String command]);

  String get manifest();

  void set manifest(String value);

  DocumentEvents get on();

  Future<ElementRect> get rect();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface DocumentFragment extends Element default DocumentFragmentWrappingImplementation {

  DocumentFragment();

  DocumentFragment.html(String html);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface DOMApplicationCacheEvents extends Events {
  EventListenerList get cached();
  EventListenerList get checking();
  EventListenerList get downloading();
  EventListenerList get error();
  EventListenerList get noUpdate();
  EventListenerList get obsolete();
  EventListenerList get progress();
  EventListenerList get updateReady();
}

interface DOMApplicationCache extends EventTarget {

  static final int CHECKING = 2;

  static final int DOWNLOADING = 3;

  static final int IDLE = 1;

  static final int OBSOLETE = 5;

  static final int UNCACHED = 0;

  static final int UPDATEREADY = 4;

  int get status();

  void swapCache();

  void update();

  DOMApplicationCacheEvents get on();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface ElementList extends List<Element> {
  // TODO(jacobr): add element batch manipulation methods.
  Element get first();
  // TODO(jacobr): add insertAt
}

class DeferredElementRect {
  // TODO(jacobr)
}

interface ElementEvents extends Events {
  EventListenerList get abort();
  EventListenerList get beforeCopy();
  EventListenerList get beforeCut();
  EventListenerList get beforePaste();
  EventListenerList get blur();
  EventListenerList get change();
  EventListenerList get click();
  EventListenerList get contextMenu();
  EventListenerList get copy();
  EventListenerList get cut();
  EventListenerList get dblClick();
  EventListenerList get drag();
  EventListenerList get dragEnd();
  EventListenerList get dragEnter();
  EventListenerList get dragLeave();
  EventListenerList get dragOver();
  EventListenerList get dragStart();
  EventListenerList get drop();
  EventListenerList get error();
  EventListenerList get focus();
  EventListenerList get input();
  EventListenerList get invalid();
  EventListenerList get keyDown();
  EventListenerList get keyPress();
  EventListenerList get keyUp();
  EventListenerList get load();
  EventListenerList get mouseDown();
  EventListenerList get mouseMove();
  EventListenerList get mouseOut();
  EventListenerList get mouseOver();
  EventListenerList get mouseUp();
  EventListenerList get mouseWheel();
  EventListenerList get paste();
  EventListenerList get reset();
  EventListenerList get scroll();
  EventListenerList get search();
  EventListenerList get select();
  EventListenerList get selectStart();
  EventListenerList get submit();
  EventListenerList get touchCancel();
  EventListenerList get touchEnd();
  EventListenerList get touchLeave();
  EventListenerList get touchMove();
  EventListenerList get touchStart();
  EventListenerList get transitionEnd();
  EventListenerList get fullscreenChange();
}

/**
 * All your element measurement needs in one place
 */
interface ElementRect {
  ClientRect get client();
  ClientRect get offset();
  ClientRect get scroll();
  ClientRect get bounding();
  List<ClientRect> get clientRects();
}


interface Element extends Node /*, common.NodeSelector, common.ElementTraversal */
    default ElementWrappingImplementation {

  Element.html(String html);
  Element.tag(String tag);

  Map<String, String> get attributes();
  void set attributes(Map<String, String> value);

  ElementList get elements();

  // TODO: The type of value should be Collection<Element>. See http://b/5392897
  void set elements(value);

  Set<String> get classes();

  // TODO: The type of value should be Collection<String>. See http://b/5392897
  void set classes(value);

  Map<String, String> get dataAttributes();
  void set dataAttributes(Map<String, String> value);

  String get contentEditable();

  void set contentEditable(String value);

  String get dir();

  void set dir(String value);

  bool get draggable();

  void set draggable(bool value);

  Element get firstElementChild();

  bool get hidden();

  void set hidden(bool value);

  String get id();

  void set id(String value);

  String get innerHTML();

  void set innerHTML(String value);

  bool get isContentEditable();

  String get lang();

  void set lang(String value);

  Element get lastElementChild();

  Element get nextElementSibling();

  Element get offsetParent();

  String get outerHTML();

  Element get previousElementSibling();

  void set scrollLeft(int value);

  void set scrollTop(int value);

  bool get spellcheck();

  void set spellcheck(bool value);

  CSSStyleDeclaration get style();

  int get tabIndex();

  void set tabIndex(int value);

  String get tagName();

  String get title();

  void set title(String value);

  String get webkitdropzone();

  void set webkitdropzone(String value);

  void blur();

  void focus();

  Element insertAdjacentElement([String where, Element element]);

  void insertAdjacentHTML([String position_OR_where, String text]);

  void insertAdjacentText([String where, String text]);

  Element query(String selectors);

  ElementList queryAll(String selectors);

  Element get parent();

  void scrollByLines([int lines]);

  void scrollByPages([int pages]);

  void scrollIntoView([bool centerIfNeeded]);

  bool matchesSelector([String selectors]);

  Future<ElementRect> get rect();

  Future<CSSStyleDeclaration> get computedStyle();

  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement);

  ElementEvents get on();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface ErrorEvent extends Event default ErrorEventWrappingImplementation {

  ErrorEvent(String type, String message, String filename, int lineNo,
      [bool canBubble, bool cancelable]);

  String get filename();

  int get lineno();

  String get message();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface Event default EventWrappingImplementation {

  static final int AT_TARGET = 2;

  static final int BLUR = 8192;

  static final int BUBBLING_PHASE = 3;

  static final int CAPTURING_PHASE = 1;

  static final int CHANGE = 32768;

  static final int CLICK = 64;

  static final int DBLCLICK = 128;

  static final int DRAGDROP = 2048;

  static final int FOCUS = 4096;

  static final int KEYDOWN = 256;

  static final int KEYPRESS = 1024;

  static final int KEYUP = 512;

  static final int MOUSEDOWN = 1;

  static final int MOUSEDRAG = 32;

  static final int MOUSEMOVE = 16;

  static final int MOUSEOUT = 8;

  static final int MOUSEOVER = 4;

  static final int MOUSEUP = 2;

  static final int SELECT = 16384;

  // In JS, canBubble and cancelable are technically required parameters to
  // init*Event. In practice, though, if they aren't provided they simply
  // default to false (since that's Boolean(undefined)).
  //
  // Contrary to JS, we default canBubble and cancelable to true, since that's
  // what people want most of the time anyway.
  Event(String type, [bool canBubble, bool cancelable]);

  bool get bubbles();

  bool get cancelBubble();

  void set cancelBubble(bool value);

  bool get cancelable();

  EventTarget get currentTarget();

  bool get defaultPrevented();

  int get eventPhase();

  bool get returnValue();

  void set returnValue(bool value);

  EventTarget get srcElement();

  EventTarget get target();

  int get timeStamp();

  String get type();

  void preventDefault();

  void stopImmediatePropagation();

  void stopPropagation();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef void EventListener(Event event);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface EventSourceEvents extends Events {
  EventListenerList get error();
  EventListenerList get message();
  EventListenerList get open();
}

interface EventSource extends EventTarget {

  static final int CLOSED = 2;

  static final int CONNECTING = 0;

  static final int OPEN = 1;

  String get URL();

  int get readyState();

  void close();

  EventSourceEvents get on();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface EventListenerList {
  EventListenerList add(EventListener handler, [bool useCapture]);

  EventListenerList remove(EventListener handler, [bool useCapture]);

  bool dispatch(Event evt);
}

interface Events {
  EventListenerList operator [](String type);
}

interface EventTarget {
  Events get on();
}

// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

Window secretWindow;
Document secretDocument;

Window get window() {
  if (secretWindow === null) {
    LevelDom.initialize();
  }
  return secretWindow;
}

Document get document() {
  if (secretWindow === null) {
    LevelDom.initialize();
  }
  return secretDocument;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface HashChangeEvent extends Event default HashChangeEventWrappingImplementation {

  HashChangeEvent(String type, String oldURL, String newURL, [bool canBubble,
      bool cancelable]);

  String get newURL();

  String get oldURL();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface KeyboardEvent extends UIEvent default KeyboardEventWrappingImplementation {

  static final int KEY_LOCATION_LEFT = 0x01;

  static final int KEY_LOCATION_NUMPAD = 0x03;

  static final int KEY_LOCATION_RIGHT = 0x02;

  static final int KEY_LOCATION_STANDARD = 0x00;

  KeyboardEvent(String type, Window view, String keyIdentifier, int keyLocation,
      [bool canBubble, bool cancelable, bool ctrlKey, bool altKey,
      bool shiftKey, bool metaKey, bool altGraphKey]);

  bool get altGraphKey();

  bool get altKey();

  bool get ctrlKey();

  String get keyIdentifier();

  int get keyLocation();

  bool get metaKey();

  bool get shiftKey();

  bool getModifierState(String keyIdentifierArg);
}

// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the standard key locations returned by
 * KeyboardEvent.getKeyLocation.
 */
interface KeyLocation {

  /**
   * The event key is not distinguished as the left or right version
   * of the key, and did not originate from the numeric keypad (or did not
   * originate with a virtual key corresponding to the numeric keypad).
   */
  static final int STANDARD = 0;

  /**
   * The event key is in the left key location.
   */
  static final int LEFT = 1;

  /**
   * The event key is in the right key location.
   */
  static final int RIGHT = 2;

  /**
   * The event key originated on the numeric keypad or with a virtual key
   * corresponding to the numeric keypad.
   */
  static final int NUMPAD = 3;

  /**
   * The event key originated on a mobile device, either on a physical
   * keypad or a virtual keyboard.
   */
  static final int MOBILE = 4;

  /**
   * The event key originated on a game controller or a joystick on a mobile
   * device.
   */
  static final int JOYSTICK = 5;
}

/**
 * Defines the standard keyboard identifier names for keys that are returned
 * by KeyEvent.getKeyboardIdentifier when the key does not have a direct
 * unicode mapping.
 */
interface KeyName {

  /** The Accept (Commit, OK) key */
  static final String ACCEPT = "Accept";

  /** The Add key */
  static final String ADD = "Add";

  /** The Again key */
  static final String AGAIN = "Again";

  /** The All Candidates key */
  static final String ALL_CANDIDATES = "AllCandidates";

  /** The Alphanumeric key */
  static final String ALPHANUMERIC = "Alphanumeric";

  /** The Alt (Menu) key */
  static final String ALT = "Alt";

  /** The Alt-Graph key */
  static final String ALT_GRAPH = "AltGraph";

  /** The Application key */
  static final String APPS = "Apps";

  /** The ATTN key */
  static final String ATTN = "Attn";

  /** The Browser Back key */
  static final String BROWSER_BACK = "BrowserBack";

  /** The Browser Favorites key */
  static final String BROWSER_FAVORTIES = "BrowserFavorites";

  /** The Browser Forward key */
  static final String BROWSER_FORWARD = "BrowserForward";

  /** The Browser Home key */
  static final String BROWSER_NAME = "BrowserHome";

  /** The Browser Refresh key */
  static final String BROWSER_REFRESH = "BrowserRefresh";

  /** The Browser Search key */
  static final String BROWSER_SEARCH = "BrowserSearch";

  /** The Browser Stop key */
  static final String BROWSER_STOP = "BrowserStop";

  /** The Camera key */
  static final String CAMERA = "Camera";

  /** The Caps Lock (Capital) key */
  static final String CAPS_LOCK = "CapsLock";

  /** The Clear key */
  static final String CLEAR = "Clear";

  /** The Code Input key */
  static final String CODE_INPUT = "CodeInput";

  /** The Compose key */
  static final String COMPOSE = "Compose";

  /** The Control (Ctrl) key */
  static final String CONTROL = "Control";

  /** The Crsel key */
  static final String CRSEL = "Crsel";

  /** The Convert key */
  static final String CONVERT = "Convert";

  /** The Copy key */
  static final String COPY = "Copy";

  /** The Cut key */
  static final String CUT = "Cut";

  /** The Decimal key */
  static final String DECIMAL = "Decimal";

  /** The Divide key */
  static final String DIVIDE = "Divide";

  /** The Down Arrow key */
  static final String DOWN = "Down";

  /** The diagonal Down-Left Arrow key */
  static final String DOWN_LEFT = "DownLeft";

  /** The diagonal Down-Right Arrow key */
  static final String DOWN_RIGHT = "DownRight";

  /** The Eject key */
  static final String EJECT = "Eject";

  /** The End key */
  static final String END = "End";

  /**
   * The Enter key. Note: This key value must also be used for the Return
   *  (Macintosh numpad) key
   */
  static final String ENTER = "Enter";

  /** The Erase EOF key */
  static final String ERASE_EOF= "EraseEof";

  /** The Execute key */
  static final String EXECUTE = "Execute";

  /** The Exsel key */
  static final String EXSEL = "Exsel";

  /** The Function switch key */
  static final String FN = "Fn";

  /** The F1 key */
  static final String F1 = "F1";

  /** The F2 key */
  static final String F2 = "F2";

  /** The F3 key */
  static final String F3 = "F3";

  /** The F4 key */
  static final String F4 = "F4";

  /** The F5 key */
  static final String F5 = "F5";

  /** The F6 key */
  static final String F6 = "F6";

  /** The F7 key */
  static final String F7 = "F7";

  /** The F8 key */
  static final String F8 = "F8";

  /** The F9 key */
  static final String F9 = "F9";

  /** The F10 key */
  static final String F10 = "F10";

  /** The F11 key */
  static final String F11 = "F11";

  /** The F12 key */
  static final String F12 = "F12";

  /** The F13 key */
  static final String F13 = "F13";

  /** The F14 key */
  static final String F14 = "F14";

  /** The F15 key */
  static final String F15 = "F15";

  /** The F16 key */
  static final String F16 = "F16";

  /** The F17 key */
  static final String F17 = "F17";

  /** The F18 key */
  static final String F18 = "F18";

  /** The F19 key */
  static final String F19 = "F19";

  /** The F20 key */
  static final String F20 = "F20";

  /** The F21 key */
  static final String F21 = "F21";

  /** The F22 key */
  static final String F22 = "F22";

  /** The F23 key */
  static final String F23 = "F23";

  /** The F24 key */
  static final String F24 = "F24";

  /** The Final Mode (Final) key used on some asian keyboards */
  static final String FINAL_MODE = "FinalMode";

  /** The Find key */
  static final String FIND = "Find";

  /** The Full-Width Characters key */
  static final String FULL_WIDTH = "FullWidth";

  /** The Half-Width Characters key */
  static final String HALF_WIDTH = "HalfWidth";

  /** The Hangul (Korean characters) Mode key */
  static final String HANGUL_MODE = "HangulMode";

  /** The Hanja (Korean characters) Mode key */
  static final String HANJA_MODE = "HanjaMode";

  /** The Help key */
  static final String HELP = "Help";

  /** The Hiragana (Japanese Kana characters) key */
  static final String HIRAGANA = "Hiragana";

  /** The Home key */
  static final String HOME = "Home";

  /** The Insert (Ins) key */
  static final String INSERT = "Insert";

  /** The Japanese-Hiragana key */
  static final String JAPANESE_HIRAGANA = "JapaneseHiragana";

  /** The Japanese-Katakana key */
  static final String JAPANESE_KATAKANA = "JapaneseKatakana";

  /** The Japanese-Romaji key */
  static final String JAPANESE_ROMAJI = "JapaneseRomaji";

  /** The Junja Mode key */
  static final String JUNJA_MODE = "JunjaMode";

  /** The Kana Mode (Kana Lock) key */
  static final String KANA_MODE = "KanaMode";

  /**
   * The Kanji (Japanese name for ideographic characters of Chinese origin)
   * Mode key
   */
  static final String KANJI_MODE = "KanjiMode";

  /** The Katakana (Japanese Kana characters) key */
  static final String KATAKANA = "Katakana";

  /** The Start Application One key */
  static final String LAUNCH_APPLICATION_1 = "LaunchApplication1";

  /** The Start Application Two key */
  static final String LAUNCH_APPLICATION_2 = "LaunchApplication2";

  /** The Start Mail key */
  static final String LAUNCH_MAIL = "LaunchMail";

  /** The Left Arrow key */
  static final String LEFT = "Left";

  /** The Menu key */
  static final String MENU = "Menu";

  /**
   * The Meta key. Note: This key value shall be also used for the Apple
   * Command key
   */
  static final String META = "Meta";

  /** The Media Next Track key */
  static final String MEDIA_NEXT_TRACK = "MediaNextTrack";

  /** The Media Play Pause key */
  static final String MEDIA_PAUSE_PLAY = "MediaPlayPause";

  /** The Media Previous Track key */
  static final String MEDIA_PREVIOUS_TRACK = "MediaPreviousTrack";

  /** The Media Stop key */
  static final String MEDIA_STOP = "MediaStop";

  /** The Mode Change key */
  static final String MODE_CHANGE = "ModeChange";

  /** The Next Candidate function key */
  static final String NEXT_CANDIDATE = "NextCandidate";

  /** The Nonconvert (Don't Convert) key */
  static final String NON_CONVERT = "Nonconvert";

  /** The Number Lock key */
  static final String NUM_LOCK = "NumLock";

  /** The Page Down (Next) key */
  static final String PAGE_DOWN = "PageDown";

  /** The Page Up key */
  static final String PAGE_UP = "PageUp";

  /** The Paste key */
  static final String PASTE = "Paste";

  /** The Pause key */
  static final String PAUSE = "Pause";

  /** The Play key */
  static final String PLAY = "Play";

  /**
   * The Power key. Note: Some devices may not expose this key to the
   * operating environment
   */
  static final String POWER = "Power";

  /** The Previous Candidate function key */
  static final String PREVIOUS_CANDIDATE = "PreviousCandidate";

  /** The Print Screen (PrintScrn, SnapShot) key */
  static final String PRINT_SCREEN = "PrintScreen";

  /** The Process key */
  static final String PROCESS = "Process";

  /** The Props key */
  static final String PROPS = "Props";

  /** The Right Arrow key */
  static final String RIGHT = "Right";

  /** The Roman Characters function key */
  static final String ROMAN_CHARACTERS = "RomanCharacters";

  /** The Scroll Lock key */
  static final String SCROLL = "Scroll";

  /** The Select key */
  static final String SELECT = "Select";

  /** The Select Media key */
  static final String SELECT_MEDIA = "SelectMedia";

  /** The Separator key */
  static final String SEPARATOR = "Separator";

  /** The Shift key */
  static final String SHIFT = "Shift";

  /** The Soft1 key */
  static final String SOFT_1 = "Soft1";

  /** The Soft2 key */
  static final String SOFT_2 = "Soft2";

  /** The Soft3 key */
  static final String SOFT_3 = "Soft3";

  /** The Soft4 key */
  static final String SOFT_4 = "Soft4";

  /** The Stop key */
  static final String STOP = "Stop";

  /** The Subtract key */
  static final String SUBTRACT = "Subtract";

  /** The Symbol Lock key */
  static final String SYMBOL_LOCK = "SymbolLock";

  /** The Up Arrow key */
  static final String UP = "Up";

  /** The diagonal Up-Left Arrow key */
  static final String UP_LEFT = "UpLeft";

  /** The diagonal Up-Right Arrow key */
  static final String UP_RIGHT = "UpRight";

  /** The Undo key */
  static final String UNDO = "Undo";

  /** The Volume Down key */
  static final String VOLUME_DOWN = "VolumeDown";

  /** The Volume Mute key */
  static final String VOLUMN_MUTE = "VolumeMute";

  /** The Volume Up key */
  static final String VOLUMN_UP = "VolumeUp";

  /** The Windows Logo key */
  static final String WIN = "Win";

  /** The Zoom key */
  static final String ZOOM = "Zoom";

  /**
   * The Backspace (Back) key. Note: This key value shall be also used for the
   * key labeled 'delete' MacOS keyboards when not modified by the 'Fn' key
   */
  static final String BACKSPACE = "Backspace";

  /** The Horizontal Tabulation (Tab) key */
  static final String TAB = "Tab";

  /** The Cancel key */
  static final String CANCEL = "Cancel";

  /** The Escape (Esc) key */
  static final String ESC = "Esc";

  /** The Space (Spacebar) key:   */
  static final String SPACEBAR = "Spacebar";

  /**
   * The Delete (Del) Key. Note: This key value shall be also used for the key
   * labeled 'delete' MacOS keyboards when modified by the 'Fn' key
   */
  static final String DEL = "Del";

  /** The Combining Grave Accent (Greek Varia, Dead Grave) key */
  static final String DEAD_GRAVE = "DeadGrave";

  /**
   * The Combining Acute Accent (Stress Mark, Greek Oxia, Tonos, Dead Eacute)
   * key
   */
  static final String DEAD_EACUTE = "DeadEacute";

  /** The Combining Circumflex Accent (Hat, Dead Circumflex) key */
  static final String DEAD_CIRCUMFLEX = "DeadCircumflex";

  /** The Combining Tilde (Dead Tilde) key */
  static final String DEAD_TILDE = "DeadTilde";

  /** The Combining Macron (Long, Dead Macron) key */
  static final String DEAD_MACRON = "DeadMacron";

  /** The Combining Breve (Short, Dead Breve) key */
  static final String DEAD_BREVE = "DeadBreve";

  /** The Combining Dot Above (Derivative, Dead Above Dot) key */
  static final String DEAD_ABOVE_DOT = "DeadAboveDot";

  /**
   * The Combining Diaeresis (Double Dot Abode, Umlaut, Greek Dialytika,
   * Double Derivative, Dead Diaeresis) key
   */
  static final String DEAD_UMLAUT = "DeadUmlaut";

  /** The Combining Ring Above (Dead Above Ring) key */
  static final String DEAD_ABOVE_RING = "DeadAboveRing";

  /** The Combining Double Acute Accent (Dead Doubleacute) key */
  static final String DEAD_DOUBLEACUTE = "DeadDoubleacute";

  /** The Combining Caron (Hacek, V Above, Dead Caron) key */
  static final String DEAD_CARON = "DeadCaron";

  /** The Combining Cedilla (Dead Cedilla) key */
  static final String DEAD_CEDILLA = "DeadCedilla";

  /** The Combining Ogonek (Nasal Hook, Dead Ogonek) key */
  static final String DEAD_OGONEK = "DeadOgonek";

  /**
   * The Combining Greek Ypogegrammeni (Greek Non-Spacing Iota Below, Iota
   * Subscript, Dead Iota) key
   */
  static final String DEAD_IOTA = "DeadIota";

  /**
   * The Combining Katakana-Hiragana Voiced Sound Mark (Dead Voiced Sound) key
   */
  static final String DEAD_VOICED_SOUND = "DeadVoicedSound";

  /**
   * The Combining Katakana-Hiragana Semi-Voiced Sound Mark (Dead Semivoiced
   * Sound) key
   */
  static final String DEC_SEMIVOICED_SOUND= "DeadSemivoicedSound";

  /**
   * Key value used when an implementation is unable to identify another key
   * value, due to either hardware, platform, or software constraints
   */
  static final String UNIDENTIFIED = "Unidentified";
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface MessageEvent extends Event default MessageEventWrappingImplementation {

  MessageEvent(String type, String data, String origin, String lastEventId,
      Window source, MessagePort port, [bool canBubble, bool cancelable]);

  String get data();

  String get lastEventId();

  MessagePort get messagePort();

  String get origin();

  Window get source();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface MessagePort extends EventTarget {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface MouseEvent extends UIEvent default MouseEventWrappingImplementation {

  MouseEvent(String type, Window view, int detail, int screenX, int screenY,
      int clientX, int clientY, int button, [bool canBubble, bool cancelable,
      bool ctrlKey, bool altKey, bool shiftKey, bool metaKey,
      EventTarget relatedTarget]);

  bool get altKey();

  int get button();

  int get clientX();

  int get clientY();

  bool get ctrlKey();

  Node get fromElement();

  bool get metaKey();

  int get offsetX();

  int get offsetY();

  EventTarget get relatedTarget();

  int get screenX();

  int get screenY();

  bool get shiftKey();

  Node get toElement();

  int get x();

  int get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface MutationEvent extends Event default MutationEventWrappingImplementation {

  MutationEvent(String type, Node relatedNode, String prevValue,
      String newValue, String attrName, int attrChange, [bool canBubble,
      bool cancelable]);

  static final int ADDITION = 2;

  static final int MODIFICATION = 1;

  static final int REMOVAL = 3;

  int get attrChange();

  String get attrName();

  String get newValue();

  String get prevValue();

  Node get relatedNode();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jacobr): stop extending eventTarget.
interface Node extends EventTarget {

  NodeList get nodes();

  // TODO: The type of value should be Collection<Node>. See http://b/5392897
  void set nodes(value);

  Node get nextNode();

  Document get document();

  Node get parent();

  Node get previousNode();

  String get text();

  void set text(String value);

  Node replaceWith(Node otherNode);

  Node remove();

  bool contains(Node otherNode);

  // TODO(jacobr): remove when/if Array supports a method similar to
  // insertBefore or we switch NodeList to implement LinkedList rather than
  // array.
  Node insertBefore(Node newChild, Node refChild);

  Node clone(bool deep);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface NodeList extends List<Node> {
  Node get first();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface Notification extends EventTarget {

  String get dir();

  void set dir(String value);

  EventListener get onclick();

  void set onclick(EventListener value);

  EventListener get onclose();

  void set onclose(EventListener value);

  EventListener get ondisplay();

  void set ondisplay(EventListener value);

  EventListener get onerror();

  void set onerror(EventListener value);

  String get replaceId();

  void set replaceId(String value);

  void cancel();

  void show();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface ObjectElement extends Element {

  String get align();

  void set align(String value);

  String get archive();

  void set archive(String value);

  String get border();

  void set border(String value);

  String get code();

  void set code(String value);

  String get codeBase();

  void set codeBase(String value);

  String get codeType();

  void set codeType(String value);

  Document get contentDocument();

  String get data();

  void set data(String value);

  bool get declare();

  void set declare(bool value);

  FormElement get form();

  String get height();

  void set height(String value);

  int get hspace();

  void set hspace(int value);

  String get name();

  void set name(String value);

  String get standby();

  void set standby(String value);

  String get type();

  void set type(String value);

  String get useMap();

  void set useMap(String value);

  String get validationMessage();

  ValidityState get validity();

  int get vspace();

  void set vspace(int value);

  String get width();

  void set width(String value);

  bool get willValidate();

  bool checkValidity();

  void setCustomValidity(String error);

  // Don't support getSVGDocument because the content document won't have all
  // the necessary patches to the prototype hierarchy under Frog.
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface OverflowEvent extends Event default OverflowEventWrappingImplementation {

  OverflowEvent(int orient, bool horizontalOverflow, bool verticalOverflow);

  static final int BOTH = 2;

  static final int HORIZONTAL = 0;

  static final int VERTICAL = 1;

  bool get horizontalOverflow();

  int get orient();

  bool get verticalOverflow();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface PageTransitionEvent extends Event default PageTransitionEventWrappingImplementation {

  PageTransitionEvent(String type, [bool canBubble, bool cancelable,
      bool persisted]);

  bool get persisted();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface PopStateEvent extends Event default PopStateEventWrappingImplementation {

  PopStateEvent(String type, Object state, [bool canBubble, bool cancelable]);

  String get state();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface ProgressEvent extends Event default ProgressEventWrappingImplementation {

  ProgressEvent(String type, int loaded, [bool canBubble, bool cancelable,
      bool lengthComputable, int total]);

  bool get lengthComputable();

  int get loaded();

  int get total();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef bool RequestAnimationFrameCallback(int time);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface SharedWorker extends AbstractWorker {

  MessagePort get port();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface StorageEvent extends Event default StorageEventWrappingImplementation {

  StorageEvent(String type, String key, String url, Storage storageArea,
      [bool canBubble, bool cancelable, String oldValue, String newValue]);

  String get key();

  String get newValue();

  String get oldValue();

  Storage get storageArea();

  String get url();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGDocument extends Document {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface SVGElement extends Element default SVGElementWrappingImplementation {

  SVGElement.tag(String tag);

  String get id();

  void set id(String value);

  SVGSVGElement get ownerSVGElement();

  SVGElement get viewportElement();

  String get xmlbase();

  void set xmlbase(String value);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface SVGElementInstance extends EventTarget {

  SVGElementInstanceList get childNodes();

  SVGElement get correspondingElement();

  SVGUseElement get correspondingUseElement();

  SVGElementInstance get firstChild();

  SVGElementInstance get lastChild();

  SVGElementInstance get nextSibling();

  SVGElementInstance get parentNode();

  SVGElementInstance get previousSibling();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface SVGSVGElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGLocatable, SVGFitToViewBox, SVGZoomAndPan
    default SVGSVGElementWrappingImplementation {

  SVGSVGElement();

  String get contentScriptType();

  void set contentScriptType(String value);

  String get contentStyleType();

  void set contentStyleType(String value);

  num get currentScale();

  void set currentScale(num value);

  SVGPoint get currentTranslate();

  SVGAnimatedLength get height();

  num get pixelUnitToMillimeterX();

  num get pixelUnitToMillimeterY();

  num get screenPixelToMillimeterX();

  num get screenPixelToMillimeterY();

  bool get useCurrentView();

  void set useCurrentView(bool value);

  SVGRect get viewport();

  SVGAnimatedLength get width();

  SVGAnimatedLength get x();

  SVGAnimatedLength get y();

  bool animationsPaused();

  bool checkEnclosure(SVGElement element, SVGRect rect);

  bool checkIntersection(SVGElement element, SVGRect rect);

  SVGAngle createSVGAngle();

  SVGLength createSVGLength();

  SVGMatrix createSVGMatrix();

  SVGNumber createSVGNumber();

  SVGPoint createSVGPoint();

  SVGRect createSVGRect();

  SVGTransform createSVGTransform();

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix);

  void deselectAll();

  void forceRedraw();

  num getCurrentTime();

  Element getElementById(String elementId);

  ElementList getEnclosureList(SVGRect rect, SVGElement referenceElement);

  ElementList getIntersectionList(SVGRect rect, SVGElement referenceElement);

  void pauseAnimations();

  void setCurrentTime(num seconds);

  int suspendRedraw(int maxWaitMilliseconds);

  void unpauseAnimations();

  void unsuspendRedraw(int suspendHandleId);

  void unsuspendRedrawAll();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface Text extends CharacterData default TextWrappingImplementation {

  Text(String content);

  String get wholeText();

  Text replaceWholeText([String content]);

  Text splitText([int offset]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface TextEvent extends UIEvent default TextEventWrappingImplementation {

  TextEvent(String type, Window view, String data, [bool canBubble,
      bool cancelable]);

  String get data();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef void TimeoutHandler();
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface TouchEvent extends UIEvent default TouchEventWrappingImplementation {

  TouchEvent(TouchList touches, TouchList targetTouches,
      TouchList changedTouches, String type, Window view, int screenX,
      int screenY, int clientX, int clientY, [bool ctrlKey, bool altKey,
      bool shiftKey, bool metaKey]);

  bool get altKey();

  TouchList get changedTouches();

  bool get ctrlKey();

  bool get metaKey();

  bool get shiftKey();

  TouchList get targetTouches();

  TouchList get touches();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface TransitionEvent extends Event default TransitionEventWrappingImplementation {

  TransitionEvent(String type, String propertyName, double elapsedTime,
      [bool canBubble, bool cancelable]);

  num get elapsedTime();

  String get propertyName();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface UIEvent extends Event default UIEventWrappingImplementation {

  UIEvent(String type, Window view, int detail, [bool canBubble,
      bool cancelable]);

  int get charCode();

  int get detail();

  int get keyCode();

  int get layerX();

  int get layerY();

  int get pageX();

  int get pageY();

  Window get view();

  int get which();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface WebSocket extends EventTarget {

  static final int CLOSED = 3;

  static final int CLOSING = 2;

  static final int CONNECTING = 0;

  static final int OPEN = 1;

  String get URL();

  String get binaryType();

  void set binaryType(String value);

  int get bufferedAmount();

  EventListener get onclose();

  void set onclose(EventListener value);

  EventListener get onerror();

  void set onerror(EventListener value);

  EventListener get onmessage();

  void set onmessage(EventListener value);

  EventListener get onopen();

  void set onopen(EventListener value);

  String get protocol();

  int get readyState();

  void close();

  bool send(String data);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface WheelEvent extends UIEvent default WheelEventWrappingImplementation {

  WheelEvent(int deltaX, int deltaY, Window view, int screenX, int screenY,
      int clientX, int clientY, [bool ctrlKey, bool altKey, bool shiftKey,
      bool metaKey]);

  bool get altKey();

  int get clientX();

  int get clientY();

  bool get ctrlKey();

  bool get metaKey();

  int get offsetX();

  int get offsetY();

  int get screenX();

  int get screenY();

  bool get shiftKey();

  int get wheelDelta();

  int get wheelDeltaX();

  int get wheelDeltaY();

  int get x();

  int get y();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface WindowEvents extends Events {
  EventListenerList get abort();
  EventListenerList get beforeUnload();
  EventListenerList get blur();
  EventListenerList get canPlay();
  EventListenerList get canPlayThrough();
  EventListenerList get change();
  EventListenerList get click();
  EventListenerList get contextMenu();
  EventListenerList get dblClick();
  EventListenerList get deviceMotion();
  EventListenerList get deviceOrientation();
  EventListenerList get drag();
  EventListenerList get dragEnd();
  EventListenerList get dragEnter();
  EventListenerList get dragLeave();
  EventListenerList get dragOver();
  EventListenerList get dragStart();
  EventListenerList get drop();
  EventListenerList get durationChange();
  EventListenerList get emptied();
  EventListenerList get ended();
  EventListenerList get error();
  EventListenerList get focus();
  EventListenerList get hashChange();
  EventListenerList get input();
  EventListenerList get invalid();
  EventListenerList get keyDown();
  EventListenerList get keyPress();
  EventListenerList get keyUp();
  EventListenerList get load();
  EventListenerList get loadedData();
  EventListenerList get loadedMetaData();
  EventListenerList get loadStart();
  EventListenerList get message();
  EventListenerList get mouseDown();
  EventListenerList get mouseMove();
  EventListenerList get mouseOut();
  EventListenerList get mouseOver();
  EventListenerList get mouseUp();
  EventListenerList get mouseWheel();
  EventListenerList get offline();
  EventListenerList get online();
  EventListenerList get pageHide();
  EventListenerList get pageShow();
  EventListenerList get pause();
  EventListenerList get play();
  EventListenerList get playing();
  EventListenerList get popState();
  EventListenerList get progress();
  EventListenerList get rateChange();
  EventListenerList get reset();
  EventListenerList get resize();
  EventListenerList get scroll();
  EventListenerList get search();
  EventListenerList get seeked();
  EventListenerList get seeking();
  EventListenerList get select();
  EventListenerList get stalled();
  EventListenerList get storage();
  EventListenerList get submit();
  EventListenerList get suspend();
  EventListenerList get timeUpdate();
  EventListenerList get touchCancel();
  EventListenerList get touchEnd();
  EventListenerList get touchMove();
  EventListenerList get touchStart();
  EventListenerList get unLoad();
  EventListenerList get volumeChange();
  EventListenerList get waiting();
  EventListenerList get animationEnd();
  EventListenerList get animationIteration();
  EventListenerList get animationStart();
  EventListenerList get transitionEnd();
  EventListenerList get contentLoaded();
}

interface Window extends EventTarget {

  DOMApplicationCache get applicationCache();

  Navigator get clientInformation();

  void set clientInformation(Navigator value);

  bool get closed();

  Console get console();

  void set console(Console value);

  Crypto get crypto();

  String get defaultStatus();

  void set defaultStatus(String value);

  num get devicePixelRatio();

  void set devicePixelRatio(num value);

  Document get document();

  Event get event();

  void set event(Event value);

  Element get frameElement();

  Window get frames();

  void set frames(Window value);

  History get history();

  void set history(History value);

  int get innerHeight();

  void set innerHeight(int value);

  int get innerWidth();

  void set innerWidth(int value);

  int get length();

  void set length(int value);

  Storage get localStorage();

  Location get location();

  void set location(Location value);

  BarInfo get locationbar();

  void set locationbar(BarInfo value);

  BarInfo get menubar();

  void set menubar(BarInfo value);

  String get name();

  void set name(String value);

  Navigator get navigator();

  void set navigator(Navigator value);

  bool get offscreenBuffering();

  void set offscreenBuffering(bool value);

  Window get opener();

  void set opener(Window value);

  int get outerHeight();

  void set outerHeight(int value);

  int get outerWidth();

  void set outerWidth(int value);

  int get pageXOffset();

  int get pageYOffset();

  Window get parent();

  void set parent(Window value);

  BarInfo get personalbar();

  void set personalbar(BarInfo value);

  Screen get screen();

  void set screen(Screen value);

  int get screenLeft();

  void set screenLeft(int value);

  int get screenTop();

  void set screenTop(int value);

  int get screenX();

  void set screenX(int value);

  int get screenY();

  void set screenY(int value);

  int get scrollX();

  void set scrollX(int value);

  int get scrollY();

  void set scrollY(int value);

  BarInfo get scrollbars();

  void set scrollbars(BarInfo value);

  Window get self();

  void set self(Window value);

  Storage get sessionStorage();

  String get status();

  void set status(String value);

  BarInfo get statusbar();

  void set statusbar(BarInfo value);

  StyleMedia get styleMedia();

  BarInfo get toolbar();

  void set toolbar(BarInfo value);

  Window get top();

  void set top(Window value);

  NotificationCenter get webkitNotifications();

  void alert([String message]);

  String atob([String string]);

  void blur();

  String btoa([String string]);

  void captureEvents();

  void clearInterval([int handle]);

  void clearTimeout([int handle]);

  void close();

  bool confirm([String message]);

  FileReader createFileReader();

  bool find([String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog]);

  void focus();

  DOMSelection getSelection();

  MediaQueryList matchMedia(String query);

  void moveBy(num x, num y);

  void moveTo(num x, num y);

  Window open(String url, String target, [String features]);

  void postMessage(String message, [var messagePort, String targetOrigin]);

  void print();

  String prompt([String message, String defaultValue]);

  void releaseEvents();

  void resizeBy(num x, num y);

  void resizeTo(num width, num height);

  void scroll(int x, int y);

  void scrollBy(int x, int y);

  void scrollTo(int x, int y);

  int setInterval(TimeoutHandler handler, int timeout);

  int setTimeout(TimeoutHandler handler, int timeout);

  Object showModalDialog(String url, [Object dialogArgs, String featureArgs]);

  void stop();

  void webkitCancelRequestAnimationFrame(int id);

  // TODO(jacobr): make these return Future<Point>.
  Point webkitConvertPointFromNodeToPage([Node node, Point p]);

  Point webkitConvertPointFromPageToNode([Node node, Point p]);

  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback, [Element element]);

  /**
   * Executes a [callback] after the next batch of browser layout measurements
   * has completed or would have completed if any browser layout measurements
   * had been scheduled.
   */
  void requestLayoutFrame(TimeoutHandler callback);

  // Window open(String url, String target, WindowSpec features);

  WindowEvents get on();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface WorkerEvents extends AbstractWorkerEvents {
  EventListenerList get message();
}

interface Worker extends AbstractWorker {

  void postMessage(String message, [MessagePort messagePort]);

  void terminate();

  WorkerEvents get on();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface XMLHttpRequestEvents extends Events {
  EventListenerList get abort();
  EventListenerList get error();
  EventListenerList get load();
  EventListenerList get loadStart();
  EventListenerList get progress();
  EventListenerList get readyStateChange();
}

interface XMLHttpRequest extends EventTarget default XMLHttpRequestWrappingImplementation {
  static final int DONE = 4;

  static final int HEADERS_RECEIVED = 2;

  static final int LOADING = 3;

  static final int OPENED = 1;

  static final int UNSENT = 0;

  XMLHttpRequest();

  // TODO(rnystrom): This name should just be "get" which is valid in Dart, but
  // not correctly implemented yet. (b/4970173)
  XMLHttpRequest.getTEMPNAME(String url, onSuccess(XMLHttpRequest request));

  int get readyState();

  String get responseText();

  String get responseType();

  void set responseType(String value);

  Document get responseXML();

  int get status();

  String get statusText();

  XMLHttpRequestUpload get upload();

  bool get withCredentials();

  void set withCredentials(bool value);

  void abort();

  String getAllResponseHeaders();

  String getResponseHeader(String header);

  void open(String method, String url, bool async, [String user, String password]);

  void overrideMimeType(String mime);

  void send([String data]);

  void setRequestHeader(String header, String value);

  XMLHttpRequestEvents get on();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface XMLHttpRequestProgressEvent extends ProgressEvent default XMLHttpRequestProgressEventWrappingImplementation {

  XMLHttpRequestProgressEvent(String type, int loaded, [bool canBubble,
      bool cancelable, bool lengthComputable, int total]);

  int get position();

  int get totalSize();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface XMLHttpRequestUploadEvents extends Events {
  EventListenerList get abort();
  EventListenerList get error();
  EventListenerList get load();
  EventListenerList get loadStart();
  EventListenerList get progress();
}

interface XMLHttpRequestUpload extends EventTarget {
  XMLHttpRequestUploadEvents get on();
}

</script>
<script type="application//inert" id="release_htmlimpl_dart">
#library('htmlimpl');

#import('dart:dom', prefix:'dom');
#import('dart:html');
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// DO NOT EDIT
// Auto-generated Dart HTML library.






// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AnchorElementWrappingImplementation extends ElementWrappingImplementation implements AnchorElement {
  AnchorElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get accessKey() { return _ptr.accessKey; }

  void set accessKey(String value) { _ptr.accessKey = value; }

  String get charset() { return _ptr.charset; }

  void set charset(String value) { _ptr.charset = value; }

  String get coords() { return _ptr.coords; }

  void set coords(String value) { _ptr.coords = value; }

  String get download() { return _ptr.download; }

  void set download(String value) { _ptr.download = value; }

  String get hash() { return _ptr.hash; }

  void set hash(String value) { _ptr.hash = value; }

  String get host() { return _ptr.host; }

  void set host(String value) { _ptr.host = value; }

  String get hostname() { return _ptr.hostname; }

  void set hostname(String value) { _ptr.hostname = value; }

  String get href() { return _ptr.href; }

  void set href(String value) { _ptr.href = value; }

  String get hreflang() { return _ptr.hreflang; }

  void set hreflang(String value) { _ptr.hreflang = value; }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  String get origin() { return _ptr.origin; }

  String get pathname() { return _ptr.pathname; }

  void set pathname(String value) { _ptr.pathname = value; }

  String get ping() { return _ptr.ping; }

  void set ping(String value) { _ptr.ping = value; }

  String get port() { return _ptr.port; }

  void set port(String value) { _ptr.port = value; }

  String get protocol() { return _ptr.protocol; }

  void set protocol(String value) { _ptr.protocol = value; }

  String get rel() { return _ptr.rel; }

  void set rel(String value) { _ptr.rel = value; }

  String get rev() { return _ptr.rev; }

  void set rev(String value) { _ptr.rev = value; }

  String get search() { return _ptr.search; }

  void set search(String value) { _ptr.search = value; }

  String get shape() { return _ptr.shape; }

  void set shape(String value) { _ptr.shape = value; }

  String get target() { return _ptr.target; }

  void set target(String value) { _ptr.target = value; }

  String get text() { return _ptr.text; }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }

  String getParameter(String name) {
    return _ptr.getParameter(name);
  }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AnimationListWrappingImplementation extends DOMWrapperBase implements AnimationList {
  AnimationListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Animation item(int index) {
    return LevelDom.wrapAnimation(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AnimationWrappingImplementation extends DOMWrapperBase implements Animation {
  AnimationWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get delay() { return _ptr.delay; }

  int get direction() { return _ptr.direction; }

  num get duration() { return _ptr.duration; }

  num get elapsedTime() { return _ptr.elapsedTime; }

  void set elapsedTime(num value) { _ptr.elapsedTime = value; }

  bool get ended() { return _ptr.ended; }

  int get fillMode() { return _ptr.fillMode; }

  int get iterationCount() { return _ptr.iterationCount; }

  String get name() { return _ptr.name; }

  bool get paused() { return _ptr.paused; }

  void pause() {
    _ptr.pause();
    return;
  }

  void play() {
    _ptr.play();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AreaElementWrappingImplementation extends ElementWrappingImplementation implements AreaElement {
  AreaElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get accessKey() { return _ptr.accessKey; }

  void set accessKey(String value) { _ptr.accessKey = value; }

  String get alt() { return _ptr.alt; }

  void set alt(String value) { _ptr.alt = value; }

  String get coords() { return _ptr.coords; }

  void set coords(String value) { _ptr.coords = value; }

  String get hash() { return _ptr.hash; }

  String get host() { return _ptr.host; }

  String get hostname() { return _ptr.hostname; }

  String get href() { return _ptr.href; }

  void set href(String value) { _ptr.href = value; }

  bool get noHref() { return _ptr.noHref; }

  void set noHref(bool value) { _ptr.noHref = value; }

  String get pathname() { return _ptr.pathname; }

  String get ping() { return _ptr.ping; }

  void set ping(String value) { _ptr.ping = value; }

  String get port() { return _ptr.port; }

  String get protocol() { return _ptr.protocol; }

  String get search() { return _ptr.search; }

  String get shape() { return _ptr.shape; }

  void set shape(String value) { _ptr.shape = value; }

  String get target() { return _ptr.target; }

  void set target(String value) { _ptr.target = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ArrayBufferViewWrappingImplementation extends DOMWrapperBase implements ArrayBufferView {
  ArrayBufferViewWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  ArrayBuffer get buffer() { return LevelDom.wrapArrayBuffer(_ptr.buffer); }

  int get byteLength() { return _ptr.byteLength; }

  int get byteOffset() { return _ptr.byteOffset; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ArrayBufferWrappingImplementation extends DOMWrapperBase implements ArrayBuffer {
  ArrayBufferWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get byteLength() { return _ptr.byteLength; }

  ArrayBuffer slice(int begin, [int end]) {
    if (end === null) {
      return LevelDom.wrapArrayBuffer(_ptr.slice(begin));
    } else {
      return LevelDom.wrapArrayBuffer(_ptr.slice(begin, end));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioBufferSourceNodeWrappingImplementation extends AudioSourceNodeWrappingImplementation implements AudioBufferSourceNode {
  AudioBufferSourceNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  AudioBuffer get buffer() { return LevelDom.wrapAudioBuffer(_ptr.buffer); }

  void set buffer(AudioBuffer value) { _ptr.buffer = LevelDom.unwrap(value); }

  AudioGain get gain() { return LevelDom.wrapAudioGain(_ptr.gain); }

  bool get loop() { return _ptr.loop; }

  void set loop(bool value) { _ptr.loop = value; }

  bool get looping() { return _ptr.looping; }

  void set looping(bool value) { _ptr.looping = value; }

  AudioParam get playbackRate() { return LevelDom.wrapAudioParam(_ptr.playbackRate); }

  void noteGrainOn(num when, num grainOffset, num grainDuration) {
    _ptr.noteGrainOn(when, grainOffset, grainDuration);
    return;
  }

  void noteOff(num when) {
    _ptr.noteOff(when);
    return;
  }

  void noteOn(num when) {
    _ptr.noteOn(when);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioBufferWrappingImplementation extends DOMWrapperBase implements AudioBuffer {
  AudioBufferWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get duration() { return _ptr.duration; }

  num get gain() { return _ptr.gain; }

  void set gain(num value) { _ptr.gain = value; }

  int get length() { return _ptr.length; }

  int get numberOfChannels() { return _ptr.numberOfChannels; }

  num get sampleRate() { return _ptr.sampleRate; }

  Float32Array getChannelData(int channelIndex) {
    return LevelDom.wrapFloat32Array(_ptr.getChannelData(channelIndex));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioChannelMergerWrappingImplementation extends AudioNodeWrappingImplementation implements AudioChannelMerger {
  AudioChannelMergerWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioChannelSplitterWrappingImplementation extends AudioNodeWrappingImplementation implements AudioChannelSplitter {
  AudioChannelSplitterWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioContextWrappingImplementation extends DOMWrapperBase implements AudioContext {
  AudioContextWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get currentTime() { return _ptr.currentTime; }

  AudioDestinationNode get destination() { return LevelDom.wrapAudioDestinationNode(_ptr.destination); }

  AudioListener get listener() { return LevelDom.wrapAudioListener(_ptr.listener); }

  num get sampleRate() { return _ptr.sampleRate; }

  RealtimeAnalyserNode createAnalyser() {
    return LevelDom.wrapRealtimeAnalyserNode(_ptr.createAnalyser());
  }

  BiquadFilterNode createBiquadFilter() {
    return LevelDom.wrapBiquadFilterNode(_ptr.createBiquadFilter());
  }

  AudioBuffer createBuffer() {
    return LevelDom.wrapAudioBuffer(_ptr.createBuffer());
  }

  AudioBufferSourceNode createBufferSource() {
    return LevelDom.wrapAudioBufferSourceNode(_ptr.createBufferSource());
  }

  AudioChannelMerger createChannelMerger() {
    return LevelDom.wrapAudioChannelMerger(_ptr.createChannelMerger());
  }

  AudioChannelSplitter createChannelSplitter() {
    return LevelDom.wrapAudioChannelSplitter(_ptr.createChannelSplitter());
  }

  ConvolverNode createConvolver() {
    return LevelDom.wrapConvolverNode(_ptr.createConvolver());
  }

  DelayNode createDelayNode() {
    return LevelDom.wrapDelayNode(_ptr.createDelayNode());
  }

  DynamicsCompressorNode createDynamicsCompressor() {
    return LevelDom.wrapDynamicsCompressorNode(_ptr.createDynamicsCompressor());
  }

  AudioGainNode createGainNode() {
    return LevelDom.wrapAudioGainNode(_ptr.createGainNode());
  }

  HighPass2FilterNode createHighPass2Filter() {
    return LevelDom.wrapHighPass2FilterNode(_ptr.createHighPass2Filter());
  }

  JavaScriptAudioNode createJavaScriptNode(int bufferSize) {
    return LevelDom.wrapJavaScriptAudioNode(_ptr.createJavaScriptNode(bufferSize));
  }

  LowPass2FilterNode createLowPass2Filter() {
    return LevelDom.wrapLowPass2FilterNode(_ptr.createLowPass2Filter());
  }

  AudioPannerNode createPanner() {
    return LevelDom.wrapAudioPannerNode(_ptr.createPanner());
  }

  WaveShaperNode createWaveShaper() {
    return LevelDom.wrapWaveShaperNode(_ptr.createWaveShaper());
  }

  void decodeAudioData(ArrayBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback]) {
    if (errorCallback === null) {
      _ptr.decodeAudioData(LevelDom.unwrap(audioData), successCallback);
      return;
    } else {
      _ptr.decodeAudioData(LevelDom.unwrap(audioData), successCallback, errorCallback);
      return;
    }
  }

  void startRendering() {
    _ptr.startRendering();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioDestinationNodeWrappingImplementation extends AudioNodeWrappingImplementation implements AudioDestinationNode {
  AudioDestinationNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get numberOfChannels() { return _ptr.numberOfChannels; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioElementWrappingImplementation extends MediaElementWrappingImplementation implements AudioElement {
  AudioElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioGainNodeWrappingImplementation extends AudioNodeWrappingImplementation implements AudioGainNode {
  AudioGainNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  AudioGain get gain() { return LevelDom.wrapAudioGain(_ptr.gain); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioGainWrappingImplementation extends AudioParamWrappingImplementation implements AudioGain {
  AudioGainWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioListenerWrappingImplementation extends DOMWrapperBase implements AudioListener {
  AudioListenerWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get dopplerFactor() { return _ptr.dopplerFactor; }

  void set dopplerFactor(num value) { _ptr.dopplerFactor = value; }

  num get speedOfSound() { return _ptr.speedOfSound; }

  void set speedOfSound(num value) { _ptr.speedOfSound = value; }

  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp) {
    _ptr.setOrientation(x, y, z, xUp, yUp, zUp);
    return;
  }

  void setPosition(num x, num y, num z) {
    _ptr.setPosition(x, y, z);
    return;
  }

  void setVelocity(num x, num y, num z) {
    _ptr.setVelocity(x, y, z);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioNodeWrappingImplementation extends DOMWrapperBase implements AudioNode {
  AudioNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  AudioContext get context() { return LevelDom.wrapAudioContext(_ptr.context); }

  int get numberOfInputs() { return _ptr.numberOfInputs; }

  int get numberOfOutputs() { return _ptr.numberOfOutputs; }

  void connect(AudioNode destination, [int output, int input]) {
    if (output === null) {
      if (input === null) {
        _ptr.connect(LevelDom.unwrap(destination));
        return;
      }
    } else {
      if (input === null) {
        _ptr.connect(LevelDom.unwrap(destination), output);
        return;
      } else {
        _ptr.connect(LevelDom.unwrap(destination), output, input);
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void disconnect([int output]) {
    if (output === null) {
      _ptr.disconnect();
      return;
    } else {
      _ptr.disconnect(output);
      return;
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioPannerNodeWrappingImplementation extends AudioNodeWrappingImplementation implements AudioPannerNode {
  AudioPannerNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  AudioGain get coneGain() { return LevelDom.wrapAudioGain(_ptr.coneGain); }

  num get coneInnerAngle() { return _ptr.coneInnerAngle; }

  void set coneInnerAngle(num value) { _ptr.coneInnerAngle = value; }

  num get coneOuterAngle() { return _ptr.coneOuterAngle; }

  void set coneOuterAngle(num value) { _ptr.coneOuterAngle = value; }

  num get coneOuterGain() { return _ptr.coneOuterGain; }

  void set coneOuterGain(num value) { _ptr.coneOuterGain = value; }

  AudioGain get distanceGain() { return LevelDom.wrapAudioGain(_ptr.distanceGain); }

  int get distanceModel() { return _ptr.distanceModel; }

  void set distanceModel(int value) { _ptr.distanceModel = value; }

  num get maxDistance() { return _ptr.maxDistance; }

  void set maxDistance(num value) { _ptr.maxDistance = value; }

  int get panningModel() { return _ptr.panningModel; }

  void set panningModel(int value) { _ptr.panningModel = value; }

  num get refDistance() { return _ptr.refDistance; }

  void set refDistance(num value) { _ptr.refDistance = value; }

  num get rolloffFactor() { return _ptr.rolloffFactor; }

  void set rolloffFactor(num value) { _ptr.rolloffFactor = value; }

  void setOrientation(num x, num y, num z) {
    _ptr.setOrientation(x, y, z);
    return;
  }

  void setPosition(num x, num y, num z) {
    _ptr.setPosition(x, y, z);
    return;
  }

  void setVelocity(num x, num y, num z) {
    _ptr.setVelocity(x, y, z);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioParamWrappingImplementation extends DOMWrapperBase implements AudioParam {
  AudioParamWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get defaultValue() { return _ptr.defaultValue; }

  num get maxValue() { return _ptr.maxValue; }

  num get minValue() { return _ptr.minValue; }

  String get name() { return _ptr.name; }

  int get units() { return _ptr.units; }

  num get value() { return _ptr.value; }

  void set value(num value) { _ptr.value = value; }

  void cancelScheduledValues(num startTime) {
    _ptr.cancelScheduledValues(startTime);
    return;
  }

  void exponentialRampToValueAtTime(num value, num time) {
    _ptr.exponentialRampToValueAtTime(value, time);
    return;
  }

  void linearRampToValueAtTime(num value, num time) {
    _ptr.linearRampToValueAtTime(value, time);
    return;
  }

  void setTargetValueAtTime(num targetValue, num time, num timeConstant) {
    _ptr.setTargetValueAtTime(targetValue, time, timeConstant);
    return;
  }

  void setValueAtTime(num value, num time) {
    _ptr.setValueAtTime(value, time);
    return;
  }

  void setValueCurveAtTime(Float32Array values, num time, num duration) {
    _ptr.setValueCurveAtTime(LevelDom.unwrap(values), time, duration);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioProcessingEventWrappingImplementation extends EventWrappingImplementation implements AudioProcessingEvent {
  AudioProcessingEventWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  AudioBuffer get inputBuffer() { return LevelDom.wrapAudioBuffer(_ptr.inputBuffer); }

  AudioBuffer get outputBuffer() { return LevelDom.wrapAudioBuffer(_ptr.outputBuffer); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class AudioSourceNodeWrappingImplementation extends AudioNodeWrappingImplementation implements AudioSourceNode {
  AudioSourceNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class BRElementWrappingImplementation extends ElementWrappingImplementation implements BRElement {
  BRElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get clear() { return _ptr.clear; }

  void set clear(String value) { _ptr.clear = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class BarInfoWrappingImplementation extends DOMWrapperBase implements BarInfo {
  BarInfoWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get visible() { return _ptr.visible; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class BaseElementWrappingImplementation extends ElementWrappingImplementation implements BaseElement {
  BaseElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get href() { return _ptr.href; }

  void set href(String value) { _ptr.href = value; }

  String get target() { return _ptr.target; }

  void set target(String value) { _ptr.target = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class BiquadFilterNodeWrappingImplementation extends AudioNodeWrappingImplementation implements BiquadFilterNode {
  BiquadFilterNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  AudioParam get Q() { return LevelDom.wrapAudioParam(_ptr.Q); }

  AudioParam get frequency() { return LevelDom.wrapAudioParam(_ptr.frequency); }

  AudioParam get gain() { return LevelDom.wrapAudioParam(_ptr.gain); }

  int get type() { return _ptr.type; }

  void set type(int value) { _ptr.type = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class BlobBuilderWrappingImplementation extends DOMWrapperBase implements BlobBuilder {
  BlobBuilderWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void append(var blob_OR_value, [String endings]) {
    if (blob_OR_value is Blob) {
      if (endings === null) {
        _ptr.append(LevelDom.unwrapMaybePrimitive(blob_OR_value));
        return;
      }
    } else {
      if (blob_OR_value is String) {
        if (endings === null) {
          _ptr.append(LevelDom.unwrapMaybePrimitive(blob_OR_value));
          return;
        } else {
          _ptr.append(LevelDom.unwrapMaybePrimitive(blob_OR_value), endings);
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  Blob getBlob([String contentType]) {
    if (contentType === null) {
      return LevelDom.wrapBlob(_ptr.getBlob());
    } else {
      return LevelDom.wrapBlob(_ptr.getBlob(contentType));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class BlobWrappingImplementation extends DOMWrapperBase implements Blob {
  BlobWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get size() { return _ptr.size; }

  String get type() { return _ptr.type; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ButtonElementWrappingImplementation extends ElementWrappingImplementation implements ButtonElement {
  ButtonElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get accessKey() { return _ptr.accessKey; }

  void set accessKey(String value) { _ptr.accessKey = value; }

  bool get autofocus() { return _ptr.autofocus; }

  void set autofocus(bool value) { _ptr.autofocus = value; }

  bool get disabled() { return _ptr.disabled; }

  void set disabled(bool value) { _ptr.disabled = value; }

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  String get formAction() { return _ptr.formAction; }

  void set formAction(String value) { _ptr.formAction = value; }

  String get formEnctype() { return _ptr.formEnctype; }

  void set formEnctype(String value) { _ptr.formEnctype = value; }

  String get formMethod() { return _ptr.formMethod; }

  void set formMethod(String value) { _ptr.formMethod = value; }

  bool get formNoValidate() { return _ptr.formNoValidate; }

  void set formNoValidate(bool value) { _ptr.formNoValidate = value; }

  String get formTarget() { return _ptr.formTarget; }

  void set formTarget(String value) { _ptr.formTarget = value; }

  ElementList get labels() { return LevelDom.wrapElementList(_ptr.labels); }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  String get type() { return _ptr.type; }

  String get validationMessage() { return _ptr.validationMessage; }

  ValidityState get validity() { return LevelDom.wrapValidityState(_ptr.validity); }

  String get value() { return _ptr.value; }

  void set value(String value) { _ptr.value = value; }

  bool get willValidate() { return _ptr.willValidate; }

  bool checkValidity() {
    return _ptr.checkValidity();
  }

  void click() {
    _ptr.click();
    return;
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(error);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CDATASectionWrappingImplementation extends TextWrappingImplementation implements CDATASection {
  CDATASectionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSCharsetRuleWrappingImplementation extends CSSRuleWrappingImplementation implements CSSCharsetRule {
  CSSCharsetRuleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get encoding() { return _ptr.encoding; }

  void set encoding(String value) { _ptr.encoding = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSFontFaceRuleWrappingImplementation extends CSSRuleWrappingImplementation implements CSSFontFaceRule {
  CSSFontFaceRuleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSImportRuleWrappingImplementation extends CSSRuleWrappingImplementation implements CSSImportRule {
  CSSImportRuleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get href() { return _ptr.href; }

  MediaList get media() { return LevelDom.wrapMediaList(_ptr.media); }

  CSSStyleSheet get styleSheet() { return LevelDom.wrapCSSStyleSheet(_ptr.styleSheet); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSKeyframeRuleWrappingImplementation extends CSSRuleWrappingImplementation implements CSSKeyframeRule {
  CSSKeyframeRuleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get keyText() { return _ptr.keyText; }

  void set keyText(String value) { _ptr.keyText = value; }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSKeyframesRuleWrappingImplementation extends CSSRuleWrappingImplementation implements CSSKeyframesRule {
  CSSKeyframesRuleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  CSSRuleList get cssRules() { return LevelDom.wrapCSSRuleList(_ptr.cssRules); }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  void deleteRule(String key) {
    _ptr.deleteRule(key);
    return;
  }

  CSSKeyframeRule findRule(String key) {
    return LevelDom.wrapCSSKeyframeRule(_ptr.findRule(key));
  }

  void insertRule(String rule) {
    _ptr.insertRule(rule);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSMatrixWrappingImplementation extends DOMWrapperBase implements CSSMatrix {
  CSSMatrixWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
  factory CSSMatrixWrappingImplementation([String cssValue = null]) {

    if (cssValue === null) {
      return LevelDom.wrapCSSMatrix(new dom.WebKitCSSMatrix());
    } else {
      return LevelDom.wrapCSSMatrix(new dom.WebKitCSSMatrix(cssValue));
    }
  }

  num get a() { return _ptr.a; }

  void set a(num value) { _ptr.a = value; }

  num get b() { return _ptr.b; }

  void set b(num value) { _ptr.b = value; }

  num get c() { return _ptr.c; }

  void set c(num value) { _ptr.c = value; }

  num get d() { return _ptr.d; }

  void set d(num value) { _ptr.d = value; }

  num get e() { return _ptr.e; }

  void set e(num value) { _ptr.e = value; }

  num get f() { return _ptr.f; }

  void set f(num value) { _ptr.f = value; }

  num get m11() { return _ptr.m11; }

  void set m11(num value) { _ptr.m11 = value; }

  num get m12() { return _ptr.m12; }

  void set m12(num value) { _ptr.m12 = value; }

  num get m13() { return _ptr.m13; }

  void set m13(num value) { _ptr.m13 = value; }

  num get m14() { return _ptr.m14; }

  void set m14(num value) { _ptr.m14 = value; }

  num get m21() { return _ptr.m21; }

  void set m21(num value) { _ptr.m21 = value; }

  num get m22() { return _ptr.m22; }

  void set m22(num value) { _ptr.m22 = value; }

  num get m23() { return _ptr.m23; }

  void set m23(num value) { _ptr.m23 = value; }

  num get m24() { return _ptr.m24; }

  void set m24(num value) { _ptr.m24 = value; }

  num get m31() { return _ptr.m31; }

  void set m31(num value) { _ptr.m31 = value; }

  num get m32() { return _ptr.m32; }

  void set m32(num value) { _ptr.m32 = value; }

  num get m33() { return _ptr.m33; }

  void set m33(num value) { _ptr.m33 = value; }

  num get m34() { return _ptr.m34; }

  void set m34(num value) { _ptr.m34 = value; }

  num get m41() { return _ptr.m41; }

  void set m41(num value) { _ptr.m41 = value; }

  num get m42() { return _ptr.m42; }

  void set m42(num value) { _ptr.m42 = value; }

  num get m43() { return _ptr.m43; }

  void set m43(num value) { _ptr.m43 = value; }

  num get m44() { return _ptr.m44; }

  void set m44(num value) { _ptr.m44 = value; }

  CSSMatrix inverse() {
    return LevelDom.wrapCSSMatrix(_ptr.inverse());
  }

  CSSMatrix multiply(CSSMatrix secondMatrix) {
    return LevelDom.wrapCSSMatrix(_ptr.multiply(LevelDom.unwrap(secondMatrix)));
  }

  CSSMatrix rotate(num rotX, num rotY, num rotZ) {
    return LevelDom.wrapCSSMatrix(_ptr.rotate(rotX, rotY, rotZ));
  }

  CSSMatrix rotateAxisAngle(num x, num y, num z, num angle) {
    return LevelDom.wrapCSSMatrix(_ptr.rotateAxisAngle(x, y, z, angle));
  }

  CSSMatrix scale(num scaleX, num scaleY, num scaleZ) {
    return LevelDom.wrapCSSMatrix(_ptr.scale(scaleX, scaleY, scaleZ));
  }

  void setMatrixValue(String string) {
    _ptr.setMatrixValue(string);
    return;
  }

  CSSMatrix skewX(num angle) {
    return LevelDom.wrapCSSMatrix(_ptr.skewX(angle));
  }

  CSSMatrix skewY(num angle) {
    return LevelDom.wrapCSSMatrix(_ptr.skewY(angle));
  }

  String toString() {
    return _ptr.toString();
  }

  CSSMatrix translate(num x, num y, num z) {
    return LevelDom.wrapCSSMatrix(_ptr.translate(x, y, z));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSMediaRuleWrappingImplementation extends CSSRuleWrappingImplementation implements CSSMediaRule {
  CSSMediaRuleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  CSSRuleList get cssRules() { return LevelDom.wrapCSSRuleList(_ptr.cssRules); }

  MediaList get media() { return LevelDom.wrapMediaList(_ptr.media); }

  void deleteRule(int index) {
    _ptr.deleteRule(index);
    return;
  }

  int insertRule(String rule, int index) {
    return _ptr.insertRule(rule, index);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSPageRuleWrappingImplementation extends CSSRuleWrappingImplementation implements CSSPageRule {
  CSSPageRuleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get selectorText() { return _ptr.selectorText; }

  void set selectorText(String value) { _ptr.selectorText = value; }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSPrimitiveValueWrappingImplementation extends CSSValueWrappingImplementation implements CSSPrimitiveValue {
  CSSPrimitiveValueWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get primitiveType() { return _ptr.primitiveType; }

  Counter getCounterValue() {
    return LevelDom.wrapCounter(_ptr.getCounterValue());
  }

  num getFloatValue(int unitType) {
    return _ptr.getFloatValue(unitType);
  }

  RGBColor getRGBColorValue() {
    return LevelDom.wrapRGBColor(_ptr.getRGBColorValue());
  }

  Rect getRectValue() {
    return LevelDom.wrapRect(_ptr.getRectValue());
  }

  String getStringValue() {
    return _ptr.getStringValue();
  }

  void setFloatValue(int unitType, num floatValue) {
    _ptr.setFloatValue(unitType, floatValue);
    return;
  }

  void setStringValue(int stringType, String stringValue) {
    _ptr.setStringValue(stringType, stringValue);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSRuleListWrappingImplementation extends DOMWrapperBase implements CSSRuleList {
  CSSRuleListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  CSSRule item(int index) {
    return LevelDom.wrapCSSRule(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSRuleWrappingImplementation extends DOMWrapperBase implements CSSRule {
  CSSRuleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get cssText() { return _ptr.cssText; }

  void set cssText(String value) { _ptr.cssText = value; }

  CSSRule get parentRule() { return LevelDom.wrapCSSRule(_ptr.parentRule); }

  CSSStyleSheet get parentStyleSheet() { return LevelDom.wrapCSSStyleSheet(_ptr.parentStyleSheet); }

  int get type() { return _ptr.type; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSStyleRuleWrappingImplementation extends CSSRuleWrappingImplementation implements CSSStyleRule {
  CSSStyleRuleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get selectorText() { return _ptr.selectorText; }

  void set selectorText(String value) { _ptr.selectorText = value; }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSStyleSheetWrappingImplementation extends StyleSheetWrappingImplementation implements CSSStyleSheet {
  CSSStyleSheetWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  CSSRuleList get cssRules() { return LevelDom.wrapCSSRuleList(_ptr.cssRules); }

  CSSRule get ownerRule() { return LevelDom.wrapCSSRule(_ptr.ownerRule); }

  CSSRuleList get rules() { return LevelDom.wrapCSSRuleList(_ptr.rules); }

  int addRule(String selector, String style, [int index]) {
    if (index === null) {
      return _ptr.addRule(selector, style);
    } else {
      return _ptr.addRule(selector, style, index);
    }
  }

  void deleteRule(int index) {
    _ptr.deleteRule(index);
    return;
  }

  int insertRule(String rule, int index) {
    return _ptr.insertRule(rule, index);
  }

  void removeRule(int index) {
    _ptr.removeRule(index);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSTransformValueWrappingImplementation extends CSSValueListWrappingImplementation implements CSSTransformValue {
  CSSTransformValueWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get operationType() { return _ptr.operationType; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSUnknownRuleWrappingImplementation extends CSSRuleWrappingImplementation implements CSSUnknownRule {
  CSSUnknownRuleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSValueListWrappingImplementation extends CSSValueWrappingImplementation implements CSSValueList {
  CSSValueListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  CSSValue item(int index) {
    return LevelDom.wrapCSSValue(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CSSValueWrappingImplementation extends DOMWrapperBase implements CSSValue {
  CSSValueWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get cssText() { return _ptr.cssText; }

  void set cssText(String value) { _ptr.cssText = value; }

  int get cssValueType() { return _ptr.cssValueType; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CanvasElementWrappingImplementation extends ElementWrappingImplementation implements CanvasElement {
  CanvasElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get height() { return _ptr.height; }

  void set height(int value) { _ptr.height = value; }

  int get width() { return _ptr.width; }

  void set width(int value) { _ptr.width = value; }

  CanvasRenderingContext getContext([String contextId = null]) {
    if (contextId === null) {
      return LevelDom.wrapCanvasRenderingContext(_ptr.getContext());
    } else {
      return LevelDom.wrapCanvasRenderingContext(_ptr.getContext(contextId));
    }
  }

  String toDataURL(String type) {
    return _ptr.toDataURL(type);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CanvasGradientWrappingImplementation extends DOMWrapperBase implements CanvasGradient {
  CanvasGradientWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void addColorStop(num offset, String color) {
    _ptr.addColorStop(offset, color);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CanvasPatternWrappingImplementation extends DOMWrapperBase implements CanvasPattern {
  CanvasPatternWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CanvasPixelArrayWrappingImplementation extends DOMWrapperBase implements CanvasPixelArray {
  CanvasPixelArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  int operator[](int index) {
    return _ptr[index];
  }

  void operator[]=(int index, int value) {
    _ptr[index] = value;
  }

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CanvasRenderingContext2DWrappingImplementation extends CanvasRenderingContextWrappingImplementation implements CanvasRenderingContext2D {
  CanvasRenderingContext2DWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  Object get fillStyle() { return LevelDom.wrapObject(_ptr.fillStyle); }

  void set fillStyle(Object value) { _ptr.fillStyle = LevelDom.unwrapMaybePrimitive(value); }

  String get font() { return _ptr.font; }

  void set font(String value) { _ptr.font = value; }

  num get globalAlpha() { return _ptr.globalAlpha; }

  void set globalAlpha(num value) { _ptr.globalAlpha = value; }

  String get globalCompositeOperation() { return _ptr.globalCompositeOperation; }

  void set globalCompositeOperation(String value) { _ptr.globalCompositeOperation = value; }

  String get lineCap() { return _ptr.lineCap; }

  void set lineCap(String value) { _ptr.lineCap = value; }

  String get lineJoin() { return _ptr.lineJoin; }

  void set lineJoin(String value) { _ptr.lineJoin = value; }

  num get lineWidth() { return _ptr.lineWidth; }

  void set lineWidth(num value) { _ptr.lineWidth = value; }

  num get miterLimit() { return _ptr.miterLimit; }

  void set miterLimit(num value) { _ptr.miterLimit = value; }

  num get shadowBlur() { return _ptr.shadowBlur; }

  void set shadowBlur(num value) { _ptr.shadowBlur = value; }

  String get shadowColor() { return _ptr.shadowColor; }

  void set shadowColor(String value) { _ptr.shadowColor = value; }

  num get shadowOffsetX() { return _ptr.shadowOffsetX; }

  void set shadowOffsetX(num value) { _ptr.shadowOffsetX = value; }

  num get shadowOffsetY() { return _ptr.shadowOffsetY; }

  void set shadowOffsetY(num value) { _ptr.shadowOffsetY = value; }

  Object get strokeStyle() { return LevelDom.wrapObject(_ptr.strokeStyle); }

  void set strokeStyle(Object value) { _ptr.strokeStyle = LevelDom.unwrapMaybePrimitive(value); }

  String get textAlign() { return _ptr.textAlign; }

  void set textAlign(String value) { _ptr.textAlign = value; }

  String get textBaseline() { return _ptr.textBaseline; }

  void set textBaseline(String value) { _ptr.textBaseline = value; }

  List get webkitLineDash() { return _ptr.webkitLineDash; }

  void set webkitLineDash(List value) { _ptr.webkitLineDash = value; }

  num get webkitLineDashOffset() { return _ptr.webkitLineDashOffset; }

  void set webkitLineDashOffset(num value) { _ptr.webkitLineDashOffset = value; }

  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) {
    _ptr.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    return;
  }

  void arcTo(num x1, num y1, num x2, num y2, num radius) {
    _ptr.arcTo(x1, y1, x2, y2, radius);
    return;
  }

  void beginPath() {
    _ptr.beginPath();
    return;
  }

  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) {
    _ptr.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    return;
  }

  void clearRect(num x, num y, num width, num height) {
    _ptr.clearRect(x, y, width, height);
    return;
  }

  void clearShadow() {
    _ptr.clearShadow();
    return;
  }

  void clip() {
    _ptr.clip();
    return;
  }

  void closePath() {
    _ptr.closePath();
    return;
  }

  ImageData createImageData(var imagedata_OR_sw, [num sh = null]) {
    if (imagedata_OR_sw is ImageData) {
      if (sh === null) {
        return LevelDom.wrapImageData(_ptr.createImageData(LevelDom.unwrapMaybePrimitive(imagedata_OR_sw)));
      }
    } else {
      if (imagedata_OR_sw is num) {
        return LevelDom.wrapImageData(_ptr.createImageData(LevelDom.unwrapMaybePrimitive(imagedata_OR_sw), sh));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1) {
    return LevelDom.wrapCanvasGradient(_ptr.createLinearGradient(x0, y0, x1, y1));
  }

  CanvasPattern createPattern(var canvas_OR_image, String repetitionType) {
    if (canvas_OR_image is CanvasElement) {
      return LevelDom.wrapCanvasPattern(_ptr.createPattern(LevelDom.unwrapMaybePrimitive(canvas_OR_image), repetitionType));
    } else {
      if (canvas_OR_image is ImageElement) {
        return LevelDom.wrapCanvasPattern(_ptr.createPattern(LevelDom.unwrapMaybePrimitive(canvas_OR_image), repetitionType));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1) {
    return LevelDom.wrapCanvasGradient(_ptr.createRadialGradient(x0, y0, r0, x1, y1, r1));
  }

  void drawImage(var canvas_OR_image, num sx_OR_x, num sy_OR_y, [num sw_OR_width = null, num height_OR_sh = null, num dx = null, num dy = null, num dw = null, num dh = null]) {
    if (canvas_OR_image is ImageElement) {
      if (sw_OR_width === null) {
        if (height_OR_sh === null) {
          if (dx === null) {
            if (dy === null) {
              if (dw === null) {
                if (dh === null) {
                  _ptr.drawImage(LevelDom.unwrapMaybePrimitive(canvas_OR_image), sx_OR_x, sy_OR_y);
                  return;
                }
              }
            }
          }
        }
      } else {
        if (dx === null) {
          if (dy === null) {
            if (dw === null) {
              if (dh === null) {
                _ptr.drawImage(LevelDom.unwrapMaybePrimitive(canvas_OR_image), sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh);
                return;
              }
            }
          }
        } else {
          _ptr.drawImage(LevelDom.unwrapMaybePrimitive(canvas_OR_image), sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh);
          return;
        }
      }
    } else {
      if (canvas_OR_image is CanvasElement) {
        if (sw_OR_width === null) {
          if (height_OR_sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    _ptr.drawImage(LevelDom.unwrapMaybePrimitive(canvas_OR_image), sx_OR_x, sy_OR_y);
                    return;
                  }
                }
              }
            }
          }
        } else {
          if (dx === null) {
            if (dy === null) {
              if (dw === null) {
                if (dh === null) {
                  _ptr.drawImage(LevelDom.unwrapMaybePrimitive(canvas_OR_image), sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh);
                  return;
                }
              }
            }
          } else {
            _ptr.drawImage(LevelDom.unwrapMaybePrimitive(canvas_OR_image), sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh);
            return;
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void drawImageFromRect(ImageElement image, [num sx = null, num sy = null, num sw = null, num sh = null, num dx = null, num dy = null, num dw = null, num dh = null, String compositeOperation = null]) {
    if (sx === null) {
      if (sy === null) {
        if (sw === null) {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(LevelDom.unwrap(image));
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      if (sy === null) {
        if (sw === null) {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(LevelDom.unwrap(image), sx);
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (sw === null) {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(LevelDom.unwrap(image), sx, sy);
                      return;
                    }
                  }
                }
              }
            }
          }
        } else {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(LevelDom.unwrap(image), sx, sy, sw);
                      return;
                    }
                  }
                }
              }
            }
          } else {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(LevelDom.unwrap(image), sx, sy, sw, sh);
                      return;
                    }
                  }
                }
              }
            } else {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(LevelDom.unwrap(image), sx, sy, sw, sh, dx);
                      return;
                    }
                  }
                }
              } else {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(LevelDom.unwrap(image), sx, sy, sw, sh, dx, dy);
                      return;
                    }
                  }
                } else {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(LevelDom.unwrap(image), sx, sy, sw, sh, dx, dy, dw);
                      return;
                    }
                  } else {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(LevelDom.unwrap(image), sx, sy, sw, sh, dx, dy, dw, dh);
                      return;
                    } else {
                      _ptr.drawImageFromRect(LevelDom.unwrap(image), sx, sy, sw, sh, dx, dy, dw, dh, compositeOperation);
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void fill() {
    _ptr.fill();
    return;
  }

  void fillRect(num x, num y, num width, num height) {
    _ptr.fillRect(x, y, width, height);
    return;
  }

  void fillText(String text, num x, num y, [num maxWidth = null]) {
    if (maxWidth === null) {
      _ptr.fillText(text, x, y);
      return;
    } else {
      _ptr.fillText(text, x, y, maxWidth);
      return;
    }
  }

  ImageData getImageData(num sx, num sy, num sw, num sh) {
    return LevelDom.wrapImageData(_ptr.getImageData(sx, sy, sw, sh));
  }

  bool isPointInPath(num x, num y) {
    return _ptr.isPointInPath(x, y);
  }

  void lineTo(num x, num y) {
    _ptr.lineTo(x, y);
    return;
  }

  TextMetrics measureText(String text) {
    return LevelDom.wrapTextMetrics(_ptr.measureText(text));
  }

  void moveTo(num x, num y) {
    _ptr.moveTo(x, y);
    return;
  }

  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX = null, num dirtyY = null, num dirtyWidth = null, num dirtyHeight = null]) {
    if (dirtyX === null) {
      if (dirtyY === null) {
        if (dirtyWidth === null) {
          if (dirtyHeight === null) {
            _ptr.putImageData(LevelDom.unwrap(imagedata), dx, dy);
            return;
          }
        }
      }
    } else {
      _ptr.putImageData(LevelDom.unwrap(imagedata), dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void quadraticCurveTo(num cpx, num cpy, num x, num y) {
    _ptr.quadraticCurveTo(cpx, cpy, x, y);
    return;
  }

  void rect(num x, num y, num width, num height) {
    _ptr.rect(x, y, width, height);
    return;
  }

  void restore() {
    _ptr.restore();
    return;
  }

  void rotate(num angle) {
    _ptr.rotate(angle);
    return;
  }

  void save() {
    _ptr.save();
    return;
  }

  void scale(num sx, num sy) {
    _ptr.scale(sx, sy);
    return;
  }

  void setAlpha(num alpha) {
    _ptr.setAlpha(alpha);
    return;
  }

  void setCompositeOperation(String compositeOperation) {
    _ptr.setCompositeOperation(compositeOperation);
    return;
  }

  void setFillColor(var c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    if (c_OR_color_OR_grayLevel_OR_r is String) {
      if (alpha_OR_g_OR_m === null) {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setFillColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r));
              return;
            }
          }
        }
      } else {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setFillColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m);
              return;
            }
          }
        }
      }
    } else {
      if (c_OR_color_OR_grayLevel_OR_r is num) {
        if (alpha_OR_g_OR_m === null) {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setFillColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r));
                return;
              }
            }
          }
        } else {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setFillColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m);
                return;
              }
            }
          } else {
            if (a === null) {
              _ptr.setFillColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m, b_OR_y, a_OR_k);
              return;
            } else {
              _ptr.setFillColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m, b_OR_y, a_OR_k, a);
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setLineCap(String cap) {
    _ptr.setLineCap(cap);
    return;
  }

  void setLineJoin(String join) {
    _ptr.setLineJoin(join);
    return;
  }

  void setLineWidth(num width) {
    _ptr.setLineWidth(width);
    return;
  }

  void setMiterLimit(num limit) {
    _ptr.setMiterLimit(limit);
    return;
  }

  void setShadow(num width, num height, num blur, [var c_OR_color_OR_grayLevel_OR_r = null, num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    if (c_OR_color_OR_grayLevel_OR_r === null) {
      if (alpha_OR_g_OR_m === null) {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setShadow(width, height, blur);
              return;
            }
          }
        }
      }
    } else {
      if (c_OR_color_OR_grayLevel_OR_r is String) {
        if (alpha_OR_g_OR_m === null) {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setShadow(width, height, blur, LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r));
                return;
              }
            }
          }
        } else {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setShadow(width, height, blur, LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m);
                return;
              }
            }
          }
        }
      } else {
        if (c_OR_color_OR_grayLevel_OR_r is num) {
          if (alpha_OR_g_OR_m === null) {
            if (b_OR_y === null) {
              if (a_OR_k === null) {
                if (a === null) {
                  _ptr.setShadow(width, height, blur, LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r));
                  return;
                }
              }
            }
          } else {
            if (b_OR_y === null) {
              if (a_OR_k === null) {
                if (a === null) {
                  _ptr.setShadow(width, height, blur, LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m);
                  return;
                }
              }
            } else {
              if (a === null) {
                _ptr.setShadow(width, height, blur, LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m, b_OR_y, a_OR_k);
                return;
              } else {
                _ptr.setShadow(width, height, blur, LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m, b_OR_y, a_OR_k, a);
                return;
              }
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setStrokeColor(var c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    if (c_OR_color_OR_grayLevel_OR_r is String) {
      if (alpha_OR_g_OR_m === null) {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setStrokeColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r));
              return;
            }
          }
        }
      } else {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setStrokeColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m);
              return;
            }
          }
        }
      }
    } else {
      if (c_OR_color_OR_grayLevel_OR_r is num) {
        if (alpha_OR_g_OR_m === null) {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setStrokeColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r));
                return;
              }
            }
          }
        } else {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setStrokeColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m);
                return;
              }
            }
          } else {
            if (a === null) {
              _ptr.setStrokeColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m, b_OR_y, a_OR_k);
              return;
            } else {
              _ptr.setStrokeColor(LevelDom.unwrapMaybePrimitive(c_OR_color_OR_grayLevel_OR_r), alpha_OR_g_OR_m, b_OR_y, a_OR_k, a);
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy) {
    _ptr.setTransform(m11, m12, m21, m22, dx, dy);
    return;
  }

  void stroke() {
    _ptr.stroke();
    return;
  }

  void strokeRect(num x, num y, num width, num height, [num lineWidth = null]) {
    if (lineWidth === null) {
      _ptr.strokeRect(x, y, width, height);
      return;
    } else {
      _ptr.strokeRect(x, y, width, height, lineWidth);
      return;
    }
  }

  void strokeText(String text, num x, num y, [num maxWidth = null]) {
    if (maxWidth === null) {
      _ptr.strokeText(text, x, y);
      return;
    } else {
      _ptr.strokeText(text, x, y, maxWidth);
      return;
    }
  }

  void transform(num m11, num m12, num m21, num m22, num dx, num dy) {
    _ptr.transform(m11, m12, m21, m22, dx, dy);
    return;
  }

  void translate(num tx, num ty) {
    _ptr.translate(tx, ty);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CanvasRenderingContextWrappingImplementation extends DOMWrapperBase implements CanvasRenderingContext {
  CanvasRenderingContextWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  CanvasElement get canvas() { return LevelDom.wrapCanvasElement(_ptr.canvas); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CharacterDataWrappingImplementation extends NodeWrappingImplementation implements CharacterData {
  CharacterDataWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get data() { return _ptr.data; }

  void set data(String value) { _ptr.data = value; }

  int get length() { return _ptr.length; }

  void appendData(String data) {
    _ptr.appendData(data);
    return;
  }

  void deleteData(int offset, int length) {
    _ptr.deleteData(offset, length);
    return;
  }

  void insertData(int offset, String data) {
    _ptr.insertData(offset, data);
    return;
  }

  void replaceData(int offset, int length, String data) {
    _ptr.replaceData(offset, length, data);
    return;
  }

  String substringData(int offset, int length) {
    return _ptr.substringData(offset, length);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ClientRectListWrappingImplementation extends DOMWrapperBase implements ClientRectList {
  ClientRectListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  ClientRect item(int index) {
    return LevelDom.wrapClientRect(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ClientRectWrappingImplementation extends DOMWrapperBase implements ClientRect {
  ClientRectWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get bottom() { return _ptr.bottom; }

  num get height() { return _ptr.height; }

  num get left() { return _ptr.left; }

  num get right() { return _ptr.right; }

  num get top() { return _ptr.top; }

  num get width() { return _ptr.width; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ClipboardWrappingImplementation extends DOMWrapperBase implements Clipboard {
  ClipboardWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get dropEffect() { return _ptr.dropEffect; }

  void set dropEffect(String value) { _ptr.dropEffect = value; }

  String get effectAllowed() { return _ptr.effectAllowed; }

  void set effectAllowed(String value) { _ptr.effectAllowed = value; }

  FileList get files() { return LevelDom.wrapFileList(_ptr.files); }

  DataTransferItemList get items() { return LevelDom.wrapDataTransferItemList(_ptr.items); }

  List get types() { return _ptr.types; }

  void clearData([String type]) {
    if (type === null) {
      _ptr.clearData();
      return;
    } else {
      _ptr.clearData(type);
      return;
    }
  }

  void getData(String type) {
    _ptr.getData(type);
    return;
  }

  bool setData(String type, String data) {
    return _ptr.setData(type, data);
  }

  void setDragImage(ImageElement image, int x, int y) {
    _ptr.setDragImage(LevelDom.unwrap(image), x, y);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CommentWrappingImplementation extends CharacterDataWrappingImplementation implements Comment {
  CommentWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ConsoleWrappingImplementation extends DOMWrapperBase implements Console {
  ConsoleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void count() {
    _ptr.count();
    return;
  }

  void debug(Object arg) {
    _ptr.debug(LevelDom.unwrapMaybePrimitive(arg));
    return;
  }

  void dir() {
    _ptr.dir();
    return;
  }

  void dirxml() {
    _ptr.dirxml();
    return;
  }

  void error(Object arg) {
    _ptr.error(LevelDom.unwrapMaybePrimitive(arg));
    return;
  }

  void group() {
    _ptr.group();
    return;
  }

  void groupCollapsed() {
    _ptr.groupCollapsed();
    return;
  }

  void groupEnd() {
    _ptr.groupEnd();
    return;
  }

  void info(Object arg) {
    _ptr.info(LevelDom.unwrapMaybePrimitive(arg));
    return;
  }

  void log(Object arg) {
    _ptr.log(LevelDom.unwrapMaybePrimitive(arg));
    return;
  }

  void markTimeline() {
    _ptr.markTimeline();
    return;
  }

  void time(String title) {
    _ptr.time(title);
    return;
  }

  void timeEnd(String title) {
    _ptr.timeEnd(title);
    return;
  }

  void timeStamp() {
    _ptr.timeStamp();
    return;
  }

  void trace(Object arg) {
    _ptr.trace(LevelDom.unwrapMaybePrimitive(arg));
    return;
  }

  void warn(Object arg) {
    _ptr.warn(LevelDom.unwrapMaybePrimitive(arg));
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ConvolverNodeWrappingImplementation extends AudioNodeWrappingImplementation implements ConvolverNode {
  ConvolverNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  AudioBuffer get buffer() { return LevelDom.wrapAudioBuffer(_ptr.buffer); }

  void set buffer(AudioBuffer value) { _ptr.buffer = LevelDom.unwrap(value); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CoordinatesWrappingImplementation extends DOMWrapperBase implements Coordinates {
  CoordinatesWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get accuracy() { return _ptr.accuracy; }

  num get altitude() { return _ptr.altitude; }

  num get altitudeAccuracy() { return _ptr.altitudeAccuracy; }

  num get heading() { return _ptr.heading; }

  num get latitude() { return _ptr.latitude; }

  num get longitude() { return _ptr.longitude; }

  num get speed() { return _ptr.speed; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CounterWrappingImplementation extends DOMWrapperBase implements Counter {
  CounterWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get identifier() { return _ptr.identifier; }

  String get listStyle() { return _ptr.listStyle; }

  String get separator() { return _ptr.separator; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class CryptoWrappingImplementation extends DOMWrapperBase implements Crypto {
  CryptoWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void getRandomValues(ArrayBufferView array) {
    _ptr.getRandomValues(LevelDom.unwrap(array));
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DListElementWrappingImplementation extends ElementWrappingImplementation implements DListElement {
  DListElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get compact() { return _ptr.compact; }

  void set compact(bool value) { _ptr.compact = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMExceptionWrappingImplementation extends DOMWrapperBase implements DOMException {
  DOMExceptionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }

  String get message() { return _ptr.message; }

  String get name() { return _ptr.name; }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMFileSystemSyncWrappingImplementation extends DOMWrapperBase implements DOMFileSystemSync {
  DOMFileSystemSyncWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get name() { return _ptr.name; }

  DirectoryEntrySync get root() { return LevelDom.wrapDirectoryEntrySync(_ptr.root); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMFileSystemWrappingImplementation extends DOMWrapperBase implements DOMFileSystem {
  DOMFileSystemWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get name() { return _ptr.name; }

  DirectoryEntry get root() { return LevelDom.wrapDirectoryEntry(_ptr.root); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMFormDataWrappingImplementation extends DOMWrapperBase implements DOMFormData {
  DOMFormDataWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void append(String name, String value, String filename) {
    _ptr.append(name, value, filename);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMMimeTypeArrayWrappingImplementation extends DOMWrapperBase implements DOMMimeTypeArray {
  DOMMimeTypeArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  DOMMimeType item(int index) {
    return LevelDom.wrapDOMMimeType(_ptr.item(index));
  }

  DOMMimeType namedItem(String name) {
    return LevelDom.wrapDOMMimeType(_ptr.namedItem(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMMimeTypeWrappingImplementation extends DOMWrapperBase implements DOMMimeType {
  DOMMimeTypeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get description() { return _ptr.description; }

  DOMPlugin get enabledPlugin() { return LevelDom.wrapDOMPlugin(_ptr.enabledPlugin); }

  String get suffixes() { return _ptr.suffixes; }

  String get type() { return _ptr.type; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMParserWrappingImplementation extends DOMWrapperBase implements DOMParser {
  DOMParserWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  Document parseFromString(String str, String contentType) {
    return LevelDom.wrapDocument(_ptr.parseFromString(str, contentType));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMPluginArrayWrappingImplementation extends DOMWrapperBase implements DOMPluginArray {
  DOMPluginArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  DOMPlugin item(int index) {
    return LevelDom.wrapDOMPlugin(_ptr.item(index));
  }

  DOMPlugin namedItem(String name) {
    return LevelDom.wrapDOMPlugin(_ptr.namedItem(name));
  }

  void refresh(bool reload) {
    _ptr.refresh(reload);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMPluginWrappingImplementation extends DOMWrapperBase implements DOMPlugin {
  DOMPluginWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get description() { return _ptr.description; }

  String get filename() { return _ptr.filename; }

  int get length() { return _ptr.length; }

  String get name() { return _ptr.name; }

  DOMMimeType item(int index) {
    return LevelDom.wrapDOMMimeType(_ptr.item(index));
  }

  DOMMimeType namedItem(String name) {
    return LevelDom.wrapDOMMimeType(_ptr.namedItem(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMSelectionWrappingImplementation extends DOMWrapperBase implements DOMSelection {
  DOMSelectionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  Node get anchorNode() { return LevelDom.wrapNode(_ptr.anchorNode); }

  int get anchorOffset() { return _ptr.anchorOffset; }

  Node get baseNode() { return LevelDom.wrapNode(_ptr.baseNode); }

  int get baseOffset() { return _ptr.baseOffset; }

  Node get extentNode() { return LevelDom.wrapNode(_ptr.extentNode); }

  int get extentOffset() { return _ptr.extentOffset; }

  Node get focusNode() { return LevelDom.wrapNode(_ptr.focusNode); }

  int get focusOffset() { return _ptr.focusOffset; }

  bool get isCollapsed() { return _ptr.isCollapsed; }

  int get rangeCount() { return _ptr.rangeCount; }

  String get type() { return _ptr.type; }

  void addRange(Range range) {
    _ptr.addRange(LevelDom.unwrap(range));
    return;
  }

  void collapse(Node node, int index) {
    _ptr.collapse(LevelDom.unwrap(node), index);
    return;
  }

  void collapseToEnd() {
    _ptr.collapseToEnd();
    return;
  }

  void collapseToStart() {
    _ptr.collapseToStart();
    return;
  }

  bool containsNode(Node node, bool allowPartial) {
    return _ptr.containsNode(LevelDom.unwrap(node), allowPartial);
  }

  void deleteFromDocument() {
    _ptr.deleteFromDocument();
    return;
  }

  void empty() {
    _ptr.empty();
    return;
  }

  void extend(Node node, int offset) {
    _ptr.extend(LevelDom.unwrap(node), offset);
    return;
  }

  Range getRangeAt(int index) {
    return LevelDom.wrapRange(_ptr.getRangeAt(index));
  }

  void modify(String alter, String direction, String granularity) {
    _ptr.modify(alter, direction, granularity);
    return;
  }

  void removeAllRanges() {
    _ptr.removeAllRanges();
    return;
  }

  void selectAllChildren(Node node) {
    _ptr.selectAllChildren(LevelDom.unwrap(node));
    return;
  }

  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset) {
    _ptr.setBaseAndExtent(LevelDom.unwrap(baseNode), baseOffset, LevelDom.unwrap(extentNode), extentOffset);
    return;
  }

  void setPosition(Node node, int offset) {
    _ptr.setPosition(LevelDom.unwrap(node), offset);
    return;
  }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMSettableTokenListWrappingImplementation extends DOMTokenListWrappingImplementation implements DOMSettableTokenList {
  DOMSettableTokenListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get value() { return _ptr.value; }

  void set value(String value) { _ptr.value = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMTokenListWrappingImplementation extends DOMWrapperBase implements DOMTokenList {
  DOMTokenListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  void add(String token) {
    _ptr.add(token);
    return;
  }

  bool contains(String token) {
    return _ptr.contains(token);
  }

  String item(int index) {
    return _ptr.item(index);
  }

  void remove(String token) {
    _ptr.remove(token);
    return;
  }

  String toString() {
    return _ptr.toString();
  }

  bool toggle(String token) {
    return _ptr.toggle(token);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DOMURLWrappingImplementation extends DOMWrapperBase implements DOMURL {
  DOMURLWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String createObjectURL(Blob blob) {
    return _ptr.createObjectURL(LevelDom.unwrap(blob));
  }

  void revokeObjectURL(String url) {
    _ptr.revokeObjectURL(url);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DataListElementWrappingImplementation extends ElementWrappingImplementation implements DataListElement {
  DataListElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  ElementList get options() { return LevelDom.wrapElementList(_ptr.options); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DataTransferItemListWrappingImplementation extends DOMWrapperBase implements DataTransferItemList {
  DataTransferItemListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  void add(String data, String type) {
    _ptr.add(data, type);
    return;
  }

  void clear() {
    _ptr.clear();
    return;
  }

  DataTransferItem item(int index) {
    return LevelDom.wrapDataTransferItem(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DataTransferItemWrappingImplementation extends DOMWrapperBase implements DataTransferItem {
  DataTransferItemWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get kind() { return _ptr.kind; }

  String get type() { return _ptr.type; }

  Blob getAsFile() {
    return LevelDom.wrapBlob(_ptr.getAsFile());
  }

  void getAsString(StringCallback callback) {
    _ptr.getAsString(callback);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DataViewWrappingImplementation extends ArrayBufferViewWrappingImplementation implements DataView {
  DataViewWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num getFloat32(int byteOffset, [bool littleEndian]) {
    if (littleEndian === null) {
      return _ptr.getFloat32(byteOffset);
    } else {
      return _ptr.getFloat32(byteOffset, littleEndian);
    }
  }

  num getFloat64(int byteOffset, [bool littleEndian]) {
    if (littleEndian === null) {
      return _ptr.getFloat64(byteOffset);
    } else {
      return _ptr.getFloat64(byteOffset, littleEndian);
    }
  }

  int getInt16(int byteOffset, [bool littleEndian]) {
    if (littleEndian === null) {
      return _ptr.getInt16(byteOffset);
    } else {
      return _ptr.getInt16(byteOffset, littleEndian);
    }
  }

  int getInt32(int byteOffset, [bool littleEndian]) {
    if (littleEndian === null) {
      return _ptr.getInt32(byteOffset);
    } else {
      return _ptr.getInt32(byteOffset, littleEndian);
    }
  }

  int getInt8() {
    return _ptr.getInt8();
  }

  int getUint16(int byteOffset, [bool littleEndian]) {
    if (littleEndian === null) {
      return _ptr.getUint16(byteOffset);
    } else {
      return _ptr.getUint16(byteOffset, littleEndian);
    }
  }

  int getUint32(int byteOffset, [bool littleEndian]) {
    if (littleEndian === null) {
      return _ptr.getUint32(byteOffset);
    } else {
      return _ptr.getUint32(byteOffset, littleEndian);
    }
  }

  int getUint8() {
    return _ptr.getUint8();
  }

  void setFloat32(int byteOffset, num value, [bool littleEndian]) {
    if (littleEndian === null) {
      _ptr.setFloat32(byteOffset, value);
      return;
    } else {
      _ptr.setFloat32(byteOffset, value, littleEndian);
      return;
    }
  }

  void setFloat64(int byteOffset, num value, [bool littleEndian]) {
    if (littleEndian === null) {
      _ptr.setFloat64(byteOffset, value);
      return;
    } else {
      _ptr.setFloat64(byteOffset, value, littleEndian);
      return;
    }
  }

  void setInt16(int byteOffset, int value, [bool littleEndian]) {
    if (littleEndian === null) {
      _ptr.setInt16(byteOffset, value);
      return;
    } else {
      _ptr.setInt16(byteOffset, value, littleEndian);
      return;
    }
  }

  void setInt32(int byteOffset, int value, [bool littleEndian]) {
    if (littleEndian === null) {
      _ptr.setInt32(byteOffset, value);
      return;
    } else {
      _ptr.setInt32(byteOffset, value, littleEndian);
      return;
    }
  }

  void setInt8() {
    _ptr.setInt8();
    return;
  }

  void setUint16(int byteOffset, int value, [bool littleEndian]) {
    if (littleEndian === null) {
      _ptr.setUint16(byteOffset, value);
      return;
    } else {
      _ptr.setUint16(byteOffset, value, littleEndian);
      return;
    }
  }

  void setUint32(int byteOffset, int value, [bool littleEndian]) {
    if (littleEndian === null) {
      _ptr.setUint32(byteOffset, value);
      return;
    } else {
      _ptr.setUint32(byteOffset, value, littleEndian);
      return;
    }
  }

  void setUint8() {
    _ptr.setUint8();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DelayNodeWrappingImplementation extends AudioNodeWrappingImplementation implements DelayNode {
  DelayNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  AudioParam get delayTime() { return LevelDom.wrapAudioParam(_ptr.delayTime); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DetailsElementWrappingImplementation extends ElementWrappingImplementation implements DetailsElement {
  DetailsElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get open() { return _ptr.open; }

  void set open(bool value) { _ptr.open = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DirectoryEntrySyncWrappingImplementation extends EntrySyncWrappingImplementation implements DirectoryEntrySync {
  DirectoryEntrySyncWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  DirectoryReaderSync createReader() {
    return LevelDom.wrapDirectoryReaderSync(_ptr.createReader());
  }

  DirectoryEntrySync getDirectory(String path, Flags flags) {
    return LevelDom.wrapDirectoryEntrySync(_ptr.getDirectory(path, LevelDom.unwrap(flags)));
  }

  FileEntrySync getFile(String path, Flags flags) {
    return LevelDom.wrapFileEntrySync(_ptr.getFile(path, LevelDom.unwrap(flags)));
  }

  void removeRecursively() {
    _ptr.removeRecursively();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DirectoryEntryWrappingImplementation extends EntryWrappingImplementation implements DirectoryEntry {
  DirectoryEntryWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  DirectoryReader createReader() {
    return LevelDom.wrapDirectoryReader(_ptr.createReader());
  }

  void getDirectory(String path, [Flags flags, EntryCallback successCallback, ErrorCallback errorCallback]) {
    if (flags === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getDirectory(path);
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getDirectory(path, LevelDom.unwrap(flags));
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.getDirectory(path, LevelDom.unwrap(flags), successCallback);
          return;
        } else {
          _ptr.getDirectory(path, LevelDom.unwrap(flags), successCallback, LevelDom.unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void getFile(String path, [Flags flags, EntryCallback successCallback, ErrorCallback errorCallback]) {
    if (flags === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getFile(path);
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getFile(path, LevelDom.unwrap(flags));
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.getFile(path, LevelDom.unwrap(flags), successCallback);
          return;
        } else {
          _ptr.getFile(path, LevelDom.unwrap(flags), successCallback, LevelDom.unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void removeRecursively([VoidCallback successCallback, ErrorCallback errorCallback]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.removeRecursively();
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.removeRecursively(LevelDom.unwrap(successCallback));
        return;
      } else {
        _ptr.removeRecursively(LevelDom.unwrap(successCallback), LevelDom.unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DirectoryReaderSyncWrappingImplementation extends DOMWrapperBase implements DirectoryReaderSync {
  DirectoryReaderSyncWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  EntryArraySync readEntries() {
    return LevelDom.wrapEntryArraySync(_ptr.readEntries());
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DirectoryReaderWrappingImplementation extends DOMWrapperBase implements DirectoryReader {
  DirectoryReaderWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback]) {
    if (errorCallback === null) {
      _ptr.readEntries(successCallback);
      return;
    } else {
      _ptr.readEntries(successCallback, LevelDom.unwrap(errorCallback));
      return;
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DivElementWrappingImplementation extends ElementWrappingImplementation implements DivElement {
  DivElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class DynamicsCompressorNodeWrappingImplementation extends AudioNodeWrappingImplementation implements DynamicsCompressorNode {
  DynamicsCompressorNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ElementTimeControlWrappingImplementation extends DOMWrapperBase implements ElementTimeControl {
  ElementTimeControlWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void beginElement() {
    _ptr.beginElement();
    return;
  }

  void beginElementAt(num offset) {
    _ptr.beginElementAt(offset);
    return;
  }

  void endElement() {
    _ptr.endElement();
    return;
  }

  void endElementAt(num offset) {
    _ptr.endElementAt(offset);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class EmbedElementWrappingImplementation extends ElementWrappingImplementation implements EmbedElement {
  EmbedElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  String get height() { return _ptr.height; }

  void set height(String value) { _ptr.height = value; }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  String get src() { return _ptr.src; }

  void set src(String value) { _ptr.src = value; }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }

  String get width() { return _ptr.width; }

  void set width(String value) { _ptr.width = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class EntityReferenceWrappingImplementation extends NodeWrappingImplementation implements EntityReference {
  EntityReferenceWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class EntityWrappingImplementation extends NodeWrappingImplementation implements Entity {
  EntityWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get notationName() { return _ptr.notationName; }

  String get publicId() { return _ptr.publicId; }

  String get systemId() { return _ptr.systemId; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class EntryArraySyncWrappingImplementation extends DOMWrapperBase implements EntryArraySync {
  EntryArraySyncWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  EntrySync item(int index) {
    return LevelDom.wrapEntrySync(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class EntryArrayWrappingImplementation extends DOMWrapperBase implements EntryArray {
  EntryArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Entry item(int index) {
    return LevelDom.wrapEntry(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class EntrySyncWrappingImplementation extends DOMWrapperBase implements EntrySync {
  EntrySyncWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  DOMFileSystemSync get filesystem() { return LevelDom.wrapDOMFileSystemSync(_ptr.filesystem); }

  String get fullPath() { return _ptr.fullPath; }

  bool get isDirectory() { return _ptr.isDirectory; }

  bool get isFile() { return _ptr.isFile; }

  String get name() { return _ptr.name; }

  EntrySync copyTo(DirectoryEntrySync parent, String name) {
    return LevelDom.wrapEntrySync(_ptr.copyTo(LevelDom.unwrap(parent), name));
  }

  Metadata getMetadata() {
    return LevelDom.wrapMetadata(_ptr.getMetadata());
  }

  DirectoryEntrySync getParent() {
    return LevelDom.wrapDirectoryEntrySync(_ptr.getParent());
  }

  EntrySync moveTo(DirectoryEntrySync parent, String name) {
    return LevelDom.wrapEntrySync(_ptr.moveTo(LevelDom.unwrap(parent), name));
  }

  void remove() {
    _ptr.remove();
    return;
  }

  String toURL() {
    return _ptr.toURL();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class EntryWrappingImplementation extends DOMWrapperBase implements Entry {
  EntryWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  DOMFileSystem get filesystem() { return LevelDom.wrapDOMFileSystem(_ptr.filesystem); }

  String get fullPath() { return _ptr.fullPath; }

  bool get isDirectory() { return _ptr.isDirectory; }

  bool get isFile() { return _ptr.isFile; }

  String get name() { return _ptr.name; }

  void copyTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]) {
    if (name === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.copyTo(LevelDom.unwrap(parent));
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.copyTo(LevelDom.unwrap(parent), name);
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.copyTo(LevelDom.unwrap(parent), name, successCallback);
          return;
        } else {
          _ptr.copyTo(LevelDom.unwrap(parent), name, successCallback, LevelDom.unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void getMetadata([MetadataCallback successCallback, ErrorCallback errorCallback]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.getMetadata();
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.getMetadata(successCallback);
        return;
      } else {
        _ptr.getMetadata(successCallback, LevelDom.unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void getParent([EntryCallback successCallback, ErrorCallback errorCallback]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.getParent();
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.getParent(successCallback);
        return;
      } else {
        _ptr.getParent(successCallback, LevelDom.unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void moveTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]) {
    if (name === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.moveTo(LevelDom.unwrap(parent));
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.moveTo(LevelDom.unwrap(parent), name);
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.moveTo(LevelDom.unwrap(parent), name, successCallback);
          return;
        } else {
          _ptr.moveTo(LevelDom.unwrap(parent), name, successCallback, LevelDom.unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void remove([VoidCallback successCallback, ErrorCallback errorCallback]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.remove();
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.remove(LevelDom.unwrap(successCallback));
        return;
      } else {
        _ptr.remove(LevelDom.unwrap(successCallback), LevelDom.unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  String toURL() {
    return _ptr.toURL();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class EventExceptionWrappingImplementation extends DOMWrapperBase implements EventException {
  EventExceptionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }

  String get message() { return _ptr.message; }

  String get name() { return _ptr.name; }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FieldSetElementWrappingImplementation extends ElementWrappingImplementation implements FieldSetElement {
  FieldSetElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  String get validationMessage() { return _ptr.validationMessage; }

  ValidityState get validity() { return LevelDom.wrapValidityState(_ptr.validity); }

  bool get willValidate() { return _ptr.willValidate; }

  bool checkValidity() {
    return _ptr.checkValidity();
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(error);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FileEntrySyncWrappingImplementation extends EntrySyncWrappingImplementation implements FileEntrySync {
  FileEntrySyncWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  FileWriterSync createWriter() {
    return LevelDom.wrapFileWriterSync(_ptr.createWriter());
  }

  File file() {
    return LevelDom.wrapFile(_ptr.file());
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FileEntryWrappingImplementation extends EntryWrappingImplementation implements FileEntry {
  FileEntryWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback]) {
    if (errorCallback === null) {
      _ptr.createWriter(successCallback);
      return;
    } else {
      _ptr.createWriter(successCallback, LevelDom.unwrap(errorCallback));
      return;
    }
  }

  void file(FileCallback successCallback, [ErrorCallback errorCallback]) {
    if (errorCallback === null) {
      _ptr.file(successCallback);
      return;
    } else {
      _ptr.file(successCallback, LevelDom.unwrap(errorCallback));
      return;
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FileErrorWrappingImplementation extends DOMWrapperBase implements FileError {
  FileErrorWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FileExceptionWrappingImplementation extends DOMWrapperBase implements FileException {
  FileExceptionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }

  String get message() { return _ptr.message; }

  String get name() { return _ptr.name; }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FileListWrappingImplementation extends DOMWrapperBase implements FileList {
  FileListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  File item(int index) {
    return LevelDom.wrapFile(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FileReaderSyncWrappingImplementation extends DOMWrapperBase implements FileReaderSync {
  FileReaderSyncWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  ArrayBuffer readAsArrayBuffer(Blob blob) {
    return LevelDom.wrapArrayBuffer(_ptr.readAsArrayBuffer(LevelDom.unwrap(blob)));
  }

  String readAsBinaryString(Blob blob) {
    return _ptr.readAsBinaryString(LevelDom.unwrap(blob));
  }

  String readAsDataURL(Blob blob) {
    return _ptr.readAsDataURL(LevelDom.unwrap(blob));
  }

  String readAsText(Blob blob, [String encoding]) {
    if (encoding === null) {
      return _ptr.readAsText(LevelDom.unwrap(blob));
    } else {
      return _ptr.readAsText(LevelDom.unwrap(blob), encoding);
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FileReaderWrappingImplementation extends DOMWrapperBase implements FileReader {
  FileReaderWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  FileError get error() { return LevelDom.wrapFileError(_ptr.error); }

  int get readyState() { return _ptr.readyState; }

  String get result() { return _ptr.result; }

  void abort() {
    _ptr.abort();
    return;
  }

  void readAsArrayBuffer(Blob blob) {
    _ptr.readAsArrayBuffer(LevelDom.unwrap(blob));
    return;
  }

  void readAsBinaryString(Blob blob) {
    _ptr.readAsBinaryString(LevelDom.unwrap(blob));
    return;
  }

  void readAsDataURL(Blob blob) {
    _ptr.readAsDataURL(LevelDom.unwrap(blob));
    return;
  }

  void readAsText(Blob blob, [String encoding]) {
    if (encoding === null) {
      _ptr.readAsText(LevelDom.unwrap(blob));
      return;
    } else {
      _ptr.readAsText(LevelDom.unwrap(blob), encoding);
      return;
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FileWrappingImplementation extends BlobWrappingImplementation implements File {
  FileWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get fileName() { return _ptr.fileName; }

  int get fileSize() { return _ptr.fileSize; }

  Date get lastModifiedDate() { return _ptr.lastModifiedDate; }

  String get name() { return _ptr.name; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FileWriterSyncWrappingImplementation extends DOMWrapperBase implements FileWriterSync {
  FileWriterSyncWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  int get position() { return _ptr.position; }

  void seek(int position) {
    _ptr.seek(position);
    return;
  }

  void truncate(int size) {
    _ptr.truncate(size);
    return;
  }

  void write(Blob data) {
    _ptr.write(LevelDom.unwrap(data));
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FileWriterWrappingImplementation extends DOMWrapperBase implements FileWriter {
  FileWriterWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  FileError get error() { return LevelDom.wrapFileError(_ptr.error); }

  int get length() { return _ptr.length; }

  int get position() { return _ptr.position; }

  int get readyState() { return _ptr.readyState; }

  void abort() {
    _ptr.abort();
    return;
  }

  void seek(int position) {
    _ptr.seek(position);
    return;
  }

  void truncate(int size) {
    _ptr.truncate(size);
    return;
  }

  void write(Blob data) {
    _ptr.write(LevelDom.unwrap(data));
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FlagsWrappingImplementation extends DOMWrapperBase implements Flags {
  FlagsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get create() { return _ptr.create; }

  void set create(bool value) { _ptr.create = value; }

  bool get exclusive() { return _ptr.exclusive; }

  void set exclusive(bool value) { _ptr.exclusive = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class Float32ArrayWrappingImplementation extends ArrayBufferViewWrappingImplementation implements Float32Array {
  Float32ArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Float32Array subarray(int start, [int end]) {
    if (end === null) {
      return LevelDom.wrapFloat32Array(_ptr.subarray(start));
    } else {
      return LevelDom.wrapFloat32Array(_ptr.subarray(start, end));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class Float64ArrayWrappingImplementation extends ArrayBufferViewWrappingImplementation implements Float64Array {
  Float64ArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Float64Array subarray(int start, [int end]) {
    if (end === null) {
      return LevelDom.wrapFloat64Array(_ptr.subarray(start));
    } else {
      return LevelDom.wrapFloat64Array(_ptr.subarray(start, end));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FontElementWrappingImplementation extends ElementWrappingImplementation implements FontElement {
  FontElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get color() { return _ptr.color; }

  void set color(String value) { _ptr.color = value; }

  String get face() { return _ptr.face; }

  void set face(String value) { _ptr.face = value; }

  String get size() { return _ptr.size; }

  void set size(String value) { _ptr.size = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class FormElementWrappingImplementation extends ElementWrappingImplementation implements FormElement {
  FormElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get acceptCharset() { return _ptr.acceptCharset; }

  void set acceptCharset(String value) { _ptr.acceptCharset = value; }

  String get action() { return _ptr.action; }

  void set action(String value) { _ptr.action = value; }

  String get autocomplete() { return _ptr.autocomplete; }

  void set autocomplete(String value) { _ptr.autocomplete = value; }

  String get encoding() { return _ptr.encoding; }

  void set encoding(String value) { _ptr.encoding = value; }

  String get enctype() { return _ptr.enctype; }

  void set enctype(String value) { _ptr.enctype = value; }

  int get length() { return _ptr.length; }

  String get method() { return _ptr.method; }

  void set method(String value) { _ptr.method = value; }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  bool get noValidate() { return _ptr.noValidate; }

  void set noValidate(bool value) { _ptr.noValidate = value; }

  String get target() { return _ptr.target; }

  void set target(String value) { _ptr.target = value; }

  bool checkValidity() {
    return _ptr.checkValidity();
  }

  void reset() {
    _ptr.reset();
    return;
  }

  void submit() {
    _ptr.submit();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class GeolocationWrappingImplementation extends DOMWrapperBase implements Geolocation {
  GeolocationWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void clearWatch(int watchId) {
    _ptr.clearWatch(watchId);
    return;
  }

  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback]) {
    if (errorCallback === null) {
      _ptr.getCurrentPosition(successCallback);
      return;
    } else {
      _ptr.getCurrentPosition(successCallback, LevelDom.unwrap(errorCallback));
      return;
    }
  }

  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback]) {
    if (errorCallback === null) {
      return _ptr.watchPosition(successCallback);
    } else {
      return _ptr.watchPosition(successCallback, LevelDom.unwrap(errorCallback));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class GeopositionWrappingImplementation extends DOMWrapperBase implements Geoposition {
  GeopositionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  Coordinates get coords() { return LevelDom.wrapCoordinates(_ptr.coords); }

  int get timestamp() { return _ptr.timestamp; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class HRElementWrappingImplementation extends ElementWrappingImplementation implements HRElement {
  HRElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  bool get noShade() { return _ptr.noShade; }

  void set noShade(bool value) { _ptr.noShade = value; }

  String get size() { return _ptr.size; }

  void set size(String value) { _ptr.size = value; }

  String get width() { return _ptr.width; }

  void set width(String value) { _ptr.width = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class HTMLAllCollectionWrappingImplementation extends DOMWrapperBase implements HTMLAllCollection {
  HTMLAllCollectionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Node item(int index) {
    return LevelDom.wrapNode(_ptr.item(index));
  }

  Node namedItem(String name) {
    return LevelDom.wrapNode(_ptr.namedItem(name));
  }

  ElementList tags(String name) {
    return LevelDom.wrapElementList(_ptr.tags(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class HeadElementWrappingImplementation extends ElementWrappingImplementation implements HeadElement {
  HeadElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get profile() { return _ptr.profile; }

  void set profile(String value) { _ptr.profile = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class HeadingElementWrappingImplementation extends ElementWrappingImplementation implements HeadingElement {
  HeadingElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class HighPass2FilterNodeWrappingImplementation extends AudioNodeWrappingImplementation implements HighPass2FilterNode {
  HighPass2FilterNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  AudioParam get cutoff() { return LevelDom.wrapAudioParam(_ptr.cutoff); }

  AudioParam get resonance() { return LevelDom.wrapAudioParam(_ptr.resonance); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class HistoryWrappingImplementation extends DOMWrapperBase implements History {
  HistoryWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  void back() {
    _ptr.back();
    return;
  }

  void forward() {
    _ptr.forward();
    return;
  }

  void go(int distance) {
    _ptr.go(distance);
    return;
  }

  void pushState(Object data, String title, [String url]) {
    if (url === null) {
      _ptr.pushState(LevelDom.unwrapMaybePrimitive(data), title);
      return;
    } else {
      _ptr.pushState(LevelDom.unwrapMaybePrimitive(data), title, url);
      return;
    }
  }

  void replaceState(Object data, String title, [String url]) {
    if (url === null) {
      _ptr.replaceState(LevelDom.unwrapMaybePrimitive(data), title);
      return;
    } else {
      _ptr.replaceState(LevelDom.unwrapMaybePrimitive(data), title, url);
      return;
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBAnyWrappingImplementation extends DOMWrapperBase implements IDBAny {
  IDBAnyWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBCursorWithValueWrappingImplementation extends IDBCursorWrappingImplementation implements IDBCursorWithValue {
  IDBCursorWithValueWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  IDBAny get value() { return LevelDom.wrapIDBAny(_ptr.value); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBCursorWrappingImplementation extends DOMWrapperBase implements IDBCursor {
  IDBCursorWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get direction() { return _ptr.direction; }

  IDBKey get key() { return LevelDom.wrapIDBKey(_ptr.key); }

  IDBKey get primaryKey() { return LevelDom.wrapIDBKey(_ptr.primaryKey); }

  IDBAny get source() { return LevelDom.wrapIDBAny(_ptr.source); }

  void continueFunction([IDBKey key]) {
    if (key === null) {
      _ptr.continueFunction();
      return;
    } else {
      _ptr.continueFunction(LevelDom.unwrap(key));
      return;
    }
  }

  IDBRequest delete() {
    return LevelDom.wrapIDBRequest(_ptr.delete());
  }

  IDBRequest update(String value) {
    return LevelDom.wrapIDBRequest(_ptr.update(value));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBDatabaseErrorWrappingImplementation extends DOMWrapperBase implements IDBDatabaseError {
  IDBDatabaseErrorWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }

  void set code(int value) { _ptr.code = value; }

  String get message() { return _ptr.message; }

  void set message(String value) { _ptr.message = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBDatabaseExceptionWrappingImplementation extends DOMWrapperBase implements IDBDatabaseException {
  IDBDatabaseExceptionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }

  String get message() { return _ptr.message; }

  String get name() { return _ptr.name; }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBDatabaseWrappingImplementation extends DOMWrapperBase implements IDBDatabase {
  IDBDatabaseWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get name() { return _ptr.name; }

  String get version() { return _ptr.version; }

  void addEventListener(String type, EventListener listener, [bool useCapture]) {
    if (useCapture === null) {
      _ptr.addEventListener(type, LevelDom.unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(type, LevelDom.unwrap(listener), useCapture);
      return;
    }
  }

  void close() {
    _ptr.close();
    return;
  }

  IDBObjectStore createObjectStore(String name) {
    return LevelDom.wrapIDBObjectStore(_ptr.createObjectStore(name));
  }

  void deleteObjectStore(String name) {
    _ptr.deleteObjectStore(name);
    return;
  }

  bool dispatchEvent(Event evt) {
    return _ptr.dispatchEvent(LevelDom.unwrap(evt));
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture]) {
    if (useCapture === null) {
      _ptr.removeEventListener(type, LevelDom.unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(type, LevelDom.unwrap(listener), useCapture);
      return;
    }
  }

  IDBVersionChangeRequest setVersion(String version) {
    return LevelDom.wrapIDBVersionChangeRequest(_ptr.setVersion(version));
  }

  IDBTransaction transaction(String storeName, int mode) {
    return LevelDom.wrapIDBTransaction(_ptr.transaction(storeName, mode));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBFactoryWrappingImplementation extends DOMWrapperBase implements IDBFactory {
  IDBFactoryWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int cmp(IDBKey first, IDBKey second) {
    return _ptr.cmp(LevelDom.unwrap(first), LevelDom.unwrap(second));
  }

  IDBVersionChangeRequest deleteDatabase(String name) {
    return LevelDom.wrapIDBVersionChangeRequest(_ptr.deleteDatabase(name));
  }

  IDBRequest getDatabaseNames() {
    return LevelDom.wrapIDBRequest(_ptr.getDatabaseNames());
  }

  IDBRequest open(String name) {
    return LevelDom.wrapIDBRequest(_ptr.open(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBIndexWrappingImplementation extends DOMWrapperBase implements IDBIndex {
  IDBIndexWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get keyPath() { return _ptr.keyPath; }

  String get name() { return _ptr.name; }

  IDBObjectStore get objectStore() { return LevelDom.wrapIDBObjectStore(_ptr.objectStore); }

  bool get unique() { return _ptr.unique; }

  IDBRequest getObject(IDBKey key) {
    return LevelDom.wrapIDBRequest(_ptr.getObject(LevelDom.unwrap(key)));
  }

  IDBRequest getKey(IDBKey key) {
    return LevelDom.wrapIDBRequest(_ptr.getKey(LevelDom.unwrap(key)));
  }

  IDBRequest openCursor([IDBKeyRange range, int direction]) {
    if (range === null) {
      if (direction === null) {
        return LevelDom.wrapIDBRequest(_ptr.openCursor());
      }
    } else {
      if (direction === null) {
        return LevelDom.wrapIDBRequest(_ptr.openCursor(LevelDom.unwrap(range)));
      } else {
        return LevelDom.wrapIDBRequest(_ptr.openCursor(LevelDom.unwrap(range), direction));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  IDBRequest openKeyCursor([IDBKeyRange range, int direction]) {
    if (range === null) {
      if (direction === null) {
        return LevelDom.wrapIDBRequest(_ptr.openKeyCursor());
      }
    } else {
      if (direction === null) {
        return LevelDom.wrapIDBRequest(_ptr.openKeyCursor(LevelDom.unwrap(range)));
      } else {
        return LevelDom.wrapIDBRequest(_ptr.openKeyCursor(LevelDom.unwrap(range), direction));
      }
    }
    throw "Incorrect number or type of arguments";
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBKeyRangeWrappingImplementation extends DOMWrapperBase implements IDBKeyRange {
  IDBKeyRangeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  IDBKey get lower() { return LevelDom.wrapIDBKey(_ptr.lower); }

  bool get lowerOpen() { return _ptr.lowerOpen; }

  IDBKey get upper() { return LevelDom.wrapIDBKey(_ptr.upper); }

  bool get upperOpen() { return _ptr.upperOpen; }

  IDBKeyRange bound(IDBKey lower, IDBKey upper, [bool lowerOpen, bool upperOpen]) {
    if (lowerOpen === null) {
      if (upperOpen === null) {
        return LevelDom.wrapIDBKeyRange(_ptr.bound(LevelDom.unwrap(lower), LevelDom.unwrap(upper)));
      }
    } else {
      if (upperOpen === null) {
        return LevelDom.wrapIDBKeyRange(_ptr.bound(LevelDom.unwrap(lower), LevelDom.unwrap(upper), lowerOpen));
      } else {
        return LevelDom.wrapIDBKeyRange(_ptr.bound(LevelDom.unwrap(lower), LevelDom.unwrap(upper), lowerOpen, upperOpen));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  IDBKeyRange lowerBound(IDBKey bound_, [bool open]) {
    if (open === null) {
      return LevelDom.wrapIDBKeyRange(_ptr.lowerBound(LevelDom.unwrap(bound_)));
    } else {
      return LevelDom.wrapIDBKeyRange(_ptr.lowerBound(LevelDom.unwrap(bound_), open));
    }
  }

  IDBKeyRange only(IDBKey value) {
    return LevelDom.wrapIDBKeyRange(_ptr.only(LevelDom.unwrap(value)));
  }

  IDBKeyRange upperBound(IDBKey bound_, [bool open]) {
    if (open === null) {
      return LevelDom.wrapIDBKeyRange(_ptr.upperBound(LevelDom.unwrap(bound_)));
    } else {
      return LevelDom.wrapIDBKeyRange(_ptr.upperBound(LevelDom.unwrap(bound_), open));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBKeyWrappingImplementation extends DOMWrapperBase implements IDBKey {
  IDBKeyWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBObjectStoreWrappingImplementation extends DOMWrapperBase implements IDBObjectStore {
  IDBObjectStoreWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get keyPath() { return _ptr.keyPath; }

  String get name() { return _ptr.name; }

  IDBTransaction get transaction() { return LevelDom.wrapIDBTransaction(_ptr.transaction); }

  IDBRequest add(String value, [IDBKey key]) {
    if (key === null) {
      return LevelDom.wrapIDBRequest(_ptr.add(value));
    } else {
      return LevelDom.wrapIDBRequest(_ptr.add(value, LevelDom.unwrap(key)));
    }
  }

  IDBRequest clear() {
    return LevelDom.wrapIDBRequest(_ptr.clear());
  }

  IDBIndex createIndex(String name, String keyPath) {
    return LevelDom.wrapIDBIndex(_ptr.createIndex(name, keyPath));
  }

  IDBRequest delete(IDBKey key) {
    return LevelDom.wrapIDBRequest(_ptr.delete(LevelDom.unwrap(key)));
  }

  void deleteIndex(String name) {
    _ptr.deleteIndex(name);
    return;
  }

  IDBRequest getObject(IDBKey key) {
    return LevelDom.wrapIDBRequest(_ptr.getObject(LevelDom.unwrap(key)));
  }

  IDBIndex index(String name) {
    return LevelDom.wrapIDBIndex(_ptr.index(name));
  }

  IDBRequest openCursor([IDBKeyRange range, int direction]) {
    if (range === null) {
      if (direction === null) {
        return LevelDom.wrapIDBRequest(_ptr.openCursor());
      }
    } else {
      if (direction === null) {
        return LevelDom.wrapIDBRequest(_ptr.openCursor(LevelDom.unwrap(range)));
      } else {
        return LevelDom.wrapIDBRequest(_ptr.openCursor(LevelDom.unwrap(range), direction));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  IDBRequest put(String value, [IDBKey key]) {
    if (key === null) {
      return LevelDom.wrapIDBRequest(_ptr.put(value));
    } else {
      return LevelDom.wrapIDBRequest(_ptr.put(value, LevelDom.unwrap(key)));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBRequestWrappingImplementation extends DOMWrapperBase implements IDBRequest {
  IDBRequestWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get errorCode() { return _ptr.errorCode; }

  int get readyState() { return _ptr.readyState; }

  IDBAny get result() { return LevelDom.wrapIDBAny(_ptr.result); }

  IDBAny get source() { return LevelDom.wrapIDBAny(_ptr.source); }

  IDBTransaction get transaction() { return LevelDom.wrapIDBTransaction(_ptr.transaction); }

  String get webkitErrorMessage() { return _ptr.webkitErrorMessage; }

  void addEventListener(String type, EventListener listener, [bool useCapture]) {
    if (useCapture === null) {
      _ptr.addEventListener(type, LevelDom.unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(type, LevelDom.unwrap(listener), useCapture);
      return;
    }
  }

  bool dispatchEvent(Event evt) {
    return _ptr.dispatchEvent(LevelDom.unwrap(evt));
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture]) {
    if (useCapture === null) {
      _ptr.removeEventListener(type, LevelDom.unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(type, LevelDom.unwrap(listener), useCapture);
      return;
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBTransactionWrappingImplementation extends DOMWrapperBase implements IDBTransaction {
  IDBTransactionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  IDBDatabase get db() { return LevelDom.wrapIDBDatabase(_ptr.db); }

  int get mode() { return _ptr.mode; }

  void abort() {
    _ptr.abort();
    return;
  }

  void addEventListener(String type, EventListener listener, [bool useCapture]) {
    if (useCapture === null) {
      _ptr.addEventListener(type, LevelDom.unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(type, LevelDom.unwrap(listener), useCapture);
      return;
    }
  }

  bool dispatchEvent(Event evt) {
    return _ptr.dispatchEvent(LevelDom.unwrap(evt));
  }

  IDBObjectStore objectStore(String name) {
    return LevelDom.wrapIDBObjectStore(_ptr.objectStore(name));
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture]) {
    if (useCapture === null) {
      _ptr.removeEventListener(type, LevelDom.unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(type, LevelDom.unwrap(listener), useCapture);
      return;
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBVersionChangeEventWrappingImplementation extends EventWrappingImplementation implements IDBVersionChangeEvent {
  IDBVersionChangeEventWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get version() { return _ptr.version; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IDBVersionChangeRequestWrappingImplementation extends IDBRequestWrappingImplementation implements IDBVersionChangeRequest {
  IDBVersionChangeRequestWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class IFrameElementWrappingImplementation extends ElementWrappingImplementation implements IFrameElement {
  IFrameElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  Document get contentDocument() { return LevelDom.wrapDocument(_ptr.contentDocument); }

  Window get contentWindow() { return LevelDom.wrapWindow(_ptr.contentWindow); }

  String get frameBorder() { return _ptr.frameBorder; }

  void set frameBorder(String value) { _ptr.frameBorder = value; }

  String get height() { return _ptr.height; }

  void set height(String value) { _ptr.height = value; }

  String get longDesc() { return _ptr.longDesc; }

  void set longDesc(String value) { _ptr.longDesc = value; }

  String get marginHeight() { return _ptr.marginHeight; }

  void set marginHeight(String value) { _ptr.marginHeight = value; }

  String get marginWidth() { return _ptr.marginWidth; }

  void set marginWidth(String value) { _ptr.marginWidth = value; }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  String get sandbox() { return _ptr.sandbox; }

  void set sandbox(String value) { _ptr.sandbox = value; }

  String get scrolling() { return _ptr.scrolling; }

  void set scrolling(String value) { _ptr.scrolling = value; }

  String get src() { return _ptr.src; }

  void set src(String value) { _ptr.src = value; }

  String get width() { return _ptr.width; }

  void set width(String value) { _ptr.width = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ImageDataWrappingImplementation extends DOMWrapperBase implements ImageData {
  ImageDataWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  CanvasPixelArray get data() { return LevelDom.wrapCanvasPixelArray(_ptr.data); }

  int get height() { return _ptr.height; }

  int get width() { return _ptr.width; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ImageElementWrappingImplementation extends ElementWrappingImplementation implements ImageElement {
  ImageElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  String get alt() { return _ptr.alt; }

  void set alt(String value) { _ptr.alt = value; }

  String get border() { return _ptr.border; }

  void set border(String value) { _ptr.border = value; }

  bool get complete() { return _ptr.complete; }

  String get crossOrigin() { return _ptr.crossOrigin; }

  void set crossOrigin(String value) { _ptr.crossOrigin = value; }

  int get height() { return _ptr.height; }

  void set height(int value) { _ptr.height = value; }

  int get hspace() { return _ptr.hspace; }

  void set hspace(int value) { _ptr.hspace = value; }

  bool get isMap() { return _ptr.isMap; }

  void set isMap(bool value) { _ptr.isMap = value; }

  String get longDesc() { return _ptr.longDesc; }

  void set longDesc(String value) { _ptr.longDesc = value; }

  String get lowsrc() { return _ptr.lowsrc; }

  void set lowsrc(String value) { _ptr.lowsrc = value; }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  int get naturalHeight() { return _ptr.naturalHeight; }

  int get naturalWidth() { return _ptr.naturalWidth; }

  String get src() { return _ptr.src; }

  void set src(String value) { _ptr.src = value; }

  String get useMap() { return _ptr.useMap; }

  void set useMap(String value) { _ptr.useMap = value; }

  int get vspace() { return _ptr.vspace; }

  void set vspace(int value) { _ptr.vspace = value; }

  int get width() { return _ptr.width; }

  void set width(int value) { _ptr.width = value; }

  int get x() { return _ptr.x; }

  int get y() { return _ptr.y; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class InputElementWrappingImplementation extends ElementWrappingImplementation implements InputElement {
  InputElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get accept() { return _ptr.accept; }

  void set accept(String value) { _ptr.accept = value; }

  String get accessKey() { return _ptr.accessKey; }

  void set accessKey(String value) { _ptr.accessKey = value; }

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  String get alt() { return _ptr.alt; }

  void set alt(String value) { _ptr.alt = value; }

  String get autocomplete() { return _ptr.autocomplete; }

  void set autocomplete(String value) { _ptr.autocomplete = value; }

  bool get autofocus() { return _ptr.autofocus; }

  void set autofocus(bool value) { _ptr.autofocus = value; }

  bool get checked() { return _ptr.checked; }

  void set checked(bool value) { _ptr.checked = value; }

  bool get defaultChecked() { return _ptr.defaultChecked; }

  void set defaultChecked(bool value) { _ptr.defaultChecked = value; }

  String get defaultValue() { return _ptr.defaultValue; }

  void set defaultValue(String value) { _ptr.defaultValue = value; }

  bool get disabled() { return _ptr.disabled; }

  void set disabled(bool value) { _ptr.disabled = value; }

  FileList get files() { return LevelDom.wrapFileList(_ptr.files); }

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  String get formAction() { return _ptr.formAction; }

  void set formAction(String value) { _ptr.formAction = value; }

  String get formEnctype() { return _ptr.formEnctype; }

  void set formEnctype(String value) { _ptr.formEnctype = value; }

  String get formMethod() { return _ptr.formMethod; }

  void set formMethod(String value) { _ptr.formMethod = value; }

  bool get formNoValidate() { return _ptr.formNoValidate; }

  void set formNoValidate(bool value) { _ptr.formNoValidate = value; }

  String get formTarget() { return _ptr.formTarget; }

  void set formTarget(String value) { _ptr.formTarget = value; }

  bool get incremental() { return _ptr.incremental; }

  void set incremental(bool value) { _ptr.incremental = value; }

  bool get indeterminate() { return _ptr.indeterminate; }

  void set indeterminate(bool value) { _ptr.indeterminate = value; }

  ElementList get labels() { return LevelDom.wrapElementList(_ptr.labels); }

  Element get list() { return LevelDom.wrapElement(_ptr.list); }

  String get max() { return _ptr.max; }

  void set max(String value) { _ptr.max = value; }

  int get maxLength() { return _ptr.maxLength; }

  void set maxLength(int value) { _ptr.maxLength = value; }

  String get min() { return _ptr.min; }

  void set min(String value) { _ptr.min = value; }

  bool get multiple() { return _ptr.multiple; }

  void set multiple(bool value) { _ptr.multiple = value; }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  String get pattern() { return _ptr.pattern; }

  void set pattern(String value) { _ptr.pattern = value; }

  String get placeholder() { return _ptr.placeholder; }

  void set placeholder(String value) { _ptr.placeholder = value; }

  bool get readOnly() { return _ptr.readOnly; }

  void set readOnly(bool value) { _ptr.readOnly = value; }

  bool get required() { return _ptr.required; }

  void set required(bool value) { _ptr.required = value; }

  OptionElement get selectedOption() { return LevelDom.wrapOptionElement(_ptr.selectedOption); }

  String get selectionDirection() { return _ptr.selectionDirection; }

  void set selectionDirection(String value) { _ptr.selectionDirection = value; }

  int get selectionEnd() { return _ptr.selectionEnd; }

  void set selectionEnd(int value) { _ptr.selectionEnd = value; }

  int get selectionStart() { return _ptr.selectionStart; }

  void set selectionStart(int value) { _ptr.selectionStart = value; }

  int get size() { return _ptr.size; }

  void set size(int value) { _ptr.size = value; }

  String get src() { return _ptr.src; }

  void set src(String value) { _ptr.src = value; }

  String get step() { return _ptr.step; }

  void set step(String value) { _ptr.step = value; }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }

  String get useMap() { return _ptr.useMap; }

  void set useMap(String value) { _ptr.useMap = value; }

  String get validationMessage() { return _ptr.validationMessage; }

  ValidityState get validity() { return LevelDom.wrapValidityState(_ptr.validity); }

  String get value() { return _ptr.value; }

  void set value(String value) { _ptr.value = value; }

  Date get valueAsDate() { return _ptr.valueAsDate; }

  void set valueAsDate(Date value) { _ptr.valueAsDate = value; }

  num get valueAsNumber() { return _ptr.valueAsNumber; }

  void set valueAsNumber(num value) { _ptr.valueAsNumber = value; }

  bool get webkitGrammar() { return _ptr.webkitGrammar; }

  void set webkitGrammar(bool value) { _ptr.webkitGrammar = value; }

  bool get webkitSpeech() { return _ptr.webkitSpeech; }

  void set webkitSpeech(bool value) { _ptr.webkitSpeech = value; }

  bool get webkitdirectory() { return _ptr.webkitdirectory; }

  void set webkitdirectory(bool value) { _ptr.webkitdirectory = value; }

  bool get willValidate() { return _ptr.willValidate; }

  bool checkValidity() {
    return _ptr.checkValidity();
  }

  void click() {
    _ptr.click();
    return;
  }

  void select() {
    _ptr.select();
    return;
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(error);
    return;
  }

  void setSelectionRange(int start, int end, [String direction = null]) {
    if (direction === null) {
      _ptr.setSelectionRange(start, end);
      return;
    } else {
      _ptr.setSelectionRange(start, end, direction);
      return;
    }
  }

  void stepDown([int n = null]) {
    if (n === null) {
      _ptr.stepDown();
      return;
    } else {
      _ptr.stepDown(n);
      return;
    }
  }

  void stepUp([int n = null]) {
    if (n === null) {
      _ptr.stepUp();
      return;
    } else {
      _ptr.stepUp(n);
      return;
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class Int16ArrayWrappingImplementation extends ArrayBufferViewWrappingImplementation implements Int16Array {
  Int16ArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Int16Array subarray(int start, [int end]) {
    if (end === null) {
      return LevelDom.wrapInt16Array(_ptr.subarray(start));
    } else {
      return LevelDom.wrapInt16Array(_ptr.subarray(start, end));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class Int32ArrayWrappingImplementation extends ArrayBufferViewWrappingImplementation implements Int32Array {
  Int32ArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Int32Array subarray(int start, [int end]) {
    if (end === null) {
      return LevelDom.wrapInt32Array(_ptr.subarray(start));
    } else {
      return LevelDom.wrapInt32Array(_ptr.subarray(start, end));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class Int8ArrayWrappingImplementation extends ArrayBufferViewWrappingImplementation implements Int8Array {
  Int8ArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Int8Array subarray(int start, [int end]) {
    if (end === null) {
      return LevelDom.wrapInt8Array(_ptr.subarray(start));
    } else {
      return LevelDom.wrapInt8Array(_ptr.subarray(start, end));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class JavaScriptAudioNodeWrappingImplementation extends AudioNodeWrappingImplementation implements JavaScriptAudioNode {
  JavaScriptAudioNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get bufferSize() { return _ptr.bufferSize; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class KeygenElementWrappingImplementation extends ElementWrappingImplementation implements KeygenElement {
  KeygenElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get autofocus() { return _ptr.autofocus; }

  void set autofocus(bool value) { _ptr.autofocus = value; }

  String get challenge() { return _ptr.challenge; }

  void set challenge(String value) { _ptr.challenge = value; }

  bool get disabled() { return _ptr.disabled; }

  void set disabled(bool value) { _ptr.disabled = value; }

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  String get keytype() { return _ptr.keytype; }

  void set keytype(String value) { _ptr.keytype = value; }

  ElementList get labels() { return LevelDom.wrapElementList(_ptr.labels); }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  String get type() { return _ptr.type; }

  String get validationMessage() { return _ptr.validationMessage; }

  ValidityState get validity() { return LevelDom.wrapValidityState(_ptr.validity); }

  bool get willValidate() { return _ptr.willValidate; }

  bool checkValidity() {
    return _ptr.checkValidity();
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(error);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class LIElementWrappingImplementation extends ElementWrappingImplementation implements LIElement {
  LIElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }

  int get value() { return _ptr.value; }

  void set value(int value) { _ptr.value = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class LabelElementWrappingImplementation extends ElementWrappingImplementation implements LabelElement {
  LabelElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get accessKey() { return _ptr.accessKey; }

  void set accessKey(String value) { _ptr.accessKey = value; }

  Element get control() { return LevelDom.wrapElement(_ptr.control); }

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  String get htmlFor() { return _ptr.htmlFor; }

  void set htmlFor(String value) { _ptr.htmlFor = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class LegendElementWrappingImplementation extends ElementWrappingImplementation implements LegendElement {
  LegendElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get accessKey() { return _ptr.accessKey; }

  void set accessKey(String value) { _ptr.accessKey = value; }

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class LinkElementWrappingImplementation extends ElementWrappingImplementation implements LinkElement {
  LinkElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get charset() { return _ptr.charset; }

  void set charset(String value) { _ptr.charset = value; }

  bool get disabled() { return _ptr.disabled; }

  void set disabled(bool value) { _ptr.disabled = value; }

  String get href() { return _ptr.href; }

  void set href(String value) { _ptr.href = value; }

  String get hreflang() { return _ptr.hreflang; }

  void set hreflang(String value) { _ptr.hreflang = value; }

  String get media() { return _ptr.media; }

  void set media(String value) { _ptr.media = value; }

  String get rel() { return _ptr.rel; }

  void set rel(String value) { _ptr.rel = value; }

  String get rev() { return _ptr.rev; }

  void set rev(String value) { _ptr.rev = value; }

  StyleSheet get sheet() { return LevelDom.wrapStyleSheet(_ptr.sheet); }

  DOMSettableTokenList get sizes() { return LevelDom.wrapDOMSettableTokenList(_ptr.sizes); }

  void set sizes(DOMSettableTokenList value) { _ptr.sizes = LevelDom.unwrap(value); }

  String get target() { return _ptr.target; }

  void set target(String value) { _ptr.target = value; }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class LocationWrappingImplementation extends DOMWrapperBase implements Location {
  LocationWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get hash() { return _ptr.hash; }

  void set hash(String value) { _ptr.hash = value; }

  String get host() { return _ptr.host; }

  void set host(String value) { _ptr.host = value; }

  String get hostname() { return _ptr.hostname; }

  void set hostname(String value) { _ptr.hostname = value; }

  String get href() { return _ptr.href; }

  void set href(String value) { _ptr.href = value; }

  String get origin() { return _ptr.origin; }

  String get pathname() { return _ptr.pathname; }

  void set pathname(String value) { _ptr.pathname = value; }

  String get port() { return _ptr.port; }

  void set port(String value) { _ptr.port = value; }

  String get protocol() { return _ptr.protocol; }

  void set protocol(String value) { _ptr.protocol = value; }

  String get search() { return _ptr.search; }

  void set search(String value) { _ptr.search = value; }

  void assign(String url) {
    _ptr.assign(url);
    return;
  }

  String getParameter(String name) {
    return _ptr.getParameter(name);
  }

  void reload() {
    _ptr.reload();
    return;
  }

  void replace(String url) {
    _ptr.replace(url);
    return;
  }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class LoseContextWrappingImplementation extends DOMWrapperBase implements LoseContext {
  LoseContextWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void loseContext() {
    _ptr.loseContext();
    return;
  }

  void restoreContext() {
    _ptr.restoreContext();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class LowPass2FilterNodeWrappingImplementation extends AudioNodeWrappingImplementation implements LowPass2FilterNode {
  LowPass2FilterNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  AudioParam get cutoff() { return LevelDom.wrapAudioParam(_ptr.cutoff); }

  AudioParam get resonance() { return LevelDom.wrapAudioParam(_ptr.resonance); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MapElementWrappingImplementation extends ElementWrappingImplementation implements MapElement {
  MapElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  ElementList get areas() { return LevelDom.wrapElementList(_ptr.areas); }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MarqueeElementWrappingImplementation extends ElementWrappingImplementation implements MarqueeElement {
  MarqueeElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get behavior() { return _ptr.behavior; }

  void set behavior(String value) { _ptr.behavior = value; }

  String get bgColor() { return _ptr.bgColor; }

  void set bgColor(String value) { _ptr.bgColor = value; }

  String get direction() { return _ptr.direction; }

  void set direction(String value) { _ptr.direction = value; }

  String get height() { return _ptr.height; }

  void set height(String value) { _ptr.height = value; }

  int get hspace() { return _ptr.hspace; }

  void set hspace(int value) { _ptr.hspace = value; }

  int get loop() { return _ptr.loop; }

  void set loop(int value) { _ptr.loop = value; }

  int get scrollAmount() { return _ptr.scrollAmount; }

  void set scrollAmount(int value) { _ptr.scrollAmount = value; }

  int get scrollDelay() { return _ptr.scrollDelay; }

  void set scrollDelay(int value) { _ptr.scrollDelay = value; }

  bool get trueSpeed() { return _ptr.trueSpeed; }

  void set trueSpeed(bool value) { _ptr.trueSpeed = value; }

  int get vspace() { return _ptr.vspace; }

  void set vspace(int value) { _ptr.vspace = value; }

  String get width() { return _ptr.width; }

  void set width(String value) { _ptr.width = value; }

  void start() {
    _ptr.start();
    return;
  }

  void stop() {
    _ptr.stop();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MediaElementAudioSourceNodeWrappingImplementation extends AudioSourceNodeWrappingImplementation implements MediaElementAudioSourceNode {
  MediaElementAudioSourceNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  MediaElement get mediaElement() { return LevelDom.wrapMediaElement(_ptr.mediaElement); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MediaElementWrappingImplementation extends ElementWrappingImplementation implements MediaElement {
  MediaElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get autoplay() { return _ptr.autoplay; }

  void set autoplay(bool value) { _ptr.autoplay = value; }

  TimeRanges get buffered() { return LevelDom.wrapTimeRanges(_ptr.buffered); }

  bool get controls() { return _ptr.controls; }

  void set controls(bool value) { _ptr.controls = value; }

  String get currentSrc() { return _ptr.currentSrc; }

  num get currentTime() { return _ptr.currentTime; }

  void set currentTime(num value) { _ptr.currentTime = value; }

  bool get defaultMuted() { return _ptr.defaultMuted; }

  void set defaultMuted(bool value) { _ptr.defaultMuted = value; }

  num get defaultPlaybackRate() { return _ptr.defaultPlaybackRate; }

  void set defaultPlaybackRate(num value) { _ptr.defaultPlaybackRate = value; }

  num get duration() { return _ptr.duration; }

  bool get ended() { return _ptr.ended; }

  MediaError get error() { return LevelDom.wrapMediaError(_ptr.error); }

  num get initialTime() { return _ptr.initialTime; }

  bool get loop() { return _ptr.loop; }

  void set loop(bool value) { _ptr.loop = value; }

  bool get muted() { return _ptr.muted; }

  void set muted(bool value) { _ptr.muted = value; }

  int get networkState() { return _ptr.networkState; }

  bool get paused() { return _ptr.paused; }

  num get playbackRate() { return _ptr.playbackRate; }

  void set playbackRate(num value) { _ptr.playbackRate = value; }

  TimeRanges get played() { return LevelDom.wrapTimeRanges(_ptr.played); }

  String get preload() { return _ptr.preload; }

  void set preload(String value) { _ptr.preload = value; }

  int get readyState() { return _ptr.readyState; }

  TimeRanges get seekable() { return LevelDom.wrapTimeRanges(_ptr.seekable); }

  bool get seeking() { return _ptr.seeking; }

  String get src() { return _ptr.src; }

  void set src(String value) { _ptr.src = value; }

  num get startTime() { return _ptr.startTime; }

  num get volume() { return _ptr.volume; }

  void set volume(num value) { _ptr.volume = value; }

  int get webkitAudioDecodedByteCount() { return _ptr.webkitAudioDecodedByteCount; }

  bool get webkitClosedCaptionsVisible() { return _ptr.webkitClosedCaptionsVisible; }

  void set webkitClosedCaptionsVisible(bool value) { _ptr.webkitClosedCaptionsVisible = value; }

  bool get webkitHasClosedCaptions() { return _ptr.webkitHasClosedCaptions; }

  bool get webkitPreservesPitch() { return _ptr.webkitPreservesPitch; }

  void set webkitPreservesPitch(bool value) { _ptr.webkitPreservesPitch = value; }

  int get webkitVideoDecodedByteCount() { return _ptr.webkitVideoDecodedByteCount; }

  String canPlayType(String type) {
    return _ptr.canPlayType(type);
  }

  void load() {
    _ptr.load();
    return;
  }

  void pause() {
    _ptr.pause();
    return;
  }

  void play() {
    _ptr.play();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MediaErrorWrappingImplementation extends DOMWrapperBase implements MediaError {
  MediaErrorWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MediaListWrappingImplementation extends DOMWrapperBase implements MediaList {
  MediaListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  String get mediaText() { return _ptr.mediaText; }

  void set mediaText(String value) { _ptr.mediaText = value; }

  String operator[](int index) {
    return _ptr[index];
  }

  void operator[]=(int index, String value) {
    _ptr[index] = value;
  }

  void add(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<String> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(String a, String b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(String element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(String element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  String removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  String last() {
    return this[length - 1];
  }

  void forEach(void f(String element)) {
    _Collections.forEach(this, f);
  }

  Collection<String> filter(bool f(String element)) {
    return _Collections.filter(this, new List<String>(), f);
  }

  bool every(bool f(String element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(String element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<String> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [String initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<String> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<String> iterator() {
    return new _FixedSizeListIterator<String>(this);
  }

  void appendMedium(String newMedium) {
    _ptr.appendMedium(newMedium);
    return;
  }

  void deleteMedium(String oldMedium) {
    _ptr.deleteMedium(oldMedium);
    return;
  }

  String item(int index) {
    return _ptr.item(index);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MediaQueryListListenerWrappingImplementation extends DOMWrapperBase implements MediaQueryListListener {
  MediaQueryListListenerWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void queryChanged(MediaQueryList list) {
    _ptr.queryChanged(LevelDom.unwrap(list));
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MediaQueryListWrappingImplementation extends DOMWrapperBase implements MediaQueryList {
  MediaQueryListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get matches() { return _ptr.matches; }

  String get media() { return _ptr.media; }

  void addListener(MediaQueryListListener listener) {
    _ptr.addListener(LevelDom.unwrap(listener));
    return;
  }

  void removeListener(MediaQueryListListener listener) {
    _ptr.removeListener(LevelDom.unwrap(listener));
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MenuElementWrappingImplementation extends ElementWrappingImplementation implements MenuElement {
  MenuElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get compact() { return _ptr.compact; }

  void set compact(bool value) { _ptr.compact = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MessageChannelWrappingImplementation extends DOMWrapperBase implements MessageChannel {
  MessageChannelWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  MessagePort get port1() { return LevelDom.wrapMessagePort(_ptr.port1); }

  MessagePort get port2() { return LevelDom.wrapMessagePort(_ptr.port2); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MetaElementWrappingImplementation extends ElementWrappingImplementation implements MetaElement {
  MetaElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get content() { return _ptr.content; }

  void set content(String value) { _ptr.content = value; }

  String get httpEquiv() { return _ptr.httpEquiv; }

  void set httpEquiv(String value) { _ptr.httpEquiv = value; }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  String get scheme() { return _ptr.scheme; }

  void set scheme(String value) { _ptr.scheme = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MetadataWrappingImplementation extends DOMWrapperBase implements Metadata {
  MetadataWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  Date get modificationTime() { return _ptr.modificationTime; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MeterElementWrappingImplementation extends ElementWrappingImplementation implements MeterElement {
  MeterElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  num get high() { return _ptr.high; }

  void set high(num value) { _ptr.high = value; }

  ElementList get labels() { return LevelDom.wrapElementList(_ptr.labels); }

  num get low() { return _ptr.low; }

  void set low(num value) { _ptr.low = value; }

  num get max() { return _ptr.max; }

  void set max(num value) { _ptr.max = value; }

  num get min() { return _ptr.min; }

  void set min(num value) { _ptr.min = value; }

  num get optimum() { return _ptr.optimum; }

  void set optimum(num value) { _ptr.optimum = value; }

  num get value() { return _ptr.value; }

  void set value(num value) { _ptr.value = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ModElementWrappingImplementation extends ElementWrappingImplementation implements ModElement {
  ModElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get cite() { return _ptr.cite; }

  void set cite(String value) { _ptr.cite = value; }

  String get dateTime() { return _ptr.dateTime; }

  void set dateTime(String value) { _ptr.dateTime = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MutationCallbackWrappingImplementation extends DOMWrapperBase implements MutationCallback {
  MutationCallbackWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class MutationRecordWrappingImplementation extends DOMWrapperBase implements MutationRecord {
  MutationRecordWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  ElementList get addedNodes() { return LevelDom.wrapElementList(_ptr.addedNodes); }

  String get attributeName() { return _ptr.attributeName; }

  String get attributeNamespace() { return _ptr.attributeNamespace; }

  Node get nextSibling() { return LevelDom.wrapNode(_ptr.nextSibling); }

  String get oldValue() { return _ptr.oldValue; }

  Node get previousSibling() { return LevelDom.wrapNode(_ptr.previousSibling); }

  ElementList get removedNodes() { return LevelDom.wrapElementList(_ptr.removedNodes); }

  Node get target() { return LevelDom.wrapNode(_ptr.target); }

  String get type() { return _ptr.type; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class NavigatorUserMediaErrorWrappingImplementation extends DOMWrapperBase implements NavigatorUserMediaError {
  NavigatorUserMediaErrorWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class NavigatorUserMediaSuccessCallbackWrappingImplementation extends DOMWrapperBase implements NavigatorUserMediaSuccessCallback {
  NavigatorUserMediaSuccessCallbackWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class NavigatorWrappingImplementation extends DOMWrapperBase implements Navigator {
  NavigatorWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get appCodeName() { return _ptr.appCodeName; }

  String get appName() { return _ptr.appName; }

  String get appVersion() { return _ptr.appVersion; }

  bool get cookieEnabled() { return _ptr.cookieEnabled; }

  String get language() { return _ptr.language; }

  DOMMimeTypeArray get mimeTypes() { return LevelDom.wrapDOMMimeTypeArray(_ptr.mimeTypes); }

  bool get onLine() { return _ptr.onLine; }

  String get platform() { return _ptr.platform; }

  DOMPluginArray get plugins() { return LevelDom.wrapDOMPluginArray(_ptr.plugins); }

  String get product() { return _ptr.product; }

  String get productSub() { return _ptr.productSub; }

  String get userAgent() { return _ptr.userAgent; }

  String get vendor() { return _ptr.vendor; }

  String get vendorSub() { return _ptr.vendorSub; }

  void getStorageUpdates() {
    _ptr.getStorageUpdates();
    return;
  }

  bool javaEnabled() {
    return _ptr.javaEnabled();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class NotationWrappingImplementation extends NodeWrappingImplementation implements Notation {
  NotationWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get publicId() { return _ptr.publicId; }

  String get systemId() { return _ptr.systemId; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class NotificationCenterWrappingImplementation extends DOMWrapperBase implements NotificationCenter {
  NotificationCenterWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int checkPermission() {
    return _ptr.checkPermission();
  }

  Notification createHTMLNotification(String url) {
    return LevelDom.wrapNotification(_ptr.createHTMLNotification(url));
  }

  Notification createNotification(String iconUrl, String title, String body) {
    return LevelDom.wrapNotification(_ptr.createNotification(iconUrl, title, body));
  }

  void requestPermission(VoidCallback callback) {
    _ptr.requestPermission(LevelDom.unwrap(callback));
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class OESStandardDerivativesWrappingImplementation extends DOMWrapperBase implements OESStandardDerivatives {
  OESStandardDerivativesWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class OESTextureFloatWrappingImplementation extends DOMWrapperBase implements OESTextureFloat {
  OESTextureFloatWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class OESVertexArrayObjectWrappingImplementation extends DOMWrapperBase implements OESVertexArrayObject {
  OESVertexArrayObjectWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void bindVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    _ptr.bindVertexArrayOES(LevelDom.unwrap(arrayObject));
    return;
  }

  WebGLVertexArrayObjectOES createVertexArrayOES() {
    return LevelDom.wrapWebGLVertexArrayObjectOES(_ptr.createVertexArrayOES());
  }

  void deleteVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    _ptr.deleteVertexArrayOES(LevelDom.unwrap(arrayObject));
    return;
  }

  bool isVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    return _ptr.isVertexArrayOES(LevelDom.unwrap(arrayObject));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class OListElementWrappingImplementation extends ElementWrappingImplementation implements OListElement {
  OListElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get compact() { return _ptr.compact; }

  void set compact(bool value) { _ptr.compact = value; }

  int get start() { return _ptr.start; }

  void set start(int value) { _ptr.start = value; }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class OfflineAudioCompletionEventWrappingImplementation extends EventWrappingImplementation implements OfflineAudioCompletionEvent {
  OfflineAudioCompletionEventWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  AudioBuffer get renderedBuffer() { return LevelDom.wrapAudioBuffer(_ptr.renderedBuffer); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class OperationNotAllowedExceptionWrappingImplementation extends DOMWrapperBase implements OperationNotAllowedException {
  OperationNotAllowedExceptionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }

  String get message() { return _ptr.message; }

  String get name() { return _ptr.name; }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class OptGroupElementWrappingImplementation extends ElementWrappingImplementation implements OptGroupElement {
  OptGroupElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get disabled() { return _ptr.disabled; }

  void set disabled(bool value) { _ptr.disabled = value; }

  String get label() { return _ptr.label; }

  void set label(String value) { _ptr.label = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class OptionElementWrappingImplementation extends ElementWrappingImplementation implements OptionElement {
  OptionElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get defaultSelected() { return _ptr.defaultSelected; }

  void set defaultSelected(bool value) { _ptr.defaultSelected = value; }

  bool get disabled() { return _ptr.disabled; }

  void set disabled(bool value) { _ptr.disabled = value; }

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  int get index() { return _ptr.index; }

  String get label() { return _ptr.label; }

  void set label(String value) { _ptr.label = value; }

  bool get selected() { return _ptr.selected; }

  void set selected(bool value) { _ptr.selected = value; }

  String get text() { return _ptr.text; }

  void set text(String value) { _ptr.text = value; }

  String get value() { return _ptr.value; }

  void set value(String value) { _ptr.value = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class OutputElementWrappingImplementation extends ElementWrappingImplementation implements OutputElement {
  OutputElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get defaultValue() { return _ptr.defaultValue; }

  void set defaultValue(String value) { _ptr.defaultValue = value; }

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  DOMSettableTokenList get htmlFor() { return LevelDom.wrapDOMSettableTokenList(_ptr.htmlFor); }

  void set htmlFor(DOMSettableTokenList value) { _ptr.htmlFor = LevelDom.unwrap(value); }

  ElementList get labels() { return LevelDom.wrapElementList(_ptr.labels); }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  String get type() { return _ptr.type; }

  String get validationMessage() { return _ptr.validationMessage; }

  ValidityState get validity() { return LevelDom.wrapValidityState(_ptr.validity); }

  String get value() { return _ptr.value; }

  void set value(String value) { _ptr.value = value; }

  bool get willValidate() { return _ptr.willValidate; }

  bool checkValidity() {
    return _ptr.checkValidity();
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(error);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ParagraphElementWrappingImplementation extends ElementWrappingImplementation implements ParagraphElement {
  ParagraphElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ParamElementWrappingImplementation extends ElementWrappingImplementation implements ParamElement {
  ParamElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }

  String get value() { return _ptr.value; }

  void set value(String value) { _ptr.value = value; }

  String get valueType() { return _ptr.valueType; }

  void set valueType(String value) { _ptr.valueType = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class PointWrappingImplementation extends DOMWrapperBase implements Point {
  PointWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
  factory PointWrappingImplementation(num x, num y) {
    return LevelDom.wrapPoint(new dom.WebKitPoint(x, y));
  }

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class PositionErrorWrappingImplementation extends DOMWrapperBase implements PositionError {
  PositionErrorWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }

  String get message() { return _ptr.message; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class PreElementWrappingImplementation extends ElementWrappingImplementation implements PreElement {
  PreElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get width() { return _ptr.width; }

  void set width(int value) { _ptr.width = value; }

  bool get wrap() { return _ptr.wrap; }

  void set wrap(bool value) { _ptr.wrap = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ProcessingInstructionWrappingImplementation extends NodeWrappingImplementation implements ProcessingInstruction {
  ProcessingInstructionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get data() { return _ptr.data; }

  void set data(String value) { _ptr.data = value; }

  StyleSheet get sheet() { return LevelDom.wrapStyleSheet(_ptr.sheet); }

  String get target() { return _ptr.target; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ProgressElementWrappingImplementation extends ElementWrappingImplementation implements ProgressElement {
  ProgressElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  ElementList get labels() { return LevelDom.wrapElementList(_ptr.labels); }

  num get max() { return _ptr.max; }

  void set max(num value) { _ptr.max = value; }

  num get position() { return _ptr.position; }

  num get value() { return _ptr.value; }

  void set value(num value) { _ptr.value = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class QuoteElementWrappingImplementation extends ElementWrappingImplementation implements QuoteElement {
  QuoteElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get cite() { return _ptr.cite; }

  void set cite(String value) { _ptr.cite = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class RGBColorWrappingImplementation extends DOMWrapperBase implements RGBColor {
  RGBColorWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  CSSPrimitiveValue get blue() { return LevelDom.wrapCSSPrimitiveValue(_ptr.blue); }

  CSSPrimitiveValue get green() { return LevelDom.wrapCSSPrimitiveValue(_ptr.green); }

  CSSPrimitiveValue get red() { return LevelDom.wrapCSSPrimitiveValue(_ptr.red); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class RangeExceptionWrappingImplementation extends DOMWrapperBase implements RangeException {
  RangeExceptionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }

  String get message() { return _ptr.message; }

  String get name() { return _ptr.name; }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class RangeWrappingImplementation extends DOMWrapperBase implements Range {
  RangeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get collapsed() { return _ptr.collapsed; }

  Node get commonAncestorContainer() { return LevelDom.wrapNode(_ptr.commonAncestorContainer); }

  Node get endContainer() { return LevelDom.wrapNode(_ptr.endContainer); }

  int get endOffset() { return _ptr.endOffset; }

  Node get startContainer() { return LevelDom.wrapNode(_ptr.startContainer); }

  int get startOffset() { return _ptr.startOffset; }

  DocumentFragment cloneContents() {
    return LevelDom.wrapDocumentFragment(_ptr.cloneContents());
  }

  Range cloneRange() {
    return LevelDom.wrapRange(_ptr.cloneRange());
  }

  void collapse(bool toStart) {
    _ptr.collapse(toStart);
    return;
  }

  int compareNode(Node refNode) {
    return _ptr.compareNode(LevelDom.unwrap(refNode));
  }

  int comparePoint(Node refNode, int offset) {
    return _ptr.comparePoint(LevelDom.unwrap(refNode), offset);
  }

  DocumentFragment createContextualFragment(String html) {
    return LevelDom.wrapDocumentFragment(_ptr.createContextualFragment(html));
  }

  void deleteContents() {
    _ptr.deleteContents();
    return;
  }

  void detach() {
    _ptr.detach();
    return;
  }

  void expand(String unit) {
    _ptr.expand(unit);
    return;
  }

  DocumentFragment extractContents() {
    return LevelDom.wrapDocumentFragment(_ptr.extractContents());
  }

  ClientRect getBoundingClientRect() {
    return LevelDom.wrapClientRect(_ptr.getBoundingClientRect());
  }

  ClientRectList getClientRects() {
    return LevelDom.wrapClientRectList(_ptr.getClientRects());
  }

  void insertNode(Node newNode) {
    _ptr.insertNode(LevelDom.unwrap(newNode));
    return;
  }

  bool intersectsNode(Node refNode) {
    return _ptr.intersectsNode(LevelDom.unwrap(refNode));
  }

  bool isPointInRange(Node refNode, int offset) {
    return _ptr.isPointInRange(LevelDom.unwrap(refNode), offset);
  }

  void selectNode(Node refNode) {
    _ptr.selectNode(LevelDom.unwrap(refNode));
    return;
  }

  void selectNodeContents(Node refNode) {
    _ptr.selectNodeContents(LevelDom.unwrap(refNode));
    return;
  }

  void setEnd(Node refNode, int offset) {
    _ptr.setEnd(LevelDom.unwrap(refNode), offset);
    return;
  }

  void setEndAfter(Node refNode) {
    _ptr.setEndAfter(LevelDom.unwrap(refNode));
    return;
  }

  void setEndBefore(Node refNode) {
    _ptr.setEndBefore(LevelDom.unwrap(refNode));
    return;
  }

  void setStart(Node refNode, int offset) {
    _ptr.setStart(LevelDom.unwrap(refNode), offset);
    return;
  }

  void setStartAfter(Node refNode) {
    _ptr.setStartAfter(LevelDom.unwrap(refNode));
    return;
  }

  void setStartBefore(Node refNode) {
    _ptr.setStartBefore(LevelDom.unwrap(refNode));
    return;
  }

  void surroundContents(Node newParent) {
    _ptr.surroundContents(LevelDom.unwrap(newParent));
    return;
  }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class RealtimeAnalyserNodeWrappingImplementation extends AudioNodeWrappingImplementation implements RealtimeAnalyserNode {
  RealtimeAnalyserNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get fftSize() { return _ptr.fftSize; }

  void set fftSize(int value) { _ptr.fftSize = value; }

  int get frequencyBinCount() { return _ptr.frequencyBinCount; }

  num get maxDecibels() { return _ptr.maxDecibels; }

  void set maxDecibels(num value) { _ptr.maxDecibels = value; }

  num get minDecibels() { return _ptr.minDecibels; }

  void set minDecibels(num value) { _ptr.minDecibels = value; }

  num get smoothingTimeConstant() { return _ptr.smoothingTimeConstant; }

  void set smoothingTimeConstant(num value) { _ptr.smoothingTimeConstant = value; }

  void getByteFrequencyData(Uint8Array array) {
    _ptr.getByteFrequencyData(LevelDom.unwrap(array));
    return;
  }

  void getByteTimeDomainData(Uint8Array array) {
    _ptr.getByteTimeDomainData(LevelDom.unwrap(array));
    return;
  }

  void getFloatFrequencyData(Float32Array array) {
    _ptr.getFloatFrequencyData(LevelDom.unwrap(array));
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class RectWrappingImplementation extends DOMWrapperBase implements Rect {
  RectWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  CSSPrimitiveValue get bottom() { return LevelDom.wrapCSSPrimitiveValue(_ptr.bottom); }

  CSSPrimitiveValue get left() { return LevelDom.wrapCSSPrimitiveValue(_ptr.left); }

  CSSPrimitiveValue get right() { return LevelDom.wrapCSSPrimitiveValue(_ptr.right); }

  CSSPrimitiveValue get top() { return LevelDom.wrapCSSPrimitiveValue(_ptr.top); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGAElement {
  SVGAElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedString get target() { return LevelDom.wrapSVGAnimatedString(_ptr.target); }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAltGlyphDefElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGAltGlyphDefElement {
  SVGAltGlyphDefElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAltGlyphElementWrappingImplementation extends SVGTextPositioningElementWrappingImplementation implements SVGAltGlyphElement {
  SVGAltGlyphElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get format() { return _ptr.format; }

  void set format(String value) { _ptr.format = value; }

  String get glyphRef() { return _ptr.glyphRef; }

  void set glyphRef(String value) { _ptr.glyphRef = value; }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAltGlyphItemElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGAltGlyphItemElement {
  SVGAltGlyphItemElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAngleWrappingImplementation extends DOMWrapperBase implements SVGAngle {
  SVGAngleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get unitType() { return _ptr.unitType; }

  num get value() { return _ptr.value; }

  void set value(num value) { _ptr.value = value; }

  String get valueAsString() { return _ptr.valueAsString; }

  void set valueAsString(String value) { _ptr.valueAsString = value; }

  num get valueInSpecifiedUnits() { return _ptr.valueInSpecifiedUnits; }

  void set valueInSpecifiedUnits(num value) { _ptr.valueInSpecifiedUnits = value; }

  void convertToSpecifiedUnits(int unitType) {
    _ptr.convertToSpecifiedUnits(unitType);
    return;
  }

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) {
    _ptr.newValueSpecifiedUnits(unitType, valueInSpecifiedUnits);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimateColorElementWrappingImplementation extends SVGAnimationElementWrappingImplementation implements SVGAnimateColorElement {
  SVGAnimateColorElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimateElementWrappingImplementation extends SVGAnimationElementWrappingImplementation implements SVGAnimateElement {
  SVGAnimateElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimateMotionElementWrappingImplementation extends SVGAnimationElementWrappingImplementation implements SVGAnimateMotionElement {
  SVGAnimateMotionElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimateTransformElementWrappingImplementation extends SVGAnimationElementWrappingImplementation implements SVGAnimateTransformElement {
  SVGAnimateTransformElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedAngleWrappingImplementation extends DOMWrapperBase implements SVGAnimatedAngle {
  SVGAnimatedAngleWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAngle get animVal() { return LevelDom.wrapSVGAngle(_ptr.animVal); }

  SVGAngle get baseVal() { return LevelDom.wrapSVGAngle(_ptr.baseVal); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedBooleanWrappingImplementation extends DOMWrapperBase implements SVGAnimatedBoolean {
  SVGAnimatedBooleanWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get animVal() { return _ptr.animVal; }

  bool get baseVal() { return _ptr.baseVal; }

  void set baseVal(bool value) { _ptr.baseVal = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedEnumerationWrappingImplementation extends DOMWrapperBase implements SVGAnimatedEnumeration {
  SVGAnimatedEnumerationWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get animVal() { return _ptr.animVal; }

  int get baseVal() { return _ptr.baseVal; }

  void set baseVal(int value) { _ptr.baseVal = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedIntegerWrappingImplementation extends DOMWrapperBase implements SVGAnimatedInteger {
  SVGAnimatedIntegerWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get animVal() { return _ptr.animVal; }

  int get baseVal() { return _ptr.baseVal; }

  void set baseVal(int value) { _ptr.baseVal = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedLengthListWrappingImplementation extends DOMWrapperBase implements SVGAnimatedLengthList {
  SVGAnimatedLengthListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGLengthList get animVal() { return LevelDom.wrapSVGLengthList(_ptr.animVal); }

  SVGLengthList get baseVal() { return LevelDom.wrapSVGLengthList(_ptr.baseVal); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedLengthWrappingImplementation extends DOMWrapperBase implements SVGAnimatedLength {
  SVGAnimatedLengthWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGLength get animVal() { return LevelDom.wrapSVGLength(_ptr.animVal); }

  SVGLength get baseVal() { return LevelDom.wrapSVGLength(_ptr.baseVal); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedNumberListWrappingImplementation extends DOMWrapperBase implements SVGAnimatedNumberList {
  SVGAnimatedNumberListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGNumberList get animVal() { return LevelDom.wrapSVGNumberList(_ptr.animVal); }

  SVGNumberList get baseVal() { return LevelDom.wrapSVGNumberList(_ptr.baseVal); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedNumberWrappingImplementation extends DOMWrapperBase implements SVGAnimatedNumber {
  SVGAnimatedNumberWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get animVal() { return _ptr.animVal; }

  num get baseVal() { return _ptr.baseVal; }

  void set baseVal(num value) { _ptr.baseVal = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedPreserveAspectRatioWrappingImplementation extends DOMWrapperBase implements SVGAnimatedPreserveAspectRatio {
  SVGAnimatedPreserveAspectRatioWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGPreserveAspectRatio get animVal() { return LevelDom.wrapSVGPreserveAspectRatio(_ptr.animVal); }

  SVGPreserveAspectRatio get baseVal() { return LevelDom.wrapSVGPreserveAspectRatio(_ptr.baseVal); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedRectWrappingImplementation extends DOMWrapperBase implements SVGAnimatedRect {
  SVGAnimatedRectWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGRect get animVal() { return LevelDom.wrapSVGRect(_ptr.animVal); }

  SVGRect get baseVal() { return LevelDom.wrapSVGRect(_ptr.baseVal); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedStringWrappingImplementation extends DOMWrapperBase implements SVGAnimatedString {
  SVGAnimatedStringWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get animVal() { return _ptr.animVal; }

  String get baseVal() { return _ptr.baseVal; }

  void set baseVal(String value) { _ptr.baseVal = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimatedTransformListWrappingImplementation extends DOMWrapperBase implements SVGAnimatedTransformList {
  SVGAnimatedTransformListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGTransformList get animVal() { return LevelDom.wrapSVGTransformList(_ptr.animVal); }

  SVGTransformList get baseVal() { return LevelDom.wrapSVGTransformList(_ptr.baseVal); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGAnimationElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGAnimationElement {
  SVGAnimationElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGElement get targetElement() { return LevelDom.wrapSVGElement(_ptr.targetElement); }

  num getCurrentTime() {
    return _ptr.getCurrentTime();
  }

  num getSimpleDuration() {
    return _ptr.getSimpleDuration();
  }

  num getStartTime() {
    return _ptr.getStartTime();
  }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From ElementTimeControl

  void beginElement() {
    _ptr.beginElement();
    return;
  }

  void beginElementAt(num offset) {
    _ptr.beginElementAt(offset);
    return;
  }

  void endElement() {
    _ptr.endElement();
    return;
  }

  void endElementAt(num offset) {
    _ptr.endElementAt(offset);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGCircleElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGCircleElement {
  SVGCircleElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get cx() { return LevelDom.wrapSVGAnimatedLength(_ptr.cx); }

  SVGAnimatedLength get cy() { return LevelDom.wrapSVGAnimatedLength(_ptr.cy); }

  SVGAnimatedLength get r() { return LevelDom.wrapSVGAnimatedLength(_ptr.r); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGClipPathElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGClipPathElement {
  SVGClipPathElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedEnumeration get clipPathUnits() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.clipPathUnits); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGColorWrappingImplementation extends CSSValueWrappingImplementation implements SVGColor {
  SVGColorWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get colorType() { return _ptr.colorType; }

  RGBColor get rgbColor() { return LevelDom.wrapRGBColor(_ptr.rgbColor); }

  void setColor(int colorType, String rgbColor, String iccColor) {
    _ptr.setColor(colorType, rgbColor, iccColor);
    return;
  }

  void setRGBColor(String rgbColor) {
    _ptr.setRGBColor(rgbColor);
    return;
  }

  void setRGBColorICCColor(String rgbColor, String iccColor) {
    _ptr.setRGBColorICCColor(rgbColor, iccColor);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGComponentTransferFunctionElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGComponentTransferFunctionElement {
  SVGComponentTransferFunctionElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedNumber get amplitude() { return LevelDom.wrapSVGAnimatedNumber(_ptr.amplitude); }

  SVGAnimatedNumber get exponent() { return LevelDom.wrapSVGAnimatedNumber(_ptr.exponent); }

  SVGAnimatedNumber get intercept() { return LevelDom.wrapSVGAnimatedNumber(_ptr.intercept); }

  SVGAnimatedNumber get offset() { return LevelDom.wrapSVGAnimatedNumber(_ptr.offset); }

  SVGAnimatedNumber get slope() { return LevelDom.wrapSVGAnimatedNumber(_ptr.slope); }

  SVGAnimatedNumberList get tableValues() { return LevelDom.wrapSVGAnimatedNumberList(_ptr.tableValues); }

  SVGAnimatedEnumeration get type() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.type); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGCursorElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGCursorElement {
  SVGCursorElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGDefsElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGDefsElement {
  SVGDefsElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGDescElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGDescElement {
  SVGDescElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGElementInstanceListWrappingImplementation extends DOMWrapperBase implements SVGElementInstanceList {
  SVGElementInstanceListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  SVGElementInstance item(int index) {
    return LevelDom.wrapSVGElementInstance(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGEllipseElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGEllipseElement {
  SVGEllipseElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get cx() { return LevelDom.wrapSVGAnimatedLength(_ptr.cx); }

  SVGAnimatedLength get cy() { return LevelDom.wrapSVGAnimatedLength(_ptr.cy); }

  SVGAnimatedLength get rx() { return LevelDom.wrapSVGAnimatedLength(_ptr.rx); }

  SVGAnimatedLength get ry() { return LevelDom.wrapSVGAnimatedLength(_ptr.ry); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGExceptionWrappingImplementation extends DOMWrapperBase implements SVGException {
  SVGExceptionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }

  String get message() { return _ptr.message; }

  String get name() { return _ptr.name; }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGExternalResourcesRequiredWrappingImplementation extends DOMWrapperBase implements SVGExternalResourcesRequired {
  SVGExternalResourcesRequiredWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEBlendElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEBlendElement {
  SVGFEBlendElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }

  SVGAnimatedString get in2() { return LevelDom.wrapSVGAnimatedString(_ptr.in2); }

  SVGAnimatedEnumeration get mode() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.mode); }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEColorMatrixElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEColorMatrixElement {
  SVGFEColorMatrixElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }

  SVGAnimatedEnumeration get type() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.type); }

  SVGAnimatedNumberList get values() { return LevelDom.wrapSVGAnimatedNumberList(_ptr.values); }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEComponentTransferElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEComponentTransferElement {
  SVGFEComponentTransferElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEConvolveMatrixElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEConvolveMatrixElement {
  SVGFEConvolveMatrixElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedNumber get bias() { return LevelDom.wrapSVGAnimatedNumber(_ptr.bias); }

  SVGAnimatedNumber get divisor() { return LevelDom.wrapSVGAnimatedNumber(_ptr.divisor); }

  SVGAnimatedEnumeration get edgeMode() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.edgeMode); }

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }

  SVGAnimatedNumberList get kernelMatrix() { return LevelDom.wrapSVGAnimatedNumberList(_ptr.kernelMatrix); }

  SVGAnimatedNumber get kernelUnitLengthX() { return LevelDom.wrapSVGAnimatedNumber(_ptr.kernelUnitLengthX); }

  SVGAnimatedNumber get kernelUnitLengthY() { return LevelDom.wrapSVGAnimatedNumber(_ptr.kernelUnitLengthY); }

  SVGAnimatedInteger get orderX() { return LevelDom.wrapSVGAnimatedInteger(_ptr.orderX); }

  SVGAnimatedInteger get orderY() { return LevelDom.wrapSVGAnimatedInteger(_ptr.orderY); }

  SVGAnimatedBoolean get preserveAlpha() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.preserveAlpha); }

  SVGAnimatedInteger get targetX() { return LevelDom.wrapSVGAnimatedInteger(_ptr.targetX); }

  SVGAnimatedInteger get targetY() { return LevelDom.wrapSVGAnimatedInteger(_ptr.targetY); }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEDiffuseLightingElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEDiffuseLightingElement {
  SVGFEDiffuseLightingElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedNumber get diffuseConstant() { return LevelDom.wrapSVGAnimatedNumber(_ptr.diffuseConstant); }

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }

  SVGAnimatedNumber get kernelUnitLengthX() { return LevelDom.wrapSVGAnimatedNumber(_ptr.kernelUnitLengthX); }

  SVGAnimatedNumber get kernelUnitLengthY() { return LevelDom.wrapSVGAnimatedNumber(_ptr.kernelUnitLengthY); }

  SVGAnimatedNumber get surfaceScale() { return LevelDom.wrapSVGAnimatedNumber(_ptr.surfaceScale); }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEDisplacementMapElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEDisplacementMapElement {
  SVGFEDisplacementMapElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }

  SVGAnimatedString get in2() { return LevelDom.wrapSVGAnimatedString(_ptr.in2); }

  SVGAnimatedNumber get scale() { return LevelDom.wrapSVGAnimatedNumber(_ptr.scale); }

  SVGAnimatedEnumeration get xChannelSelector() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.xChannelSelector); }

  SVGAnimatedEnumeration get yChannelSelector() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.yChannelSelector); }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEDistantLightElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEDistantLightElement {
  SVGFEDistantLightElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedNumber get azimuth() { return LevelDom.wrapSVGAnimatedNumber(_ptr.azimuth); }

  SVGAnimatedNumber get elevation() { return LevelDom.wrapSVGAnimatedNumber(_ptr.elevation); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEDropShadowElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEDropShadowElement {
  SVGFEDropShadowElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedNumber get dx() { return LevelDom.wrapSVGAnimatedNumber(_ptr.dx); }

  SVGAnimatedNumber get dy() { return LevelDom.wrapSVGAnimatedNumber(_ptr.dy); }

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }

  SVGAnimatedNumber get stdDeviationX() { return LevelDom.wrapSVGAnimatedNumber(_ptr.stdDeviationX); }

  SVGAnimatedNumber get stdDeviationY() { return LevelDom.wrapSVGAnimatedNumber(_ptr.stdDeviationY); }

  void setStdDeviation(num stdDeviationX, num stdDeviationY) {
    _ptr.setStdDeviation(stdDeviationX, stdDeviationY);
    return;
  }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEFloodElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEFloodElement {
  SVGFEFloodElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEFuncAElementWrappingImplementation extends SVGComponentTransferFunctionElementWrappingImplementation implements SVGFEFuncAElement {
  SVGFEFuncAElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEFuncBElementWrappingImplementation extends SVGComponentTransferFunctionElementWrappingImplementation implements SVGFEFuncBElement {
  SVGFEFuncBElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEFuncGElementWrappingImplementation extends SVGComponentTransferFunctionElementWrappingImplementation implements SVGFEFuncGElement {
  SVGFEFuncGElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEFuncRElementWrappingImplementation extends SVGComponentTransferFunctionElementWrappingImplementation implements SVGFEFuncRElement {
  SVGFEFuncRElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEGaussianBlurElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEGaussianBlurElement {
  SVGFEGaussianBlurElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }

  SVGAnimatedNumber get stdDeviationX() { return LevelDom.wrapSVGAnimatedNumber(_ptr.stdDeviationX); }

  SVGAnimatedNumber get stdDeviationY() { return LevelDom.wrapSVGAnimatedNumber(_ptr.stdDeviationY); }

  void setStdDeviation(num stdDeviationX, num stdDeviationY) {
    _ptr.setStdDeviation(stdDeviationX, stdDeviationY);
    return;
  }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEImageElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEImageElement {
  SVGFEImageElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() { return LevelDom.wrapSVGAnimatedPreserveAspectRatio(_ptr.preserveAspectRatio); }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEMergeElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEMergeElement {
  SVGFEMergeElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEMergeNodeElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEMergeNodeElement {
  SVGFEMergeNodeElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEOffsetElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEOffsetElement {
  SVGFEOffsetElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedNumber get dx() { return LevelDom.wrapSVGAnimatedNumber(_ptr.dx); }

  SVGAnimatedNumber get dy() { return LevelDom.wrapSVGAnimatedNumber(_ptr.dy); }

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFEPointLightElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFEPointLightElement {
  SVGFEPointLightElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedNumber get x() { return LevelDom.wrapSVGAnimatedNumber(_ptr.x); }

  SVGAnimatedNumber get y() { return LevelDom.wrapSVGAnimatedNumber(_ptr.y); }

  SVGAnimatedNumber get z() { return LevelDom.wrapSVGAnimatedNumber(_ptr.z); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFESpecularLightingElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFESpecularLightingElement {
  SVGFESpecularLightingElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }

  SVGAnimatedNumber get specularConstant() { return LevelDom.wrapSVGAnimatedNumber(_ptr.specularConstant); }

  SVGAnimatedNumber get specularExponent() { return LevelDom.wrapSVGAnimatedNumber(_ptr.specularExponent); }

  SVGAnimatedNumber get surfaceScale() { return LevelDom.wrapSVGAnimatedNumber(_ptr.surfaceScale); }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFESpotLightElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFESpotLightElement {
  SVGFESpotLightElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedNumber get limitingConeAngle() { return LevelDom.wrapSVGAnimatedNumber(_ptr.limitingConeAngle); }

  SVGAnimatedNumber get pointsAtX() { return LevelDom.wrapSVGAnimatedNumber(_ptr.pointsAtX); }

  SVGAnimatedNumber get pointsAtY() { return LevelDom.wrapSVGAnimatedNumber(_ptr.pointsAtY); }

  SVGAnimatedNumber get pointsAtZ() { return LevelDom.wrapSVGAnimatedNumber(_ptr.pointsAtZ); }

  SVGAnimatedNumber get specularExponent() { return LevelDom.wrapSVGAnimatedNumber(_ptr.specularExponent); }

  SVGAnimatedNumber get x() { return LevelDom.wrapSVGAnimatedNumber(_ptr.x); }

  SVGAnimatedNumber get y() { return LevelDom.wrapSVGAnimatedNumber(_ptr.y); }

  SVGAnimatedNumber get z() { return LevelDom.wrapSVGAnimatedNumber(_ptr.z); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFETileElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFETileElement {
  SVGFETileElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedString get in1() { return LevelDom.wrapSVGAnimatedString(_ptr.in1); }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFETurbulenceElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFETurbulenceElement {
  SVGFETurbulenceElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedNumber get baseFrequencyX() { return LevelDom.wrapSVGAnimatedNumber(_ptr.baseFrequencyX); }

  SVGAnimatedNumber get baseFrequencyY() { return LevelDom.wrapSVGAnimatedNumber(_ptr.baseFrequencyY); }

  SVGAnimatedInteger get numOctaves() { return LevelDom.wrapSVGAnimatedInteger(_ptr.numOctaves); }

  SVGAnimatedNumber get seed() { return LevelDom.wrapSVGAnimatedNumber(_ptr.seed); }

  SVGAnimatedEnumeration get stitchTiles() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.stitchTiles); }

  SVGAnimatedEnumeration get type() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.type); }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFilterElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFilterElement {
  SVGFilterElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedInteger get filterResX() { return LevelDom.wrapSVGAnimatedInteger(_ptr.filterResX); }

  SVGAnimatedInteger get filterResY() { return LevelDom.wrapSVGAnimatedInteger(_ptr.filterResY); }

  SVGAnimatedEnumeration get filterUnits() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.filterUnits); }

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedEnumeration get primitiveUnits() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.primitiveUnits); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  void setFilterRes(int filterResX, int filterResY) {
    _ptr.setFilterRes(filterResX, filterResY);
    return;
  }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFilterPrimitiveStandardAttributesWrappingImplementation extends SVGStylableWrappingImplementation implements SVGFilterPrimitiveStandardAttributes {
  SVGFilterPrimitiveStandardAttributesWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedString get result() { return LevelDom.wrapSVGAnimatedString(_ptr.result); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFitToViewBoxWrappingImplementation extends DOMWrapperBase implements SVGFitToViewBox {
  SVGFitToViewBoxWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() { return LevelDom.wrapSVGAnimatedPreserveAspectRatio(_ptr.preserveAspectRatio); }

  SVGAnimatedRect get viewBox() { return LevelDom.wrapSVGAnimatedRect(_ptr.viewBox); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFontElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFontElement {
  SVGFontElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFontFaceElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFontFaceElement {
  SVGFontFaceElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFontFaceFormatElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFontFaceFormatElement {
  SVGFontFaceFormatElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFontFaceNameElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFontFaceNameElement {
  SVGFontFaceNameElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFontFaceSrcElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFontFaceSrcElement {
  SVGFontFaceSrcElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGFontFaceUriElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGFontFaceUriElement {
  SVGFontFaceUriElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGForeignObjectElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGForeignObjectElement {
  SVGForeignObjectElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGGElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGGElement {
  SVGGElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGGlyphElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGGlyphElement {
  SVGGlyphElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGGlyphRefElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGGlyphRefElement {
  SVGGlyphRefElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get dx() { return _ptr.dx; }

  void set dx(num value) { _ptr.dx = value; }

  num get dy() { return _ptr.dy; }

  void set dy(num value) { _ptr.dy = value; }

  String get format() { return _ptr.format; }

  void set format(String value) { _ptr.format = value; }

  String get glyphRef() { return _ptr.glyphRef; }

  void set glyphRef(String value) { _ptr.glyphRef = value; }

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGGradientElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGGradientElement {
  SVGGradientElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedTransformList get gradientTransform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.gradientTransform); }

  SVGAnimatedEnumeration get gradientUnits() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.gradientUnits); }

  SVGAnimatedEnumeration get spreadMethod() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.spreadMethod); }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGHKernElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGHKernElement {
  SVGHKernElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGImageElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGImageElement {
  SVGImageElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() { return LevelDom.wrapSVGAnimatedPreserveAspectRatio(_ptr.preserveAspectRatio); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGLangSpaceWrappingImplementation extends DOMWrapperBase implements SVGLangSpace {
  SVGLangSpaceWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGLengthListWrappingImplementation extends DOMWrapperBase implements SVGLengthList {
  SVGLengthListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get numberOfItems() { return _ptr.numberOfItems; }

  SVGLength appendItem(SVGLength item) {
    return LevelDom.wrapSVGLength(_ptr.appendItem(LevelDom.unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGLength getItem(int index) {
    return LevelDom.wrapSVGLength(_ptr.getItem(index));
  }

  SVGLength initialize(SVGLength item) {
    return LevelDom.wrapSVGLength(_ptr.initialize(LevelDom.unwrap(item)));
  }

  SVGLength insertItemBefore(SVGLength item, int index) {
    return LevelDom.wrapSVGLength(_ptr.insertItemBefore(LevelDom.unwrap(item), index));
  }

  SVGLength removeItem(int index) {
    return LevelDom.wrapSVGLength(_ptr.removeItem(index));
  }

  SVGLength replaceItem(SVGLength item, int index) {
    return LevelDom.wrapSVGLength(_ptr.replaceItem(LevelDom.unwrap(item), index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGLengthWrappingImplementation extends DOMWrapperBase implements SVGLength {
  SVGLengthWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get unitType() { return _ptr.unitType; }

  num get value() { return _ptr.value; }

  void set value(num value) { _ptr.value = value; }

  String get valueAsString() { return _ptr.valueAsString; }

  void set valueAsString(String value) { _ptr.valueAsString = value; }

  num get valueInSpecifiedUnits() { return _ptr.valueInSpecifiedUnits; }

  void set valueInSpecifiedUnits(num value) { _ptr.valueInSpecifiedUnits = value; }

  void convertToSpecifiedUnits(int unitType) {
    _ptr.convertToSpecifiedUnits(unitType);
    return;
  }

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) {
    _ptr.newValueSpecifiedUnits(unitType, valueInSpecifiedUnits);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGLineElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGLineElement {
  SVGLineElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get x1() { return LevelDom.wrapSVGAnimatedLength(_ptr.x1); }

  SVGAnimatedLength get x2() { return LevelDom.wrapSVGAnimatedLength(_ptr.x2); }

  SVGAnimatedLength get y1() { return LevelDom.wrapSVGAnimatedLength(_ptr.y1); }

  SVGAnimatedLength get y2() { return LevelDom.wrapSVGAnimatedLength(_ptr.y2); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGLinearGradientElementWrappingImplementation extends SVGGradientElementWrappingImplementation implements SVGLinearGradientElement {
  SVGLinearGradientElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get x1() { return LevelDom.wrapSVGAnimatedLength(_ptr.x1); }

  SVGAnimatedLength get x2() { return LevelDom.wrapSVGAnimatedLength(_ptr.x2); }

  SVGAnimatedLength get y1() { return LevelDom.wrapSVGAnimatedLength(_ptr.y1); }

  SVGAnimatedLength get y2() { return LevelDom.wrapSVGAnimatedLength(_ptr.y2); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGLocatableWrappingImplementation extends DOMWrapperBase implements SVGLocatable {
  SVGLocatableWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGMPathElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGMPathElement {
  SVGMPathElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGMarkerElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGMarkerElement {
  SVGMarkerElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get markerHeight() { return LevelDom.wrapSVGAnimatedLength(_ptr.markerHeight); }

  SVGAnimatedEnumeration get markerUnits() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.markerUnits); }

  SVGAnimatedLength get markerWidth() { return LevelDom.wrapSVGAnimatedLength(_ptr.markerWidth); }

  SVGAnimatedAngle get orientAngle() { return LevelDom.wrapSVGAnimatedAngle(_ptr.orientAngle); }

  SVGAnimatedEnumeration get orientType() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.orientType); }

  SVGAnimatedLength get refX() { return LevelDom.wrapSVGAnimatedLength(_ptr.refX); }

  SVGAnimatedLength get refY() { return LevelDom.wrapSVGAnimatedLength(_ptr.refY); }

  void setOrientToAngle(SVGAngle angle) {
    _ptr.setOrientToAngle(LevelDom.unwrap(angle));
    return;
  }

  void setOrientToAuto() {
    _ptr.setOrientToAuto();
    return;
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() { return LevelDom.wrapSVGAnimatedPreserveAspectRatio(_ptr.preserveAspectRatio); }

  SVGAnimatedRect get viewBox() { return LevelDom.wrapSVGAnimatedRect(_ptr.viewBox); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGMaskElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGMaskElement {
  SVGMaskElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedEnumeration get maskContentUnits() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.maskContentUnits); }

  SVGAnimatedEnumeration get maskUnits() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.maskUnits); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGMatrixWrappingImplementation extends DOMWrapperBase implements SVGMatrix {
  SVGMatrixWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get a() { return _ptr.a; }

  void set a(num value) { _ptr.a = value; }

  num get b() { return _ptr.b; }

  void set b(num value) { _ptr.b = value; }

  num get c() { return _ptr.c; }

  void set c(num value) { _ptr.c = value; }

  num get d() { return _ptr.d; }

  void set d(num value) { _ptr.d = value; }

  num get e() { return _ptr.e; }

  void set e(num value) { _ptr.e = value; }

  num get f() { return _ptr.f; }

  void set f(num value) { _ptr.f = value; }

  SVGMatrix flipX() {
    return LevelDom.wrapSVGMatrix(_ptr.flipX());
  }

  SVGMatrix flipY() {
    return LevelDom.wrapSVGMatrix(_ptr.flipY());
  }

  SVGMatrix inverse() {
    return LevelDom.wrapSVGMatrix(_ptr.inverse());
  }

  SVGMatrix multiply(SVGMatrix secondMatrix) {
    return LevelDom.wrapSVGMatrix(_ptr.multiply(LevelDom.unwrap(secondMatrix)));
  }

  SVGMatrix rotate(num angle) {
    return LevelDom.wrapSVGMatrix(_ptr.rotate(angle));
  }

  SVGMatrix rotateFromVector(num x, num y) {
    return LevelDom.wrapSVGMatrix(_ptr.rotateFromVector(x, y));
  }

  SVGMatrix scale(num scaleFactor) {
    return LevelDom.wrapSVGMatrix(_ptr.scale(scaleFactor));
  }

  SVGMatrix scaleNonUniform(num scaleFactorX, num scaleFactorY) {
    return LevelDom.wrapSVGMatrix(_ptr.scaleNonUniform(scaleFactorX, scaleFactorY));
  }

  SVGMatrix skewX(num angle) {
    return LevelDom.wrapSVGMatrix(_ptr.skewX(angle));
  }

  SVGMatrix skewY(num angle) {
    return LevelDom.wrapSVGMatrix(_ptr.skewY(angle));
  }

  SVGMatrix translate(num x, num y) {
    return LevelDom.wrapSVGMatrix(_ptr.translate(x, y));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGMetadataElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGMetadataElement {
  SVGMetadataElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGMissingGlyphElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGMissingGlyphElement {
  SVGMissingGlyphElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGNumberListWrappingImplementation extends DOMWrapperBase implements SVGNumberList {
  SVGNumberListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get numberOfItems() { return _ptr.numberOfItems; }

  SVGNumber appendItem(SVGNumber item) {
    return LevelDom.wrapSVGNumber(_ptr.appendItem(LevelDom.unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGNumber getItem(int index) {
    return LevelDom.wrapSVGNumber(_ptr.getItem(index));
  }

  SVGNumber initialize(SVGNumber item) {
    return LevelDom.wrapSVGNumber(_ptr.initialize(LevelDom.unwrap(item)));
  }

  SVGNumber insertItemBefore(SVGNumber item, int index) {
    return LevelDom.wrapSVGNumber(_ptr.insertItemBefore(LevelDom.unwrap(item), index));
  }

  SVGNumber removeItem(int index) {
    return LevelDom.wrapSVGNumber(_ptr.removeItem(index));
  }

  SVGNumber replaceItem(SVGNumber item, int index) {
    return LevelDom.wrapSVGNumber(_ptr.replaceItem(LevelDom.unwrap(item), index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGNumberWrappingImplementation extends DOMWrapperBase implements SVGNumber {
  SVGNumberWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get value() { return _ptr.value; }

  void set value(num value) { _ptr.value = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPaintWrappingImplementation extends SVGColorWrappingImplementation implements SVGPaint {
  SVGPaintWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get paintType() { return _ptr.paintType; }

  String get uri() { return _ptr.uri; }

  void setPaint(int paintType, String uri, String rgbColor, String iccColor) {
    _ptr.setPaint(paintType, uri, rgbColor, iccColor);
    return;
  }

  void setUri(String uri) {
    _ptr.setUri(uri);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGPathElement {
  SVGPathElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGPathSegList get animatedNormalizedPathSegList() { return LevelDom.wrapSVGPathSegList(_ptr.animatedNormalizedPathSegList); }

  SVGPathSegList get animatedPathSegList() { return LevelDom.wrapSVGPathSegList(_ptr.animatedPathSegList); }

  SVGPathSegList get normalizedPathSegList() { return LevelDom.wrapSVGPathSegList(_ptr.normalizedPathSegList); }

  SVGAnimatedNumber get pathLength() { return LevelDom.wrapSVGAnimatedNumber(_ptr.pathLength); }

  SVGPathSegList get pathSegList() { return LevelDom.wrapSVGPathSegList(_ptr.pathSegList); }

  SVGPathSegArcAbs createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) {
    return LevelDom.wrapSVGPathSegArcAbs(_ptr.createSVGPathSegArcAbs(x, y, r1, r2, angle, largeArcFlag, sweepFlag));
  }

  SVGPathSegArcRel createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) {
    return LevelDom.wrapSVGPathSegArcRel(_ptr.createSVGPathSegArcRel(x, y, r1, r2, angle, largeArcFlag, sweepFlag));
  }

  SVGPathSegClosePath createSVGPathSegClosePath() {
    return LevelDom.wrapSVGPathSegClosePath(_ptr.createSVGPathSegClosePath());
  }

  SVGPathSegCurvetoCubicAbs createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2) {
    return LevelDom.wrapSVGPathSegCurvetoCubicAbs(_ptr.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2));
  }

  SVGPathSegCurvetoCubicRel createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2) {
    return LevelDom.wrapSVGPathSegCurvetoCubicRel(_ptr.createSVGPathSegCurvetoCubicRel(x, y, x1, y1, x2, y2));
  }

  SVGPathSegCurvetoCubicSmoothAbs createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2) {
    return LevelDom.wrapSVGPathSegCurvetoCubicSmoothAbs(_ptr.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2));
  }

  SVGPathSegCurvetoCubicSmoothRel createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2) {
    return LevelDom.wrapSVGPathSegCurvetoCubicSmoothRel(_ptr.createSVGPathSegCurvetoCubicSmoothRel(x, y, x2, y2));
  }

  SVGPathSegCurvetoQuadraticAbs createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1) {
    return LevelDom.wrapSVGPathSegCurvetoQuadraticAbs(_ptr.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1));
  }

  SVGPathSegCurvetoQuadraticRel createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1) {
    return LevelDom.wrapSVGPathSegCurvetoQuadraticRel(_ptr.createSVGPathSegCurvetoQuadraticRel(x, y, x1, y1));
  }

  SVGPathSegCurvetoQuadraticSmoothAbs createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y) {
    return LevelDom.wrapSVGPathSegCurvetoQuadraticSmoothAbs(_ptr.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y));
  }

  SVGPathSegCurvetoQuadraticSmoothRel createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y) {
    return LevelDom.wrapSVGPathSegCurvetoQuadraticSmoothRel(_ptr.createSVGPathSegCurvetoQuadraticSmoothRel(x, y));
  }

  SVGPathSegLinetoAbs createSVGPathSegLinetoAbs(num x, num y) {
    return LevelDom.wrapSVGPathSegLinetoAbs(_ptr.createSVGPathSegLinetoAbs(x, y));
  }

  SVGPathSegLinetoHorizontalAbs createSVGPathSegLinetoHorizontalAbs(num x) {
    return LevelDom.wrapSVGPathSegLinetoHorizontalAbs(_ptr.createSVGPathSegLinetoHorizontalAbs(x));
  }

  SVGPathSegLinetoHorizontalRel createSVGPathSegLinetoHorizontalRel(num x) {
    return LevelDom.wrapSVGPathSegLinetoHorizontalRel(_ptr.createSVGPathSegLinetoHorizontalRel(x));
  }

  SVGPathSegLinetoRel createSVGPathSegLinetoRel(num x, num y) {
    return LevelDom.wrapSVGPathSegLinetoRel(_ptr.createSVGPathSegLinetoRel(x, y));
  }

  SVGPathSegLinetoVerticalAbs createSVGPathSegLinetoVerticalAbs(num y) {
    return LevelDom.wrapSVGPathSegLinetoVerticalAbs(_ptr.createSVGPathSegLinetoVerticalAbs(y));
  }

  SVGPathSegLinetoVerticalRel createSVGPathSegLinetoVerticalRel(num y) {
    return LevelDom.wrapSVGPathSegLinetoVerticalRel(_ptr.createSVGPathSegLinetoVerticalRel(y));
  }

  SVGPathSegMovetoAbs createSVGPathSegMovetoAbs(num x, num y) {
    return LevelDom.wrapSVGPathSegMovetoAbs(_ptr.createSVGPathSegMovetoAbs(x, y));
  }

  SVGPathSegMovetoRel createSVGPathSegMovetoRel(num x, num y) {
    return LevelDom.wrapSVGPathSegMovetoRel(_ptr.createSVGPathSegMovetoRel(x, y));
  }

  int getPathSegAtLength(num distance) {
    return _ptr.getPathSegAtLength(distance);
  }

  SVGPoint getPointAtLength(num distance) {
    return LevelDom.wrapSVGPoint(_ptr.getPointAtLength(distance));
  }

  num getTotalLength() {
    return _ptr.getTotalLength();
  }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegArcAbsWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegArcAbs {
  SVGPathSegArcAbsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get angle() { return _ptr.angle; }

  void set angle(num value) { _ptr.angle = value; }

  bool get largeArcFlag() { return _ptr.largeArcFlag; }

  void set largeArcFlag(bool value) { _ptr.largeArcFlag = value; }

  num get r1() { return _ptr.r1; }

  void set r1(num value) { _ptr.r1 = value; }

  num get r2() { return _ptr.r2; }

  void set r2(num value) { _ptr.r2 = value; }

  bool get sweepFlag() { return _ptr.sweepFlag; }

  void set sweepFlag(bool value) { _ptr.sweepFlag = value; }

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegArcRelWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegArcRel {
  SVGPathSegArcRelWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get angle() { return _ptr.angle; }

  void set angle(num value) { _ptr.angle = value; }

  bool get largeArcFlag() { return _ptr.largeArcFlag; }

  void set largeArcFlag(bool value) { _ptr.largeArcFlag = value; }

  num get r1() { return _ptr.r1; }

  void set r1(num value) { _ptr.r1 = value; }

  num get r2() { return _ptr.r2; }

  void set r2(num value) { _ptr.r2 = value; }

  bool get sweepFlag() { return _ptr.sweepFlag; }

  void set sweepFlag(bool value) { _ptr.sweepFlag = value; }

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegClosePathWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegClosePath {
  SVGPathSegClosePathWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegCurvetoCubicAbsWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegCurvetoCubicAbs {
  SVGPathSegCurvetoCubicAbsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get x1() { return _ptr.x1; }

  void set x1(num value) { _ptr.x1 = value; }

  num get x2() { return _ptr.x2; }

  void set x2(num value) { _ptr.x2 = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }

  num get y1() { return _ptr.y1; }

  void set y1(num value) { _ptr.y1 = value; }

  num get y2() { return _ptr.y2; }

  void set y2(num value) { _ptr.y2 = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegCurvetoCubicRelWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegCurvetoCubicRel {
  SVGPathSegCurvetoCubicRelWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get x1() { return _ptr.x1; }

  void set x1(num value) { _ptr.x1 = value; }

  num get x2() { return _ptr.x2; }

  void set x2(num value) { _ptr.x2 = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }

  num get y1() { return _ptr.y1; }

  void set y1(num value) { _ptr.y1 = value; }

  num get y2() { return _ptr.y2; }

  void set y2(num value) { _ptr.y2 = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegCurvetoCubicSmoothAbsWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegCurvetoCubicSmoothAbs {
  SVGPathSegCurvetoCubicSmoothAbsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get x2() { return _ptr.x2; }

  void set x2(num value) { _ptr.x2 = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }

  num get y2() { return _ptr.y2; }

  void set y2(num value) { _ptr.y2 = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegCurvetoCubicSmoothRelWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegCurvetoCubicSmoothRel {
  SVGPathSegCurvetoCubicSmoothRelWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get x2() { return _ptr.x2; }

  void set x2(num value) { _ptr.x2 = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }

  num get y2() { return _ptr.y2; }

  void set y2(num value) { _ptr.y2 = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegCurvetoQuadraticAbsWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegCurvetoQuadraticAbs {
  SVGPathSegCurvetoQuadraticAbsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get x1() { return _ptr.x1; }

  void set x1(num value) { _ptr.x1 = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }

  num get y1() { return _ptr.y1; }

  void set y1(num value) { _ptr.y1 = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegCurvetoQuadraticRelWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegCurvetoQuadraticRel {
  SVGPathSegCurvetoQuadraticRelWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get x1() { return _ptr.x1; }

  void set x1(num value) { _ptr.x1 = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }

  num get y1() { return _ptr.y1; }

  void set y1(num value) { _ptr.y1 = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegCurvetoQuadraticSmoothAbsWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegCurvetoQuadraticSmoothAbs {
  SVGPathSegCurvetoQuadraticSmoothAbsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegCurvetoQuadraticSmoothRelWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegCurvetoQuadraticSmoothRel {
  SVGPathSegCurvetoQuadraticSmoothRelWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegLinetoAbsWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegLinetoAbs {
  SVGPathSegLinetoAbsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegLinetoHorizontalAbsWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegLinetoHorizontalAbs {
  SVGPathSegLinetoHorizontalAbsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegLinetoHorizontalRelWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegLinetoHorizontalRel {
  SVGPathSegLinetoHorizontalRelWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegLinetoRelWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegLinetoRel {
  SVGPathSegLinetoRelWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegLinetoVerticalAbsWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegLinetoVerticalAbs {
  SVGPathSegLinetoVerticalAbsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegLinetoVerticalRelWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegLinetoVerticalRel {
  SVGPathSegLinetoVerticalRelWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegListWrappingImplementation extends DOMWrapperBase implements SVGPathSegList {
  SVGPathSegListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get numberOfItems() { return _ptr.numberOfItems; }

  SVGPathSeg appendItem(SVGPathSeg newItem) {
    return LevelDom.wrapSVGPathSeg(_ptr.appendItem(LevelDom.unwrap(newItem)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGPathSeg getItem(int index) {
    return LevelDom.wrapSVGPathSeg(_ptr.getItem(index));
  }

  SVGPathSeg initialize(SVGPathSeg newItem) {
    return LevelDom.wrapSVGPathSeg(_ptr.initialize(LevelDom.unwrap(newItem)));
  }

  SVGPathSeg insertItemBefore(SVGPathSeg newItem, int index) {
    return LevelDom.wrapSVGPathSeg(_ptr.insertItemBefore(LevelDom.unwrap(newItem), index));
  }

  SVGPathSeg removeItem(int index) {
    return LevelDom.wrapSVGPathSeg(_ptr.removeItem(index));
  }

  SVGPathSeg replaceItem(SVGPathSeg newItem, int index) {
    return LevelDom.wrapSVGPathSeg(_ptr.replaceItem(LevelDom.unwrap(newItem), index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegMovetoAbsWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegMovetoAbs {
  SVGPathSegMovetoAbsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegMovetoRelWrappingImplementation extends SVGPathSegWrappingImplementation implements SVGPathSegMovetoRel {
  SVGPathSegMovetoRelWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPathSegWrappingImplementation extends DOMWrapperBase implements SVGPathSeg {
  SVGPathSegWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get pathSegType() { return _ptr.pathSegType; }

  String get pathSegTypeAsLetter() { return _ptr.pathSegTypeAsLetter; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPatternElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGPatternElement {
  SVGPatternElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedEnumeration get patternContentUnits() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.patternContentUnits); }

  SVGAnimatedTransformList get patternTransform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.patternTransform); }

  SVGAnimatedEnumeration get patternUnits() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.patternUnits); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() { return LevelDom.wrapSVGAnimatedPreserveAspectRatio(_ptr.preserveAspectRatio); }

  SVGAnimatedRect get viewBox() { return LevelDom.wrapSVGAnimatedRect(_ptr.viewBox); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPointListWrappingImplementation extends DOMWrapperBase implements SVGPointList {
  SVGPointListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get numberOfItems() { return _ptr.numberOfItems; }

  SVGPoint appendItem(SVGPoint item) {
    return LevelDom.wrapSVGPoint(_ptr.appendItem(LevelDom.unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGPoint getItem(int index) {
    return LevelDom.wrapSVGPoint(_ptr.getItem(index));
  }

  SVGPoint initialize(SVGPoint item) {
    return LevelDom.wrapSVGPoint(_ptr.initialize(LevelDom.unwrap(item)));
  }

  SVGPoint insertItemBefore(SVGPoint item, int index) {
    return LevelDom.wrapSVGPoint(_ptr.insertItemBefore(LevelDom.unwrap(item), index));
  }

  SVGPoint removeItem(int index) {
    return LevelDom.wrapSVGPoint(_ptr.removeItem(index));
  }

  SVGPoint replaceItem(SVGPoint item, int index) {
    return LevelDom.wrapSVGPoint(_ptr.replaceItem(LevelDom.unwrap(item), index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPointWrappingImplementation extends DOMWrapperBase implements SVGPoint {
  SVGPointWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }

  SVGPoint matrixTransform(SVGMatrix matrix) {
    return LevelDom.wrapSVGPoint(_ptr.matrixTransform(LevelDom.unwrap(matrix)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPolygonElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGPolygonElement {
  SVGPolygonElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGPointList get animatedPoints() { return LevelDom.wrapSVGPointList(_ptr.animatedPoints); }

  SVGPointList get points() { return LevelDom.wrapSVGPointList(_ptr.points); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPolylineElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGPolylineElement {
  SVGPolylineElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGPointList get animatedPoints() { return LevelDom.wrapSVGPointList(_ptr.animatedPoints); }

  SVGPointList get points() { return LevelDom.wrapSVGPointList(_ptr.points); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGPreserveAspectRatioWrappingImplementation extends DOMWrapperBase implements SVGPreserveAspectRatio {
  SVGPreserveAspectRatioWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get align() { return _ptr.align; }

  void set align(int value) { _ptr.align = value; }

  int get meetOrSlice() { return _ptr.meetOrSlice; }

  void set meetOrSlice(int value) { _ptr.meetOrSlice = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGRadialGradientElementWrappingImplementation extends SVGGradientElementWrappingImplementation implements SVGRadialGradientElement {
  SVGRadialGradientElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get cx() { return LevelDom.wrapSVGAnimatedLength(_ptr.cx); }

  SVGAnimatedLength get cy() { return LevelDom.wrapSVGAnimatedLength(_ptr.cy); }

  SVGAnimatedLength get fx() { return LevelDom.wrapSVGAnimatedLength(_ptr.fx); }

  SVGAnimatedLength get fy() { return LevelDom.wrapSVGAnimatedLength(_ptr.fy); }

  SVGAnimatedLength get r() { return LevelDom.wrapSVGAnimatedLength(_ptr.r); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGRectElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGRectElement {
  SVGRectElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGAnimatedLength get rx() { return LevelDom.wrapSVGAnimatedLength(_ptr.rx); }

  SVGAnimatedLength get ry() { return LevelDom.wrapSVGAnimatedLength(_ptr.ry); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGRectWrappingImplementation extends DOMWrapperBase implements SVGRect {
  SVGRectWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get height() { return _ptr.height; }

  void set height(num value) { _ptr.height = value; }

  num get width() { return _ptr.width; }

  void set width(num value) { _ptr.width = value; }

  num get x() { return _ptr.x; }

  void set x(num value) { _ptr.x = value; }

  num get y() { return _ptr.y; }

  void set y(num value) { _ptr.y = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGRenderingIntentWrappingImplementation extends DOMWrapperBase implements SVGRenderingIntent {
  SVGRenderingIntentWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGScriptElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGScriptElement {
  SVGScriptElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGSetElementWrappingImplementation extends SVGAnimationElementWrappingImplementation implements SVGSetElement {
  SVGSetElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGStopElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGStopElement {
  SVGStopElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedNumber get offset() { return LevelDom.wrapSVGAnimatedNumber(_ptr.offset); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGStringListWrappingImplementation extends DOMWrapperBase implements SVGStringList {
  SVGStringListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get numberOfItems() { return _ptr.numberOfItems; }

  String appendItem(String item) {
    return _ptr.appendItem(item);
  }

  void clear() {
    _ptr.clear();
    return;
  }

  String getItem(int index) {
    return _ptr.getItem(index);
  }

  String initialize(String item) {
    return _ptr.initialize(item);
  }

  String insertItemBefore(String item, int index) {
    return _ptr.insertItemBefore(item, index);
  }

  String removeItem(int index) {
    return _ptr.removeItem(index);
  }

  String replaceItem(String item, int index) {
    return _ptr.replaceItem(item, index);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGStylableWrappingImplementation extends DOMWrapperBase implements SVGStylable {
  SVGStylableWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGStyleElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGStyleElement {
  SVGStyleElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get media() { return _ptr.media; }

  void set media(String value) { _ptr.media = value; }

  String get title() { return _ptr.title; }

  void set title(String value) { _ptr.title = value; }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGSwitchElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGSwitchElement {
  SVGSwitchElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGSymbolElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGSymbolElement {
  SVGSymbolElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() { return LevelDom.wrapSVGAnimatedPreserveAspectRatio(_ptr.preserveAspectRatio); }

  SVGAnimatedRect get viewBox() { return LevelDom.wrapSVGAnimatedRect(_ptr.viewBox); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGTRefElementWrappingImplementation extends SVGTextPositioningElementWrappingImplementation implements SVGTRefElement {
  SVGTRefElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGTSpanElementWrappingImplementation extends SVGTextPositioningElementWrappingImplementation implements SVGTSpanElement {
  SVGTSpanElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGTestsWrappingImplementation extends DOMWrapperBase implements SVGTests {
  SVGTestsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGTextContentElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGTextContentElement {
  SVGTextContentElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedEnumeration get lengthAdjust() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.lengthAdjust); }

  SVGAnimatedLength get textLength() { return LevelDom.wrapSVGAnimatedLength(_ptr.textLength); }

  int getCharNumAtPosition(SVGPoint point) {
    return _ptr.getCharNumAtPosition(LevelDom.unwrap(point));
  }

  num getComputedTextLength() {
    return _ptr.getComputedTextLength();
  }

  SVGPoint getEndPositionOfChar(int offset) {
    return LevelDom.wrapSVGPoint(_ptr.getEndPositionOfChar(offset));
  }

  SVGRect getExtentOfChar(int offset) {
    return LevelDom.wrapSVGRect(_ptr.getExtentOfChar(offset));
  }

  int getNumberOfChars() {
    return _ptr.getNumberOfChars();
  }

  num getRotationOfChar(int offset) {
    return _ptr.getRotationOfChar(offset);
  }

  SVGPoint getStartPositionOfChar(int offset) {
    return LevelDom.wrapSVGPoint(_ptr.getStartPositionOfChar(offset));
  }

  num getSubStringLength(int offset, int length) {
    return _ptr.getSubStringLength(offset, length);
  }

  void selectSubString(int offset, int length) {
    _ptr.selectSubString(offset, length);
    return;
  }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGTextElementWrappingImplementation extends SVGTextPositioningElementWrappingImplementation implements SVGTextElement {
  SVGTextElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGTextPathElementWrappingImplementation extends SVGTextContentElementWrappingImplementation implements SVGTextPathElement {
  SVGTextPathElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedEnumeration get method() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.method); }

  SVGAnimatedEnumeration get spacing() { return LevelDom.wrapSVGAnimatedEnumeration(_ptr.spacing); }

  SVGAnimatedLength get startOffset() { return LevelDom.wrapSVGAnimatedLength(_ptr.startOffset); }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGTextPositioningElementWrappingImplementation extends SVGTextContentElementWrappingImplementation implements SVGTextPositioningElement {
  SVGTextPositioningElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedLengthList get dx() { return LevelDom.wrapSVGAnimatedLengthList(_ptr.dx); }

  SVGAnimatedLengthList get dy() { return LevelDom.wrapSVGAnimatedLengthList(_ptr.dy); }

  SVGAnimatedNumberList get rotate() { return LevelDom.wrapSVGAnimatedNumberList(_ptr.rotate); }

  SVGAnimatedLengthList get x() { return LevelDom.wrapSVGAnimatedLengthList(_ptr.x); }

  SVGAnimatedLengthList get y() { return LevelDom.wrapSVGAnimatedLengthList(_ptr.y); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGTitleElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGTitleElement {
  SVGTitleElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGTransformListWrappingImplementation extends DOMWrapperBase implements SVGTransformList {
  SVGTransformListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get numberOfItems() { return _ptr.numberOfItems; }

  SVGTransform appendItem(SVGTransform item) {
    return LevelDom.wrapSVGTransform(_ptr.appendItem(LevelDom.unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGTransform consolidate() {
    return LevelDom.wrapSVGTransform(_ptr.consolidate());
  }

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) {
    return LevelDom.wrapSVGTransform(_ptr.createSVGTransformFromMatrix(LevelDom.unwrap(matrix)));
  }

  SVGTransform getItem(int index) {
    return LevelDom.wrapSVGTransform(_ptr.getItem(index));
  }

  SVGTransform initialize(SVGTransform item) {
    return LevelDom.wrapSVGTransform(_ptr.initialize(LevelDom.unwrap(item)));
  }

  SVGTransform insertItemBefore(SVGTransform item, int index) {
    return LevelDom.wrapSVGTransform(_ptr.insertItemBefore(LevelDom.unwrap(item), index));
  }

  SVGTransform removeItem(int index) {
    return LevelDom.wrapSVGTransform(_ptr.removeItem(index));
  }

  SVGTransform replaceItem(SVGTransform item, int index) {
    return LevelDom.wrapSVGTransform(_ptr.replaceItem(LevelDom.unwrap(item), index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGTransformWrappingImplementation extends DOMWrapperBase implements SVGTransform {
  SVGTransformWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get angle() { return _ptr.angle; }

  SVGMatrix get matrix() { return LevelDom.wrapSVGMatrix(_ptr.matrix); }

  int get type() { return _ptr.type; }

  void setMatrix(SVGMatrix matrix) {
    _ptr.setMatrix(LevelDom.unwrap(matrix));
    return;
  }

  void setRotate(num angle, num cx, num cy) {
    _ptr.setRotate(angle, cx, cy);
    return;
  }

  void setScale(num sx, num sy) {
    _ptr.setScale(sx, sy);
    return;
  }

  void setSkewX(num angle) {
    _ptr.setSkewX(angle);
    return;
  }

  void setSkewY(num angle) {
    _ptr.setSkewY(angle);
    return;
  }

  void setTranslate(num tx, num ty) {
    _ptr.setTranslate(tx, ty);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGTransformableWrappingImplementation extends SVGLocatableWrappingImplementation implements SVGTransformable {
  SVGTransformableWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGURIReferenceWrappingImplementation extends DOMWrapperBase implements SVGURIReference {
  SVGURIReferenceWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGUnitTypesWrappingImplementation extends DOMWrapperBase implements SVGUnitTypes {
  SVGUnitTypesWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGUseElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGUseElement {
  SVGUseElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGElementInstance get animatedInstanceRoot() { return LevelDom.wrapSVGElementInstance(_ptr.animatedInstanceRoot); }

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  SVGElementInstance get instanceRoot() { return LevelDom.wrapSVGElementInstance(_ptr.instanceRoot); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  // From SVGURIReference

  SVGAnimatedString get href() { return LevelDom.wrapSVGAnimatedString(_ptr.href); }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() { return LevelDom.wrapSVGAnimatedTransformList(_ptr.transform); }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGVKernElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGVKernElement {
  SVGVKernElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGViewElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGViewElement {
  SVGViewElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGStringList get viewTarget() { return LevelDom.wrapSVGStringList(_ptr.viewTarget); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() { return LevelDom.wrapSVGAnimatedPreserveAspectRatio(_ptr.preserveAspectRatio); }

  SVGAnimatedRect get viewBox() { return LevelDom.wrapSVGAnimatedRect(_ptr.viewBox); }

  // From SVGZoomAndPan

  int get zoomAndPan() { return _ptr.zoomAndPan; }

  void set zoomAndPan(int value) { _ptr.zoomAndPan = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGViewSpecWrappingImplementation extends SVGZoomAndPanWrappingImplementation implements SVGViewSpec {
  SVGViewSpecWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get preserveAspectRatioString() { return _ptr.preserveAspectRatioString; }

  SVGTransformList get transform() { return LevelDom.wrapSVGTransformList(_ptr.transform); }

  String get transformString() { return _ptr.transformString; }

  String get viewBoxString() { return _ptr.viewBoxString; }

  SVGElement get viewTarget() { return LevelDom.wrapSVGElement(_ptr.viewTarget); }

  String get viewTargetString() { return _ptr.viewTargetString; }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() { return LevelDom.wrapSVGAnimatedPreserveAspectRatio(_ptr.preserveAspectRatio); }

  SVGAnimatedRect get viewBox() { return LevelDom.wrapSVGAnimatedRect(_ptr.viewBox); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGZoomAndPanWrappingImplementation extends DOMWrapperBase implements SVGZoomAndPan {
  SVGZoomAndPanWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get zoomAndPan() { return _ptr.zoomAndPan; }

  void set zoomAndPan(int value) { _ptr.zoomAndPan = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGZoomEventWrappingImplementation extends UIEventWrappingImplementation implements SVGZoomEvent {
  SVGZoomEventWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get newScale() { return _ptr.newScale; }

  SVGPoint get newTranslate() { return LevelDom.wrapSVGPoint(_ptr.newTranslate); }

  num get previousScale() { return _ptr.previousScale; }

  SVGPoint get previousTranslate() { return LevelDom.wrapSVGPoint(_ptr.previousTranslate); }

  SVGRect get zoomRectScreen() { return LevelDom.wrapSVGRect(_ptr.zoomRectScreen); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ScreenWrappingImplementation extends DOMWrapperBase implements Screen {
  ScreenWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get availHeight() { return _ptr.availHeight; }

  int get availLeft() { return _ptr.availLeft; }

  int get availTop() { return _ptr.availTop; }

  int get availWidth() { return _ptr.availWidth; }

  int get colorDepth() { return _ptr.colorDepth; }

  int get height() { return _ptr.height; }

  int get pixelDepth() { return _ptr.pixelDepth; }

  int get width() { return _ptr.width; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ScriptElementWrappingImplementation extends ElementWrappingImplementation implements ScriptElement {
  ScriptElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get async() { return _ptr.async; }

  void set async(bool value) { _ptr.async = value; }

  String get charset() { return _ptr.charset; }

  void set charset(String value) { _ptr.charset = value; }

  bool get defer() { return _ptr.defer; }

  void set defer(bool value) { _ptr.defer = value; }

  String get event() { return _ptr.event; }

  void set event(String value) { _ptr.event = value; }

  String get htmlFor() { return _ptr.htmlFor; }

  void set htmlFor(String value) { _ptr.htmlFor = value; }

  String get src() { return _ptr.src; }

  void set src(String value) { _ptr.src = value; }

  String get text() { return _ptr.text; }

  void set text(String value) { _ptr.text = value; }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SelectElementWrappingImplementation extends ElementWrappingImplementation implements SelectElement {
  SelectElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get autofocus() { return _ptr.autofocus; }

  void set autofocus(bool value) { _ptr.autofocus = value; }

  bool get disabled() { return _ptr.disabled; }

  void set disabled(bool value) { _ptr.disabled = value; }

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  ElementList get labels() { return LevelDom.wrapElementList(_ptr.labels); }

  int get length() { return _ptr.length; }

  void set length(int value) { _ptr.length = value; }

  bool get multiple() { return _ptr.multiple; }

  void set multiple(bool value) { _ptr.multiple = value; }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  ElementList get options() { return LevelDom.wrapElementList(_ptr.options); }

  bool get required() { return _ptr.required; }

  void set required(bool value) { _ptr.required = value; }

  int get selectedIndex() { return _ptr.selectedIndex; }

  void set selectedIndex(int value) { _ptr.selectedIndex = value; }

  int get size() { return _ptr.size; }

  void set size(int value) { _ptr.size = value; }

  String get type() { return _ptr.type; }

  String get validationMessage() { return _ptr.validationMessage; }

  ValidityState get validity() { return LevelDom.wrapValidityState(_ptr.validity); }

  String get value() { return _ptr.value; }

  void set value(String value) { _ptr.value = value; }

  bool get willValidate() { return _ptr.willValidate; }

  void add(Element element, Element before) {
    _ptr.add(LevelDom.unwrap(element), LevelDom.unwrap(before));
    return;
  }

  bool checkValidity() {
    return _ptr.checkValidity();
  }

  Node item(int index) {
    return LevelDom.wrapNode(_ptr.item(index));
  }

  Node namedItem(String name) {
    return LevelDom.wrapNode(_ptr.namedItem(name));
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(error);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SourceElementWrappingImplementation extends ElementWrappingImplementation implements SourceElement {
  SourceElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get media() { return _ptr.media; }

  void set media(String value) { _ptr.media = value; }

  String get src() { return _ptr.src; }

  void set src(String value) { _ptr.src = value; }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SpanElementWrappingImplementation extends ElementWrappingImplementation implements SpanElement {
  SpanElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SpeechInputEventWrappingImplementation extends EventWrappingImplementation implements SpeechInputEvent {
  SpeechInputEventWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SpeechInputResultList get results() { return LevelDom.wrapSpeechInputResultList(_ptr.results); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SpeechInputResultListWrappingImplementation extends DOMWrapperBase implements SpeechInputResultList {
  SpeechInputResultListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  SpeechInputResult item(int index) {
    return LevelDom.wrapSpeechInputResult(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SpeechInputResultWrappingImplementation extends DOMWrapperBase implements SpeechInputResult {
  SpeechInputResultWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get confidence() { return _ptr.confidence; }

  String get utterance() { return _ptr.utterance; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class StorageInfoWrappingImplementation extends DOMWrapperBase implements StorageInfo {
  StorageInfoWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback, StorageInfoErrorCallback errorCallback]) {
    if (usageCallback === null) {
      if (errorCallback === null) {
        _ptr.queryUsageAndQuota(storageType);
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.queryUsageAndQuota(storageType, LevelDom.unwrap(usageCallback));
        return;
      } else {
        _ptr.queryUsageAndQuota(storageType, LevelDom.unwrap(usageCallback), errorCallback);
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback, StorageInfoErrorCallback errorCallback]) {
    if (quotaCallback === null) {
      if (errorCallback === null) {
        _ptr.requestQuota(storageType, newQuotaInBytes);
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.requestQuota(storageType, newQuotaInBytes, quotaCallback);
        return;
      } else {
        _ptr.requestQuota(storageType, newQuotaInBytes, quotaCallback, errorCallback);
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class StorageWrappingImplementation extends DOMWrapperBase implements Storage {
  StorageWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  void clear() {
    _ptr.clear();
    return;
  }

  String getItem(String key_) {
    return _ptr.getItem(key_);
  }

  String key(int index) {
    return _ptr.key(index);
  }

  void removeItem(String key_) {
    _ptr.removeItem(key_);
    return;
  }

  void setItem(String key_, String data) {
    _ptr.setItem(key_, data);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class StyleElementWrappingImplementation extends ElementWrappingImplementation implements StyleElement {
  StyleElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get disabled() { return _ptr.disabled; }

  void set disabled(bool value) { _ptr.disabled = value; }

  String get media() { return _ptr.media; }

  void set media(String value) { _ptr.media = value; }

  StyleSheet get sheet() { return LevelDom.wrapStyleSheet(_ptr.sheet); }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class StyleMediaWrappingImplementation extends DOMWrapperBase implements StyleMedia {
  StyleMediaWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get type() { return _ptr.type; }

  bool matchMedium(String mediaquery) {
    return _ptr.matchMedium(mediaquery);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class StyleSheetListWrappingImplementation extends DOMWrapperBase implements StyleSheetList {
  StyleSheetListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  StyleSheet operator[](int index) {
    return LevelDom.wrapStyleSheet(_ptr[index]);
  }

  void operator[]=(int index, StyleSheet value) {
    _ptr[index] = LevelDom.unwrap(value);
  }

  void add(StyleSheet value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(StyleSheet value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<StyleSheet> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(StyleSheet a, StyleSheet b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(StyleSheet element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(StyleSheet element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  StyleSheet removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  StyleSheet last() {
    return this[length - 1];
  }

  void forEach(void f(StyleSheet element)) {
    _Collections.forEach(this, f);
  }

  Collection<StyleSheet> filter(bool f(StyleSheet element)) {
    return _Collections.filter(this, new List<StyleSheet>(), f);
  }

  bool every(bool f(StyleSheet element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(StyleSheet element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<StyleSheet> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [StyleSheet initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<StyleSheet> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<StyleSheet> iterator() {
    return new _FixedSizeListIterator<StyleSheet>(this);
  }

  StyleSheet item(int index) {
    return LevelDom.wrapStyleSheet(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class StyleSheetWrappingImplementation extends DOMWrapperBase implements StyleSheet {
  StyleSheetWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get disabled() { return _ptr.disabled; }

  void set disabled(bool value) { _ptr.disabled = value; }

  String get href() { return _ptr.href; }

  MediaList get media() { return LevelDom.wrapMediaList(_ptr.media); }

  Node get ownerNode() { return LevelDom.wrapNode(_ptr.ownerNode); }

  StyleSheet get parentStyleSheet() { return LevelDom.wrapStyleSheet(_ptr.parentStyleSheet); }

  String get title() { return _ptr.title; }

  String get type() { return _ptr.type; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TableCaptionElementWrappingImplementation extends ElementWrappingImplementation implements TableCaptionElement {
  TableCaptionElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TableCellElementWrappingImplementation extends ElementWrappingImplementation implements TableCellElement {
  TableCellElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get abbr() { return _ptr.abbr; }

  void set abbr(String value) { _ptr.abbr = value; }

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  String get axis() { return _ptr.axis; }

  void set axis(String value) { _ptr.axis = value; }

  String get bgColor() { return _ptr.bgColor; }

  void set bgColor(String value) { _ptr.bgColor = value; }

  int get cellIndex() { return _ptr.cellIndex; }

  String get ch() { return _ptr.ch; }

  void set ch(String value) { _ptr.ch = value; }

  String get chOff() { return _ptr.chOff; }

  void set chOff(String value) { _ptr.chOff = value; }

  int get colSpan() { return _ptr.colSpan; }

  void set colSpan(int value) { _ptr.colSpan = value; }

  String get headers() { return _ptr.headers; }

  void set headers(String value) { _ptr.headers = value; }

  String get height() { return _ptr.height; }

  void set height(String value) { _ptr.height = value; }

  bool get noWrap() { return _ptr.noWrap; }

  void set noWrap(bool value) { _ptr.noWrap = value; }

  int get rowSpan() { return _ptr.rowSpan; }

  void set rowSpan(int value) { _ptr.rowSpan = value; }

  String get scope() { return _ptr.scope; }

  void set scope(String value) { _ptr.scope = value; }

  String get vAlign() { return _ptr.vAlign; }

  void set vAlign(String value) { _ptr.vAlign = value; }

  String get width() { return _ptr.width; }

  void set width(String value) { _ptr.width = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TableColElementWrappingImplementation extends ElementWrappingImplementation implements TableColElement {
  TableColElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  String get ch() { return _ptr.ch; }

  void set ch(String value) { _ptr.ch = value; }

  String get chOff() { return _ptr.chOff; }

  void set chOff(String value) { _ptr.chOff = value; }

  int get span() { return _ptr.span; }

  void set span(int value) { _ptr.span = value; }

  String get vAlign() { return _ptr.vAlign; }

  void set vAlign(String value) { _ptr.vAlign = value; }

  String get width() { return _ptr.width; }

  void set width(String value) { _ptr.width = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TableElementWrappingImplementation extends ElementWrappingImplementation implements TableElement {
  TableElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  String get bgColor() { return _ptr.bgColor; }

  void set bgColor(String value) { _ptr.bgColor = value; }

  String get border() { return _ptr.border; }

  void set border(String value) { _ptr.border = value; }

  TableCaptionElement get caption() { return LevelDom.wrapTableCaptionElement(_ptr.caption); }

  void set caption(TableCaptionElement value) { _ptr.caption = LevelDom.unwrap(value); }

  String get cellPadding() { return _ptr.cellPadding; }

  void set cellPadding(String value) { _ptr.cellPadding = value; }

  String get cellSpacing() { return _ptr.cellSpacing; }

  void set cellSpacing(String value) { _ptr.cellSpacing = value; }

  String get frame() { return _ptr.frame; }

  void set frame(String value) { _ptr.frame = value; }

  ElementList get rows() { return LevelDom.wrapElementList(_ptr.rows); }

  String get rules() { return _ptr.rules; }

  void set rules(String value) { _ptr.rules = value; }

  String get summary() { return _ptr.summary; }

  void set summary(String value) { _ptr.summary = value; }

  ElementList get tBodies() { return LevelDom.wrapElementList(_ptr.tBodies); }

  TableSectionElement get tFoot() { return LevelDom.wrapTableSectionElement(_ptr.tFoot); }

  void set tFoot(TableSectionElement value) { _ptr.tFoot = LevelDom.unwrap(value); }

  TableSectionElement get tHead() { return LevelDom.wrapTableSectionElement(_ptr.tHead); }

  void set tHead(TableSectionElement value) { _ptr.tHead = LevelDom.unwrap(value); }

  String get width() { return _ptr.width; }

  void set width(String value) { _ptr.width = value; }

  Element createCaption() {
    return LevelDom.wrapElement(_ptr.createCaption());
  }

  Element createTFoot() {
    return LevelDom.wrapElement(_ptr.createTFoot());
  }

  Element createTHead() {
    return LevelDom.wrapElement(_ptr.createTHead());
  }

  void deleteCaption() {
    _ptr.deleteCaption();
    return;
  }

  void deleteRow(int index) {
    _ptr.deleteRow(index);
    return;
  }

  void deleteTFoot() {
    _ptr.deleteTFoot();
    return;
  }

  void deleteTHead() {
    _ptr.deleteTHead();
    return;
  }

  Element insertRow(int index) {
    return LevelDom.wrapElement(_ptr.insertRow(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TableRowElementWrappingImplementation extends ElementWrappingImplementation implements TableRowElement {
  TableRowElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  String get bgColor() { return _ptr.bgColor; }

  void set bgColor(String value) { _ptr.bgColor = value; }

  ElementList get cells() { return LevelDom.wrapElementList(_ptr.cells); }

  String get ch() { return _ptr.ch; }

  void set ch(String value) { _ptr.ch = value; }

  String get chOff() { return _ptr.chOff; }

  void set chOff(String value) { _ptr.chOff = value; }

  int get rowIndex() { return _ptr.rowIndex; }

  int get sectionRowIndex() { return _ptr.sectionRowIndex; }

  String get vAlign() { return _ptr.vAlign; }

  void set vAlign(String value) { _ptr.vAlign = value; }

  void deleteCell(int index) {
    _ptr.deleteCell(index);
    return;
  }

  Element insertCell(int index) {
    return LevelDom.wrapElement(_ptr.insertCell(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TableSectionElementWrappingImplementation extends ElementWrappingImplementation implements TableSectionElement {
  TableSectionElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  String get ch() { return _ptr.ch; }

  void set ch(String value) { _ptr.ch = value; }

  String get chOff() { return _ptr.chOff; }

  void set chOff(String value) { _ptr.chOff = value; }

  ElementList get rows() { return LevelDom.wrapElementList(_ptr.rows); }

  String get vAlign() { return _ptr.vAlign; }

  void set vAlign(String value) { _ptr.vAlign = value; }

  void deleteRow(int index) {
    _ptr.deleteRow(index);
    return;
  }

  Element insertRow(int index) {
    return LevelDom.wrapElement(_ptr.insertRow(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TextAreaElementWrappingImplementation extends ElementWrappingImplementation implements TextAreaElement {
  TextAreaElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get accessKey() { return _ptr.accessKey; }

  void set accessKey(String value) { _ptr.accessKey = value; }

  bool get autofocus() { return _ptr.autofocus; }

  void set autofocus(bool value) { _ptr.autofocus = value; }

  int get cols() { return _ptr.cols; }

  void set cols(int value) { _ptr.cols = value; }

  String get defaultValue() { return _ptr.defaultValue; }

  void set defaultValue(String value) { _ptr.defaultValue = value; }

  bool get disabled() { return _ptr.disabled; }

  void set disabled(bool value) { _ptr.disabled = value; }

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  ElementList get labels() { return LevelDom.wrapElementList(_ptr.labels); }

  int get maxLength() { return _ptr.maxLength; }

  void set maxLength(int value) { _ptr.maxLength = value; }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  String get placeholder() { return _ptr.placeholder; }

  void set placeholder(String value) { _ptr.placeholder = value; }

  bool get readOnly() { return _ptr.readOnly; }

  void set readOnly(bool value) { _ptr.readOnly = value; }

  bool get required() { return _ptr.required; }

  void set required(bool value) { _ptr.required = value; }

  int get rows() { return _ptr.rows; }

  void set rows(int value) { _ptr.rows = value; }

  String get selectionDirection() { return _ptr.selectionDirection; }

  void set selectionDirection(String value) { _ptr.selectionDirection = value; }

  int get selectionEnd() { return _ptr.selectionEnd; }

  void set selectionEnd(int value) { _ptr.selectionEnd = value; }

  int get selectionStart() { return _ptr.selectionStart; }

  void set selectionStart(int value) { _ptr.selectionStart = value; }

  int get textLength() { return _ptr.textLength; }

  String get type() { return _ptr.type; }

  String get validationMessage() { return _ptr.validationMessage; }

  ValidityState get validity() { return LevelDom.wrapValidityState(_ptr.validity); }

  String get value() { return _ptr.value; }

  void set value(String value) { _ptr.value = value; }

  bool get willValidate() { return _ptr.willValidate; }

  String get wrap() { return _ptr.wrap; }

  void set wrap(String value) { _ptr.wrap = value; }

  bool checkValidity() {
    return _ptr.checkValidity();
  }

  void select() {
    _ptr.select();
    return;
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(error);
    return;
  }

  void setSelectionRange(int start, int end, [String direction]) {
    if (direction === null) {
      _ptr.setSelectionRange(start, end);
      return;
    } else {
      _ptr.setSelectionRange(start, end, direction);
      return;
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TextMetricsWrappingImplementation extends DOMWrapperBase implements TextMetrics {
  TextMetricsWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  num get width() { return _ptr.width; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TextTrackCueListWrappingImplementation extends DOMWrapperBase implements TextTrackCueList {
  TextTrackCueListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  TextTrackCue getCueById(String id) {
    return LevelDom.wrapTextTrackCue(_ptr.getCueById(id));
  }

  TextTrackCue item(int index) {
    return LevelDom.wrapTextTrackCue(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TextTrackCueWrappingImplementation extends DOMWrapperBase implements TextTrackCue {
  TextTrackCueWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get alignment() { return _ptr.alignment; }

  String get direction() { return _ptr.direction; }

  num get endTime() { return _ptr.endTime; }

  String get id() { return _ptr.id; }

  int get linePosition() { return _ptr.linePosition; }

  bool get pauseOnExit() { return _ptr.pauseOnExit; }

  int get size() { return _ptr.size; }

  bool get snapToLines() { return _ptr.snapToLines; }

  num get startTime() { return _ptr.startTime; }

  int get textPosition() { return _ptr.textPosition; }

  TextTrack get track() { return LevelDom.wrapTextTrack(_ptr.track); }

  DocumentFragment getCueAsHTML() {
    return LevelDom.wrapDocumentFragment(_ptr.getCueAsHTML());
  }

  String getCueAsSource() {
    return _ptr.getCueAsSource();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TextTrackWrappingImplementation extends DOMWrapperBase implements TextTrack {
  TextTrackWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  TextTrackCueList get activeCues() { return LevelDom.wrapTextTrackCueList(_ptr.activeCues); }

  TextTrackCueList get cues() { return LevelDom.wrapTextTrackCueList(_ptr.cues); }

  String get kind() { return _ptr.kind; }

  String get label() { return _ptr.label; }

  String get language() { return _ptr.language; }

  int get mode() { return _ptr.mode; }

  void set mode(int value) { _ptr.mode = value; }

  int get readyState() { return _ptr.readyState; }

  void addCue(TextTrackCue cue) {
    _ptr.addCue(LevelDom.unwrap(cue));
    return;
  }

  void removeCue(TextTrackCue cue) {
    _ptr.removeCue(LevelDom.unwrap(cue));
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TimeRangesWrappingImplementation extends DOMWrapperBase implements TimeRanges {
  TimeRangesWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  num end(int index) {
    return _ptr.end(index);
  }

  num start(int index) {
    return _ptr.start(index);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TitleElementWrappingImplementation extends ElementWrappingImplementation implements TitleElement {
  TitleElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get text() { return _ptr.text; }

  void set text(String value) { _ptr.text = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TouchListWrappingImplementation extends DOMWrapperBase implements TouchList {
  TouchListWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Touch operator[](int index) {
    return LevelDom.wrapTouch(_ptr[index]);
  }

  void operator[]=(int index, Touch value) {
    _ptr[index] = LevelDom.unwrap(value);
  }

  void add(Touch value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Touch value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Touch> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(Touch a, Touch b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(Touch element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Touch element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  Touch removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  Touch last() {
    return this[length - 1];
  }

  void forEach(void f(Touch element)) {
    _Collections.forEach(this, f);
  }

  Collection<Touch> filter(bool f(Touch element)) {
    return _Collections.filter(this, new List<Touch>(), f);
  }

  bool every(bool f(Touch element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(Touch element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<Touch> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [Touch initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Touch> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<Touch> iterator() {
    return new _FixedSizeListIterator<Touch>(this);
  }

  Touch item(int index) {
    return LevelDom.wrapTouch(_ptr.item(index));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TouchWrappingImplementation extends DOMWrapperBase implements Touch {
  TouchWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get clientX() { return _ptr.clientX; }

  int get clientY() { return _ptr.clientY; }

  int get identifier() { return _ptr.identifier; }

  int get pageX() { return _ptr.pageX; }

  int get pageY() { return _ptr.pageY; }

  int get screenX() { return _ptr.screenX; }

  int get screenY() { return _ptr.screenY; }

  EventTarget get target() { return LevelDom.wrapEventTarget(_ptr.target); }

  num get webkitForce() { return _ptr.webkitForce; }

  int get webkitRadiusX() { return _ptr.webkitRadiusX; }

  int get webkitRadiusY() { return _ptr.webkitRadiusY; }

  num get webkitRotationAngle() { return _ptr.webkitRotationAngle; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class TrackElementWrappingImplementation extends ElementWrappingImplementation implements TrackElement {
  TrackElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get isDefault() { return _ptr.isDefault; }

  void set isDefault(bool value) { _ptr.isDefault = value; }

  String get kind() { return _ptr.kind; }

  void set kind(String value) { _ptr.kind = value; }

  String get label() { return _ptr.label; }

  void set label(String value) { _ptr.label = value; }

  String get src() { return _ptr.src; }

  void set src(String value) { _ptr.src = value; }

  String get srclang() { return _ptr.srclang; }

  void set srclang(String value) { _ptr.srclang = value; }

  TextTrack get track() { return LevelDom.wrapTextTrack(_ptr.track); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class UListElementWrappingImplementation extends ElementWrappingImplementation implements UListElement {
  UListElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get compact() { return _ptr.compact; }

  void set compact(bool value) { _ptr.compact = value; }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class Uint16ArrayWrappingImplementation extends ArrayBufferViewWrappingImplementation implements Uint16Array {
  Uint16ArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Uint16Array subarray(int start, [int end]) {
    if (end === null) {
      return LevelDom.wrapUint16Array(_ptr.subarray(start));
    } else {
      return LevelDom.wrapUint16Array(_ptr.subarray(start, end));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class Uint32ArrayWrappingImplementation extends ArrayBufferViewWrappingImplementation implements Uint32Array {
  Uint32ArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Uint32Array subarray(int start, [int end]) {
    if (end === null) {
      return LevelDom.wrapUint32Array(_ptr.subarray(start));
    } else {
      return LevelDom.wrapUint32Array(_ptr.subarray(start, end));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class Uint8ArrayWrappingImplementation extends ArrayBufferViewWrappingImplementation implements Uint8Array {
  Uint8ArrayWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get length() { return _ptr.length; }

  Uint8Array subarray(int start, [int end]) {
    if (end === null) {
      return LevelDom.wrapUint8Array(_ptr.subarray(start));
    } else {
      return LevelDom.wrapUint8Array(_ptr.subarray(start, end));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class UnknownElementWrappingImplementation extends ElementWrappingImplementation implements UnknownElement {
  UnknownElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class ValidityStateWrappingImplementation extends DOMWrapperBase implements ValidityState {
  ValidityStateWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get customError() { return _ptr.customError; }

  bool get patternMismatch() { return _ptr.patternMismatch; }

  bool get rangeOverflow() { return _ptr.rangeOverflow; }

  bool get rangeUnderflow() { return _ptr.rangeUnderflow; }

  bool get stepMismatch() { return _ptr.stepMismatch; }

  bool get tooLong() { return _ptr.tooLong; }

  bool get typeMismatch() { return _ptr.typeMismatch; }

  bool get valid() { return _ptr.valid; }

  bool get valueMissing() { return _ptr.valueMissing; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class VideoElementWrappingImplementation extends MediaElementWrappingImplementation implements VideoElement {
  VideoElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get height() { return _ptr.height; }

  void set height(int value) { _ptr.height = value; }

  String get poster() { return _ptr.poster; }

  void set poster(String value) { _ptr.poster = value; }

  int get videoHeight() { return _ptr.videoHeight; }

  int get videoWidth() { return _ptr.videoWidth; }

  int get webkitDecodedFrameCount() { return _ptr.webkitDecodedFrameCount; }

  bool get webkitDisplayingFullscreen() { return _ptr.webkitDisplayingFullscreen; }

  int get webkitDroppedFrameCount() { return _ptr.webkitDroppedFrameCount; }

  bool get webkitSupportsFullscreen() { return _ptr.webkitSupportsFullscreen; }

  int get width() { return _ptr.width; }

  void set width(int value) { _ptr.width = value; }

  void webkitEnterFullScreen() {
    _ptr.webkitEnterFullScreen();
    return;
  }

  void webkitEnterFullscreen() {
    _ptr.webkitEnterFullscreen();
    return;
  }

  void webkitExitFullScreen() {
    _ptr.webkitExitFullScreen();
    return;
  }

  void webkitExitFullscreen() {
    _ptr.webkitExitFullscreen();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class VoidCallbackWrappingImplementation extends DOMWrapperBase implements VoidCallback {
  VoidCallbackWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void handleEvent() {
    _ptr.handleEvent();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WaveShaperNodeWrappingImplementation extends AudioNodeWrappingImplementation implements WaveShaperNode {
  WaveShaperNodeWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  Float32Array get curve() { return LevelDom.wrapFloat32Array(_ptr.curve); }

  void set curve(Float32Array value) { _ptr.curve = LevelDom.unwrap(value); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLActiveInfoWrappingImplementation extends DOMWrapperBase implements WebGLActiveInfo {
  WebGLActiveInfoWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get name() { return _ptr.name; }

  int get size() { return _ptr.size; }

  int get type() { return _ptr.type; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLBufferWrappingImplementation extends DOMWrapperBase implements WebGLBuffer {
  WebGLBufferWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLContextAttributesWrappingImplementation extends DOMWrapperBase implements WebGLContextAttributes {
  WebGLContextAttributesWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  bool get alpha() { return _ptr.alpha; }

  void set alpha(bool value) { _ptr.alpha = value; }

  bool get antialias() { return _ptr.antialias; }

  void set antialias(bool value) { _ptr.antialias = value; }

  bool get depth() { return _ptr.depth; }

  void set depth(bool value) { _ptr.depth = value; }

  bool get premultipliedAlpha() { return _ptr.premultipliedAlpha; }

  void set premultipliedAlpha(bool value) { _ptr.premultipliedAlpha = value; }

  bool get preserveDrawingBuffer() { return _ptr.preserveDrawingBuffer; }

  void set preserveDrawingBuffer(bool value) { _ptr.preserveDrawingBuffer = value; }

  bool get stencil() { return _ptr.stencil; }

  void set stencil(bool value) { _ptr.stencil = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLContextEventWrappingImplementation extends EventWrappingImplementation implements WebGLContextEvent {
  WebGLContextEventWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get statusMessage() { return _ptr.statusMessage; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLDebugRendererInfoWrappingImplementation extends DOMWrapperBase implements WebGLDebugRendererInfo {
  WebGLDebugRendererInfoWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLDebugShadersWrappingImplementation extends DOMWrapperBase implements WebGLDebugShaders {
  WebGLDebugShadersWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String getTranslatedShaderSource(WebGLShader shader) {
    return _ptr.getTranslatedShaderSource(LevelDom.unwrap(shader));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLFramebufferWrappingImplementation extends DOMWrapperBase implements WebGLFramebuffer {
  WebGLFramebufferWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLProgramWrappingImplementation extends DOMWrapperBase implements WebGLProgram {
  WebGLProgramWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLRenderbufferWrappingImplementation extends DOMWrapperBase implements WebGLRenderbuffer {
  WebGLRenderbufferWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLRenderingContextWrappingImplementation extends CanvasRenderingContextWrappingImplementation implements WebGLRenderingContext {
  WebGLRenderingContextWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get drawingBufferHeight() { return _ptr.drawingBufferHeight; }

  int get drawingBufferWidth() { return _ptr.drawingBufferWidth; }

  void activeTexture(int texture) {
    _ptr.activeTexture(texture);
    return;
  }

  void attachShader(WebGLProgram program, WebGLShader shader) {
    _ptr.attachShader(LevelDom.unwrap(program), LevelDom.unwrap(shader));
    return;
  }

  void bindAttribLocation(WebGLProgram program, int index, String name) {
    _ptr.bindAttribLocation(LevelDom.unwrap(program), index, name);
    return;
  }

  void bindBuffer(int target, WebGLBuffer buffer) {
    _ptr.bindBuffer(target, LevelDom.unwrap(buffer));
    return;
  }

  void bindFramebuffer(int target, WebGLFramebuffer framebuffer) {
    _ptr.bindFramebuffer(target, LevelDom.unwrap(framebuffer));
    return;
  }

  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer) {
    _ptr.bindRenderbuffer(target, LevelDom.unwrap(renderbuffer));
    return;
  }

  void bindTexture(int target, WebGLTexture texture) {
    _ptr.bindTexture(target, LevelDom.unwrap(texture));
    return;
  }

  void blendColor(num red, num green, num blue, num alpha) {
    _ptr.blendColor(red, green, blue, alpha);
    return;
  }

  void blendEquation(int mode) {
    _ptr.blendEquation(mode);
    return;
  }

  void blendEquationSeparate(int modeRGB, int modeAlpha) {
    _ptr.blendEquationSeparate(modeRGB, modeAlpha);
    return;
  }

  void blendFunc(int sfactor, int dfactor) {
    _ptr.blendFunc(sfactor, dfactor);
    return;
  }

  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
    _ptr.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    return;
  }

  void bufferData(int target, var data_OR_size, int usage) {
    if (data_OR_size is ArrayBuffer) {
      _ptr.bufferData(target, LevelDom.unwrapMaybePrimitive(data_OR_size), usage);
      return;
    } else {
      if (data_OR_size is ArrayBufferView) {
        _ptr.bufferData(target, LevelDom.unwrapMaybePrimitive(data_OR_size), usage);
        return;
      } else {
        if (data_OR_size is int) {
          _ptr.bufferData(target, LevelDom.unwrapMaybePrimitive(data_OR_size), usage);
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void bufferSubData(int target, int offset, var data) {
    if (data is ArrayBuffer) {
      _ptr.bufferSubData(target, offset, LevelDom.unwrapMaybePrimitive(data));
      return;
    } else {
      if (data is ArrayBufferView) {
        _ptr.bufferSubData(target, offset, LevelDom.unwrapMaybePrimitive(data));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  int checkFramebufferStatus(int target) {
    return _ptr.checkFramebufferStatus(target);
  }

  void clear(int mask) {
    _ptr.clear(mask);
    return;
  }

  void clearColor(num red, num green, num blue, num alpha) {
    _ptr.clearColor(red, green, blue, alpha);
    return;
  }

  void clearDepth(num depth) {
    _ptr.clearDepth(depth);
    return;
  }

  void clearStencil(int s) {
    _ptr.clearStencil(s);
    return;
  }

  void colorMask(bool red, bool green, bool blue, bool alpha) {
    _ptr.colorMask(red, green, blue, alpha);
    return;
  }

  void compileShader(WebGLShader shader) {
    _ptr.compileShader(LevelDom.unwrap(shader));
    return;
  }

  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) {
    _ptr.copyTexImage2D(target, level, internalformat, x, y, width, height, border);
    return;
  }

  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
    _ptr.copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    return;
  }

  WebGLBuffer createBuffer() {
    return LevelDom.wrapWebGLBuffer(_ptr.createBuffer());
  }

  WebGLFramebuffer createFramebuffer() {
    return LevelDom.wrapWebGLFramebuffer(_ptr.createFramebuffer());
  }

  WebGLProgram createProgram() {
    return LevelDom.wrapWebGLProgram(_ptr.createProgram());
  }

  WebGLRenderbuffer createRenderbuffer() {
    return LevelDom.wrapWebGLRenderbuffer(_ptr.createRenderbuffer());
  }

  WebGLShader createShader(int type) {
    return LevelDom.wrapWebGLShader(_ptr.createShader(type));
  }

  WebGLTexture createTexture() {
    return LevelDom.wrapWebGLTexture(_ptr.createTexture());
  }

  void cullFace(int mode) {
    _ptr.cullFace(mode);
    return;
  }

  void deleteBuffer(WebGLBuffer buffer) {
    _ptr.deleteBuffer(LevelDom.unwrap(buffer));
    return;
  }

  void deleteFramebuffer(WebGLFramebuffer framebuffer) {
    _ptr.deleteFramebuffer(LevelDom.unwrap(framebuffer));
    return;
  }

  void deleteProgram(WebGLProgram program) {
    _ptr.deleteProgram(LevelDom.unwrap(program));
    return;
  }

  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer) {
    _ptr.deleteRenderbuffer(LevelDom.unwrap(renderbuffer));
    return;
  }

  void deleteShader(WebGLShader shader) {
    _ptr.deleteShader(LevelDom.unwrap(shader));
    return;
  }

  void deleteTexture(WebGLTexture texture) {
    _ptr.deleteTexture(LevelDom.unwrap(texture));
    return;
  }

  void depthFunc(int func) {
    _ptr.depthFunc(func);
    return;
  }

  void depthMask(bool flag) {
    _ptr.depthMask(flag);
    return;
  }

  void depthRange(num zNear, num zFar) {
    _ptr.depthRange(zNear, zFar);
    return;
  }

  void detachShader(WebGLProgram program, WebGLShader shader) {
    _ptr.detachShader(LevelDom.unwrap(program), LevelDom.unwrap(shader));
    return;
  }

  void disable(int cap) {
    _ptr.disable(cap);
    return;
  }

  void disableVertexAttribArray(int index) {
    _ptr.disableVertexAttribArray(index);
    return;
  }

  void drawArrays(int mode, int first, int count) {
    _ptr.drawArrays(mode, first, count);
    return;
  }

  void drawElements(int mode, int count, int type, int offset) {
    _ptr.drawElements(mode, count, type, offset);
    return;
  }

  void enable(int cap) {
    _ptr.enable(cap);
    return;
  }

  void enableVertexAttribArray(int index) {
    _ptr.enableVertexAttribArray(index);
    return;
  }

  void finish() {
    _ptr.finish();
    return;
  }

  void flush() {
    _ptr.flush();
    return;
  }

  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer) {
    _ptr.framebufferRenderbuffer(target, attachment, renderbuffertarget, LevelDom.unwrap(renderbuffer));
    return;
  }

  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level) {
    _ptr.framebufferTexture2D(target, attachment, textarget, LevelDom.unwrap(texture), level);
    return;
  }

  void frontFace(int mode) {
    _ptr.frontFace(mode);
    return;
  }

  void generateMipmap(int target) {
    _ptr.generateMipmap(target);
    return;
  }

  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index) {
    return LevelDom.wrapWebGLActiveInfo(_ptr.getActiveAttrib(LevelDom.unwrap(program), index));
  }

  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index) {
    return LevelDom.wrapWebGLActiveInfo(_ptr.getActiveUniform(LevelDom.unwrap(program), index));
  }

  void getAttachedShaders(WebGLProgram program) {
    _ptr.getAttachedShaders(LevelDom.unwrap(program));
    return;
  }

  int getAttribLocation(WebGLProgram program, String name) {
    return _ptr.getAttribLocation(LevelDom.unwrap(program), name);
  }

  Object getBufferParameter(int target, int pname) {
    return LevelDom.wrapObject(_ptr.getBufferParameter(target, pname));
  }

  WebGLContextAttributes getContextAttributes() {
    return LevelDom.wrapWebGLContextAttributes(_ptr.getContextAttributes());
  }

  int getError() {
    return _ptr.getError();
  }

  Object getExtension(String name) {
    return LevelDom.wrapObject(_ptr.getExtension(name));
  }

  Object getFramebufferAttachmentParameter(int target, int attachment, int pname) {
    return LevelDom.wrapObject(_ptr.getFramebufferAttachmentParameter(target, attachment, pname));
  }

  Object getParameter(int pname) {
    return LevelDom.wrapObject(_ptr.getParameter(pname));
  }

  String getProgramInfoLog(WebGLProgram program) {
    return _ptr.getProgramInfoLog(LevelDom.unwrap(program));
  }

  Object getProgramParameter(WebGLProgram program, int pname) {
    return LevelDom.wrapObject(_ptr.getProgramParameter(LevelDom.unwrap(program), pname));
  }

  Object getRenderbufferParameter(int target, int pname) {
    return LevelDom.wrapObject(_ptr.getRenderbufferParameter(target, pname));
  }

  String getShaderInfoLog(WebGLShader shader) {
    return _ptr.getShaderInfoLog(LevelDom.unwrap(shader));
  }

  Object getShaderParameter(WebGLShader shader, int pname) {
    return LevelDom.wrapObject(_ptr.getShaderParameter(LevelDom.unwrap(shader), pname));
  }

  String getShaderSource(WebGLShader shader) {
    return _ptr.getShaderSource(LevelDom.unwrap(shader));
  }

  Object getTexParameter(int target, int pname) {
    return LevelDom.wrapObject(_ptr.getTexParameter(target, pname));
  }

  Object getUniform(WebGLProgram program, WebGLUniformLocation location) {
    return LevelDom.wrapObject(_ptr.getUniform(LevelDom.unwrap(program), LevelDom.unwrap(location)));
  }

  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name) {
    return LevelDom.wrapWebGLUniformLocation(_ptr.getUniformLocation(LevelDom.unwrap(program), name));
  }

  Object getVertexAttrib(int index, int pname) {
    return LevelDom.wrapObject(_ptr.getVertexAttrib(index, pname));
  }

  int getVertexAttribOffset(int index, int pname) {
    return _ptr.getVertexAttribOffset(index, pname);
  }

  void hint(int target, int mode) {
    _ptr.hint(target, mode);
    return;
  }

  bool isBuffer(WebGLBuffer buffer) {
    return _ptr.isBuffer(LevelDom.unwrap(buffer));
  }

  bool isContextLost() {
    return _ptr.isContextLost();
  }

  bool isEnabled(int cap) {
    return _ptr.isEnabled(cap);
  }

  bool isFramebuffer(WebGLFramebuffer framebuffer) {
    return _ptr.isFramebuffer(LevelDom.unwrap(framebuffer));
  }

  bool isProgram(WebGLProgram program) {
    return _ptr.isProgram(LevelDom.unwrap(program));
  }

  bool isRenderbuffer(WebGLRenderbuffer renderbuffer) {
    return _ptr.isRenderbuffer(LevelDom.unwrap(renderbuffer));
  }

  bool isShader(WebGLShader shader) {
    return _ptr.isShader(LevelDom.unwrap(shader));
  }

  bool isTexture(WebGLTexture texture) {
    return _ptr.isTexture(LevelDom.unwrap(texture));
  }

  void lineWidth(num width) {
    _ptr.lineWidth(width);
    return;
  }

  void linkProgram(WebGLProgram program) {
    _ptr.linkProgram(LevelDom.unwrap(program));
    return;
  }

  void pixelStorei(int pname, int param) {
    _ptr.pixelStorei(pname, param);
    return;
  }

  void polygonOffset(num factor, num units) {
    _ptr.polygonOffset(factor, units);
    return;
  }

  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels) {
    _ptr.readPixels(x, y, width, height, format, type, LevelDom.unwrap(pixels));
    return;
  }

  void releaseShaderCompiler() {
    _ptr.releaseShaderCompiler();
    return;
  }

  void renderbufferStorage(int target, int internalformat, int width, int height) {
    _ptr.renderbufferStorage(target, internalformat, width, height);
    return;
  }

  void sampleCoverage(num value, bool invert) {
    _ptr.sampleCoverage(value, invert);
    return;
  }

  void scissor(int x, int y, int width, int height) {
    _ptr.scissor(x, y, width, height);
    return;
  }

  void shaderSource(WebGLShader shader, String string) {
    _ptr.shaderSource(LevelDom.unwrap(shader), string);
    return;
  }

  void stencilFunc(int func, int ref, int mask) {
    _ptr.stencilFunc(func, ref, mask);
    return;
  }

  void stencilFuncSeparate(int face, int func, int ref, int mask) {
    _ptr.stencilFuncSeparate(face, func, ref, mask);
    return;
  }

  void stencilMask(int mask) {
    _ptr.stencilMask(mask);
    return;
  }

  void stencilMaskSeparate(int face, int mask) {
    _ptr.stencilMaskSeparate(face, mask);
    return;
  }

  void stencilOp(int fail, int zfail, int zpass) {
    _ptr.stencilOp(fail, zfail, zpass);
    return;
  }

  void stencilOpSeparate(int face, int fail, int zfail, int zpass) {
    _ptr.stencilOpSeparate(face, fail, zfail, zpass);
    return;
  }

  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, var border_OR_canvas_OR_image_OR_pixels, [int format, int type, ArrayBufferView pixels]) {
    if (border_OR_canvas_OR_image_OR_pixels is ImageData) {
      if (format === null) {
        if (type === null) {
          if (pixels === null) {
            _ptr.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, LevelDom.unwrapMaybePrimitive(border_OR_canvas_OR_image_OR_pixels));
            return;
          }
        }
      }
    } else {
      if (border_OR_canvas_OR_image_OR_pixels is ImageElement) {
        if (format === null) {
          if (type === null) {
            if (pixels === null) {
              _ptr.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, LevelDom.unwrapMaybePrimitive(border_OR_canvas_OR_image_OR_pixels));
              return;
            }
          }
        }
      } else {
        if (border_OR_canvas_OR_image_OR_pixels is CanvasElement) {
          if (format === null) {
            if (type === null) {
              if (pixels === null) {
                _ptr.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, LevelDom.unwrapMaybePrimitive(border_OR_canvas_OR_image_OR_pixels));
                return;
              }
            }
          }
        } else {
          if (border_OR_canvas_OR_image_OR_pixels is int) {
            _ptr.texImage2D(target, level, internalformat, format_OR_width, height_OR_type, LevelDom.unwrapMaybePrimitive(border_OR_canvas_OR_image_OR_pixels), format, type, LevelDom.unwrap(pixels));
            return;
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void texParameterf(int target, int pname, num param) {
    _ptr.texParameterf(target, pname, param);
    return;
  }

  void texParameteri(int target, int pname, int param) {
    _ptr.texParameteri(target, pname, param);
    return;
  }

  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, var canvas_OR_format_OR_image_OR_pixels, [int type, ArrayBufferView pixels]) {
    if (canvas_OR_format_OR_image_OR_pixels is ImageData) {
      if (type === null) {
        if (pixels === null) {
          _ptr.texSubImage2D(target, level, xoffset, yoffset, format_OR_width, height_OR_type, LevelDom.unwrapMaybePrimitive(canvas_OR_format_OR_image_OR_pixels));
          return;
        }
      }
    } else {
      if (canvas_OR_format_OR_image_OR_pixels is ImageElement) {
        if (type === null) {
          if (pixels === null) {
            _ptr.texSubImage2D(target, level, xoffset, yoffset, format_OR_width, height_OR_type, LevelDom.unwrapMaybePrimitive(canvas_OR_format_OR_image_OR_pixels));
            return;
          }
        }
      } else {
        if (canvas_OR_format_OR_image_OR_pixels is CanvasElement) {
          if (type === null) {
            if (pixels === null) {
              _ptr.texSubImage2D(target, level, xoffset, yoffset, format_OR_width, height_OR_type, LevelDom.unwrapMaybePrimitive(canvas_OR_format_OR_image_OR_pixels));
              return;
            }
          }
        } else {
          if (canvas_OR_format_OR_image_OR_pixels is int) {
            _ptr.texSubImage2D(target, level, xoffset, yoffset, format_OR_width, height_OR_type, LevelDom.unwrapMaybePrimitive(canvas_OR_format_OR_image_OR_pixels), type, LevelDom.unwrap(pixels));
            return;
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void uniform1f(WebGLUniformLocation location, num x) {
    _ptr.uniform1f(LevelDom.unwrap(location), x);
    return;
  }

  void uniform1fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform1fv(LevelDom.unwrap(location), LevelDom.unwrap(v));
    return;
  }

  void uniform1i(WebGLUniformLocation location, int x) {
    _ptr.uniform1i(LevelDom.unwrap(location), x);
    return;
  }

  void uniform1iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform1iv(LevelDom.unwrap(location), LevelDom.unwrap(v));
    return;
  }

  void uniform2f(WebGLUniformLocation location, num x, num y) {
    _ptr.uniform2f(LevelDom.unwrap(location), x, y);
    return;
  }

  void uniform2fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform2fv(LevelDom.unwrap(location), LevelDom.unwrap(v));
    return;
  }

  void uniform2i(WebGLUniformLocation location, int x, int y) {
    _ptr.uniform2i(LevelDom.unwrap(location), x, y);
    return;
  }

  void uniform2iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform2iv(LevelDom.unwrap(location), LevelDom.unwrap(v));
    return;
  }

  void uniform3f(WebGLUniformLocation location, num x, num y, num z) {
    _ptr.uniform3f(LevelDom.unwrap(location), x, y, z);
    return;
  }

  void uniform3fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform3fv(LevelDom.unwrap(location), LevelDom.unwrap(v));
    return;
  }

  void uniform3i(WebGLUniformLocation location, int x, int y, int z) {
    _ptr.uniform3i(LevelDom.unwrap(location), x, y, z);
    return;
  }

  void uniform3iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform3iv(LevelDom.unwrap(location), LevelDom.unwrap(v));
    return;
  }

  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w) {
    _ptr.uniform4f(LevelDom.unwrap(location), x, y, z, w);
    return;
  }

  void uniform4fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform4fv(LevelDom.unwrap(location), LevelDom.unwrap(v));
    return;
  }

  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w) {
    _ptr.uniform4i(LevelDom.unwrap(location), x, y, z, w);
    return;
  }

  void uniform4iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform4iv(LevelDom.unwrap(location), LevelDom.unwrap(v));
    return;
  }

  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array) {
    _ptr.uniformMatrix2fv(LevelDom.unwrap(location), transpose, LevelDom.unwrap(array));
    return;
  }

  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array) {
    _ptr.uniformMatrix3fv(LevelDom.unwrap(location), transpose, LevelDom.unwrap(array));
    return;
  }

  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array) {
    _ptr.uniformMatrix4fv(LevelDom.unwrap(location), transpose, LevelDom.unwrap(array));
    return;
  }

  void useProgram(WebGLProgram program) {
    _ptr.useProgram(LevelDom.unwrap(program));
    return;
  }

  void validateProgram(WebGLProgram program) {
    _ptr.validateProgram(LevelDom.unwrap(program));
    return;
  }

  void vertexAttrib1f(int indx, num x) {
    _ptr.vertexAttrib1f(indx, x);
    return;
  }

  void vertexAttrib1fv(int indx, Float32Array values) {
    _ptr.vertexAttrib1fv(indx, LevelDom.unwrap(values));
    return;
  }

  void vertexAttrib2f(int indx, num x, num y) {
    _ptr.vertexAttrib2f(indx, x, y);
    return;
  }

  void vertexAttrib2fv(int indx, Float32Array values) {
    _ptr.vertexAttrib2fv(indx, LevelDom.unwrap(values));
    return;
  }

  void vertexAttrib3f(int indx, num x, num y, num z) {
    _ptr.vertexAttrib3f(indx, x, y, z);
    return;
  }

  void vertexAttrib3fv(int indx, Float32Array values) {
    _ptr.vertexAttrib3fv(indx, LevelDom.unwrap(values));
    return;
  }

  void vertexAttrib4f(int indx, num x, num y, num z, num w) {
    _ptr.vertexAttrib4f(indx, x, y, z, w);
    return;
  }

  void vertexAttrib4fv(int indx, Float32Array values) {
    _ptr.vertexAttrib4fv(indx, LevelDom.unwrap(values));
    return;
  }

  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset) {
    _ptr.vertexAttribPointer(indx, size, type, normalized, stride, offset);
    return;
  }

  void viewport(int x, int y, int width, int height) {
    _ptr.viewport(x, y, width, height);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLShaderWrappingImplementation extends DOMWrapperBase implements WebGLShader {
  WebGLShaderWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLTextureWrappingImplementation extends DOMWrapperBase implements WebGLTexture {
  WebGLTextureWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLUniformLocationWrappingImplementation extends DOMWrapperBase implements WebGLUniformLocation {
  WebGLUniformLocationWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebGLVertexArrayObjectOESWrappingImplementation extends DOMWrapperBase implements WebGLVertexArrayObjectOES {
  WebGLVertexArrayObjectOESWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebKitCSSFilterValueWrappingImplementation extends CSSValueListWrappingImplementation implements WebKitCSSFilterValue {
  WebKitCSSFilterValueWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get operationType() { return _ptr.operationType; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class WebKitMutationObserverWrappingImplementation extends DOMWrapperBase implements WebKitMutationObserver {
  WebKitMutationObserverWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void disconnect() {
    _ptr.disconnect();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class XMLHttpRequestExceptionWrappingImplementation extends DOMWrapperBase implements XMLHttpRequestException {
  XMLHttpRequestExceptionWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  int get code() { return _ptr.code; }

  String get message() { return _ptr.message; }

  String get name() { return _ptr.name; }

  String toString() {
    return _ptr.toString();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class LevelDom {
  static AnchorElement wrapAnchorElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AnchorElementWrappingImplementation._wrap(raw);
  }

  static Animation wrapAnimation(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AnimationWrappingImplementation._wrap(raw);
  }

  static AnimationEvent wrapAnimationEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AnimationEventWrappingImplementation._wrap(raw);
  }

  static AnimationList wrapAnimationList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AnimationListWrappingImplementation._wrap(raw);
  }

  static AreaElement wrapAreaElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AreaElementWrappingImplementation._wrap(raw);
  }

  static ArrayBuffer wrapArrayBuffer(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ArrayBufferWrappingImplementation._wrap(raw);
  }

  static ArrayBufferView wrapArrayBufferView(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "ArrayBufferView":
        return new ArrayBufferViewWrappingImplementation._wrap(raw);
      case "DataView":
        return new DataViewWrappingImplementation._wrap(raw);
      case "Float32Array":
        return new Float32ArrayWrappingImplementation._wrap(raw);
      case "Float64Array":
        return new Float64ArrayWrappingImplementation._wrap(raw);
      case "Int16Array":
        return new Int16ArrayWrappingImplementation._wrap(raw);
      case "Int32Array":
        return new Int32ArrayWrappingImplementation._wrap(raw);
      case "Int8Array":
        return new Int8ArrayWrappingImplementation._wrap(raw);
      case "Uint16Array":
        return new Uint16ArrayWrappingImplementation._wrap(raw);
      case "Uint32Array":
        return new Uint32ArrayWrappingImplementation._wrap(raw);
      case "Uint8Array":
        return new Uint8ArrayWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static AudioBuffer wrapAudioBuffer(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioBufferWrappingImplementation._wrap(raw);
  }

  // Skipped AudioBufferCallback
  static AudioBufferSourceNode wrapAudioBufferSourceNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioBufferSourceNodeWrappingImplementation._wrap(raw);
  }

  static AudioChannelMerger wrapAudioChannelMerger(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioChannelMergerWrappingImplementation._wrap(raw);
  }

  static AudioChannelSplitter wrapAudioChannelSplitter(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioChannelSplitterWrappingImplementation._wrap(raw);
  }

  static AudioContext wrapAudioContext(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioContextWrappingImplementation._wrap(raw);
  }

  static AudioDestinationNode wrapAudioDestinationNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioDestinationNodeWrappingImplementation._wrap(raw);
  }

  static AudioElement wrapAudioElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioElementWrappingImplementation._wrap(raw);
  }

  static AudioGain wrapAudioGain(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioGainWrappingImplementation._wrap(raw);
  }

  static AudioGainNode wrapAudioGainNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioGainNodeWrappingImplementation._wrap(raw);
  }

  static AudioListener wrapAudioListener(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioListenerWrappingImplementation._wrap(raw);
  }

  static AudioNode wrapAudioNode(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "AudioBufferSourceNode":
        return new AudioBufferSourceNodeWrappingImplementation._wrap(raw);
      case "AudioChannelMerger":
        return new AudioChannelMergerWrappingImplementation._wrap(raw);
      case "AudioChannelSplitter":
        return new AudioChannelSplitterWrappingImplementation._wrap(raw);
      case "AudioDestinationNode":
        return new AudioDestinationNodeWrappingImplementation._wrap(raw);
      case "AudioGainNode":
        return new AudioGainNodeWrappingImplementation._wrap(raw);
      case "AudioNode":
        return new AudioNodeWrappingImplementation._wrap(raw);
      case "AudioPannerNode":
        return new AudioPannerNodeWrappingImplementation._wrap(raw);
      case "AudioSourceNode":
        return new AudioSourceNodeWrappingImplementation._wrap(raw);
      case "BiquadFilterNode":
        return new BiquadFilterNodeWrappingImplementation._wrap(raw);
      case "ConvolverNode":
        return new ConvolverNodeWrappingImplementation._wrap(raw);
      case "DelayNode":
        return new DelayNodeWrappingImplementation._wrap(raw);
      case "DynamicsCompressorNode":
        return new DynamicsCompressorNodeWrappingImplementation._wrap(raw);
      case "HighPass2FilterNode":
        return new HighPass2FilterNodeWrappingImplementation._wrap(raw);
      case "JavaScriptAudioNode":
        return new JavaScriptAudioNodeWrappingImplementation._wrap(raw);
      case "LowPass2FilterNode":
        return new LowPass2FilterNodeWrappingImplementation._wrap(raw);
      case "MediaElementAudioSourceNode":
        return new MediaElementAudioSourceNodeWrappingImplementation._wrap(raw);
      case "RealtimeAnalyserNode":
        return new RealtimeAnalyserNodeWrappingImplementation._wrap(raw);
      case "WaveShaperNode":
        return new WaveShaperNodeWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static AudioPannerNode wrapAudioPannerNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioPannerNodeWrappingImplementation._wrap(raw);
  }

  static AudioParam wrapAudioParam(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "AudioGain":
        return new AudioGainWrappingImplementation._wrap(raw);
      case "AudioParam":
        return new AudioParamWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static AudioProcessingEvent wrapAudioProcessingEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new AudioProcessingEventWrappingImplementation._wrap(raw);
  }

  static AudioSourceNode wrapAudioSourceNode(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "AudioBufferSourceNode":
        return new AudioBufferSourceNodeWrappingImplementation._wrap(raw);
      case "AudioSourceNode":
        return new AudioSourceNodeWrappingImplementation._wrap(raw);
      case "MediaElementAudioSourceNode":
        return new MediaElementAudioSourceNodeWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static BRElement wrapBRElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new BRElementWrappingImplementation._wrap(raw);
  }

  static BarInfo wrapBarInfo(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new BarInfoWrappingImplementation._wrap(raw);
  }

  static BaseElement wrapBaseElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new BaseElementWrappingImplementation._wrap(raw);
  }

  static BeforeLoadEvent wrapBeforeLoadEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new BeforeLoadEventWrappingImplementation._wrap(raw);
  }

  static BiquadFilterNode wrapBiquadFilterNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new BiquadFilterNodeWrappingImplementation._wrap(raw);
  }

  static Blob wrapBlob(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "Blob":
        return new BlobWrappingImplementation._wrap(raw);
      case "File":
        return new FileWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static BlobBuilder wrapBlobBuilder(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new BlobBuilderWrappingImplementation._wrap(raw);
  }

  static BodyElement wrapBodyElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new BodyElementWrappingImplementation._wrap(raw);
  }

  static ButtonElement wrapButtonElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ButtonElementWrappingImplementation._wrap(raw);
  }

  static CDATASection wrapCDATASection(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CDATASectionWrappingImplementation._wrap(raw);
  }

  static CSSCharsetRule wrapCSSCharsetRule(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSCharsetRuleWrappingImplementation._wrap(raw);
  }

  static CSSFontFaceRule wrapCSSFontFaceRule(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSFontFaceRuleWrappingImplementation._wrap(raw);
  }

  static CSSImportRule wrapCSSImportRule(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSImportRuleWrappingImplementation._wrap(raw);
  }

  static CSSKeyframeRule wrapCSSKeyframeRule(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSKeyframeRuleWrappingImplementation._wrap(raw);
  }

  static CSSKeyframesRule wrapCSSKeyframesRule(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSKeyframesRuleWrappingImplementation._wrap(raw);
  }

  static CSSMatrix wrapCSSMatrix(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSMatrixWrappingImplementation._wrap(raw);
  }

  static CSSMediaRule wrapCSSMediaRule(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSMediaRuleWrappingImplementation._wrap(raw);
  }

  static CSSPageRule wrapCSSPageRule(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSPageRuleWrappingImplementation._wrap(raw);
  }

  static CSSPrimitiveValue wrapCSSPrimitiveValue(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSPrimitiveValueWrappingImplementation._wrap(raw);
  }

  static CSSRule wrapCSSRule(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "CSSCharsetRule":
        return new CSSCharsetRuleWrappingImplementation._wrap(raw);
      case "CSSFontFaceRule":
        return new CSSFontFaceRuleWrappingImplementation._wrap(raw);
      case "CSSImportRule":
        return new CSSImportRuleWrappingImplementation._wrap(raw);
      case "WebKitCSSKeyframeRule":
        return new CSSKeyframeRuleWrappingImplementation._wrap(raw);
      case "WebKitCSSKeyframesRule":
        return new CSSKeyframesRuleWrappingImplementation._wrap(raw);
      case "CSSMediaRule":
        return new CSSMediaRuleWrappingImplementation._wrap(raw);
      case "CSSPageRule":
        return new CSSPageRuleWrappingImplementation._wrap(raw);
      case "CSSRule":
        return new CSSRuleWrappingImplementation._wrap(raw);
      case "CSSStyleRule":
        return new CSSStyleRuleWrappingImplementation._wrap(raw);
      case "CSSUnknownRule":
        return new CSSUnknownRuleWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static CSSRuleList wrapCSSRuleList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSRuleListWrappingImplementation._wrap(raw);
  }

  static CSSStyleDeclaration wrapCSSStyleDeclaration(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSStyleDeclarationWrappingImplementation._wrap(raw);
  }

  static CSSStyleRule wrapCSSStyleRule(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSStyleRuleWrappingImplementation._wrap(raw);
  }

  static CSSStyleSheet wrapCSSStyleSheet(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSStyleSheetWrappingImplementation._wrap(raw);
  }

  static CSSTransformValue wrapCSSTransformValue(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSTransformValueWrappingImplementation._wrap(raw);
  }

  static CSSUnknownRule wrapCSSUnknownRule(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CSSUnknownRuleWrappingImplementation._wrap(raw);
  }

  static CSSValue wrapCSSValue(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "CSSPrimitiveValue":
        return new CSSPrimitiveValueWrappingImplementation._wrap(raw);
      case "WebKitCSSTransformValue":
        return new CSSTransformValueWrappingImplementation._wrap(raw);
      case "CSSValue":
        return new CSSValueWrappingImplementation._wrap(raw);
      case "CSSValueList":
        return new CSSValueListWrappingImplementation._wrap(raw);
      case "SVGColor":
        return new SVGColorWrappingImplementation._wrap(raw);
      case "SVGPaint":
        return new SVGPaintWrappingImplementation._wrap(raw);
      case "WebKitCSSFilterValue":
        return new WebKitCSSFilterValueWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static CSSValueList wrapCSSValueList(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "WebKitCSSTransformValue":
        return new CSSTransformValueWrappingImplementation._wrap(raw);
      case "CSSValueList":
        return new CSSValueListWrappingImplementation._wrap(raw);
      case "WebKitCSSFilterValue":
        return new WebKitCSSFilterValueWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static CanvasElement wrapCanvasElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CanvasElementWrappingImplementation._wrap(raw);
  }

  static CanvasGradient wrapCanvasGradient(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CanvasGradientWrappingImplementation._wrap(raw);
  }

  static CanvasPattern wrapCanvasPattern(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CanvasPatternWrappingImplementation._wrap(raw);
  }

  static CanvasPixelArray wrapCanvasPixelArray(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CanvasPixelArrayWrappingImplementation._wrap(raw);
  }

  static CanvasRenderingContext wrapCanvasRenderingContext(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "CanvasRenderingContext":
        return new CanvasRenderingContextWrappingImplementation._wrap(raw);
      case "CanvasRenderingContext2D":
        return new CanvasRenderingContext2DWrappingImplementation._wrap(raw);
      case "WebGLRenderingContext":
        return new WebGLRenderingContextWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static CanvasRenderingContext2D wrapCanvasRenderingContext2D(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CanvasRenderingContext2DWrappingImplementation._wrap(raw);
  }

  static CharacterData wrapCharacterData(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "CDATASection":
        return new CDATASectionWrappingImplementation._wrap(raw);
      case "CharacterData":
        return new CharacterDataWrappingImplementation._wrap(raw);
      case "Comment":
        return new CommentWrappingImplementation._wrap(raw);
      case "Text":
        return new TextWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static ClientRect wrapClientRect(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ClientRectWrappingImplementation._wrap(raw);
  }

  static ClientRectList wrapClientRectList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ClientRectListWrappingImplementation._wrap(raw);
  }

  static Clipboard wrapClipboard(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ClipboardWrappingImplementation._wrap(raw);
  }

  static CloseEvent wrapCloseEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CloseEventWrappingImplementation._wrap(raw);
  }

  static Comment wrapComment(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CommentWrappingImplementation._wrap(raw);
  }

  static CompositionEvent wrapCompositionEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CompositionEventWrappingImplementation._wrap(raw);
  }

  static Console wrapConsole(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ConsoleWrappingImplementation._wrap(raw);
  }

  static ConvolverNode wrapConvolverNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ConvolverNodeWrappingImplementation._wrap(raw);
  }

  static Coordinates wrapCoordinates(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CoordinatesWrappingImplementation._wrap(raw);
  }

  static Counter wrapCounter(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CounterWrappingImplementation._wrap(raw);
  }

  static Crypto wrapCrypto(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CryptoWrappingImplementation._wrap(raw);
  }

  static CustomEvent wrapCustomEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new CustomEventWrappingImplementation._wrap(raw);
  }

  static DListElement wrapDListElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DListElementWrappingImplementation._wrap(raw);
  }

  static DOMApplicationCache wrapDOMApplicationCache(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMApplicationCacheWrappingImplementation._wrap(raw);
  }

  static DOMException wrapDOMException(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMExceptionWrappingImplementation._wrap(raw);
  }

  static DOMFileSystem wrapDOMFileSystem(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMFileSystemWrappingImplementation._wrap(raw);
  }

  static DOMFileSystemSync wrapDOMFileSystemSync(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMFileSystemSyncWrappingImplementation._wrap(raw);
  }

  static DOMFormData wrapDOMFormData(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMFormDataWrappingImplementation._wrap(raw);
  }

  static DOMMimeType wrapDOMMimeType(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMMimeTypeWrappingImplementation._wrap(raw);
  }

  static DOMMimeTypeArray wrapDOMMimeTypeArray(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMMimeTypeArrayWrappingImplementation._wrap(raw);
  }

  static DOMParser wrapDOMParser(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMParserWrappingImplementation._wrap(raw);
  }

  static DOMPlugin wrapDOMPlugin(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMPluginWrappingImplementation._wrap(raw);
  }

  static DOMPluginArray wrapDOMPluginArray(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMPluginArrayWrappingImplementation._wrap(raw);
  }

  static DOMSelection wrapDOMSelection(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMSelectionWrappingImplementation._wrap(raw);
  }

  static DOMSettableTokenList wrapDOMSettableTokenList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMSettableTokenListWrappingImplementation._wrap(raw);
  }

  static DOMTokenList wrapDOMTokenList(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "DOMSettableTokenList":
        return new DOMSettableTokenListWrappingImplementation._wrap(raw);
      case "DOMTokenList":
        return new DOMTokenListWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static DOMURL wrapDOMURL(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DOMURLWrappingImplementation._wrap(raw);
  }

  static DataListElement wrapDataListElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DataListElementWrappingImplementation._wrap(raw);
  }

  static DataTransferItem wrapDataTransferItem(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DataTransferItemWrappingImplementation._wrap(raw);
  }

  static DataTransferItemList wrapDataTransferItemList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DataTransferItemListWrappingImplementation._wrap(raw);
  }

  static DataView wrapDataView(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DataViewWrappingImplementation._wrap(raw);
  }

  // Skipped DatabaseCallback
  static DelayNode wrapDelayNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DelayNodeWrappingImplementation._wrap(raw);
  }

  static DetailsElement wrapDetailsElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DetailsElementWrappingImplementation._wrap(raw);
  }

  static DeviceMotionEvent wrapDeviceMotionEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DeviceMotionEventWrappingImplementation._wrap(raw);
  }

  static DeviceOrientationEvent wrapDeviceOrientationEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DeviceOrientationEventWrappingImplementation._wrap(raw);
  }

  static DirectoryEntry wrapDirectoryEntry(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DirectoryEntryWrappingImplementation._wrap(raw);
  }

  static DirectoryEntrySync wrapDirectoryEntrySync(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DirectoryEntrySyncWrappingImplementation._wrap(raw);
  }

  static DirectoryReader wrapDirectoryReader(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DirectoryReaderWrappingImplementation._wrap(raw);
  }

  static DirectoryReaderSync wrapDirectoryReaderSync(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DirectoryReaderSyncWrappingImplementation._wrap(raw);
  }

  static DivElement wrapDivElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DivElementWrappingImplementation._wrap(raw);
  }

  static Document wrapDocument(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "HTMLDocument":
        return new DocumentWrappingImplementation._wrap(raw, raw.documentElement);
      case "SVGDocument":
        return new SVGDocumentWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static DocumentFragment wrapDocumentFragment(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DocumentFragmentWrappingImplementation._wrap(raw);
  }

  static DynamicsCompressorNode wrapDynamicsCompressorNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new DynamicsCompressorNodeWrappingImplementation._wrap(raw);
  }

  static Element wrapElement(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "HTMLAnchorElement":
        return new AnchorElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLAppletElement*/
      case "HTMLAreaElement":
        return new AreaElementWrappingImplementation._wrap(raw);
      case "HTMLAudioElement":
        return new AudioElementWrappingImplementation._wrap(raw);
      case "HTMLBRElement":
        return new BRElementWrappingImplementation._wrap(raw);
      case "HTMLBaseElement":
        return new BaseElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLBaseFontElement*/
      case "HTMLBodyElement":
        return new BodyElementWrappingImplementation._wrap(raw);
      case "HTMLButtonElement":
        return new ButtonElementWrappingImplementation._wrap(raw);
      case "HTMLCanvasElement":
        return new CanvasElementWrappingImplementation._wrap(raw);
      case "HTMLDListElement":
        return new DListElementWrappingImplementation._wrap(raw);
      case "HTMLDataListElement":
        return new DataListElementWrappingImplementation._wrap(raw);
      case "HTMLDetailsElement":
        return new DetailsElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLDirectoryElement*/
      case "HTMLDivElement":
        return new DivElementWrappingImplementation._wrap(raw);
      case "HTMLElement":
        return new ElementWrappingImplementation._wrap(raw);
      case "HTMLEmbedElement":
        return new EmbedElementWrappingImplementation._wrap(raw);
      case "HTMLFieldSetElement":
        return new FieldSetElementWrappingImplementation._wrap(raw);
      case "HTMLFontElement":
        return new FontElementWrappingImplementation._wrap(raw);
      case "HTMLFormElement":
        return new FormElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLFrameElement*/
      /* Skipping HTMLFrameSetElement*/
      case "HTMLHRElement":
        return new HRElementWrappingImplementation._wrap(raw);
      case "HTMLHeadElement":
        return new HeadElementWrappingImplementation._wrap(raw);
      case "HTMLHeadingElement":
        return new HeadingElementWrappingImplementation._wrap(raw);
      case "HTMLHtmlElement":
        return new DocumentWrappingImplementation._wrap(raw.parentNode, raw);
      case "HTMLIFrameElement":
        return new IFrameElementWrappingImplementation._wrap(raw);
      case "HTMLImageElement":
        return new ImageElementWrappingImplementation._wrap(raw);
      case "HTMLInputElement":
        return new InputElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLIsIndexElement*/
      case "HTMLKeygenElement":
        return new KeygenElementWrappingImplementation._wrap(raw);
      case "HTMLLIElement":
        return new LIElementWrappingImplementation._wrap(raw);
      case "HTMLLabelElement":
        return new LabelElementWrappingImplementation._wrap(raw);
      case "HTMLLegendElement":
        return new LegendElementWrappingImplementation._wrap(raw);
      case "HTMLLinkElement":
        return new LinkElementWrappingImplementation._wrap(raw);
      case "HTMLMapElement":
        return new MapElementWrappingImplementation._wrap(raw);
      case "HTMLMarqueeElement":
        return new MarqueeElementWrappingImplementation._wrap(raw);
      case "HTMLMediaElement":
        return new MediaElementWrappingImplementation._wrap(raw);
      case "HTMLMenuElement":
        return new MenuElementWrappingImplementation._wrap(raw);
      case "HTMLMetaElement":
        return new MetaElementWrappingImplementation._wrap(raw);
      case "HTMLMeterElement":
        return new MeterElementWrappingImplementation._wrap(raw);
      case "HTMLModElement":
        return new ModElementWrappingImplementation._wrap(raw);
      case "HTMLOListElement":
        return new OListElementWrappingImplementation._wrap(raw);
      case "HTMLObjectElement":
        return new ObjectElementWrappingImplementation._wrap(raw);
      case "HTMLOptGroupElement":
        return new OptGroupElementWrappingImplementation._wrap(raw);
      case "HTMLOptionElement":
        return new OptionElementWrappingImplementation._wrap(raw);
      case "HTMLOutputElement":
        return new OutputElementWrappingImplementation._wrap(raw);
      case "HTMLParagraphElement":
        return new ParagraphElementWrappingImplementation._wrap(raw);
      case "HTMLParamElement":
        return new ParamElementWrappingImplementation._wrap(raw);
      case "HTMLPreElement":
        return new PreElementWrappingImplementation._wrap(raw);
      case "HTMLProgressElement":
        return new ProgressElementWrappingImplementation._wrap(raw);
      case "HTMLQuoteElement":
        return new QuoteElementWrappingImplementation._wrap(raw);
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphDefElement":
        return new SVGAltGlyphDefElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphItemElement":
        return new SVGAltGlyphItemElementWrappingImplementation._wrap(raw);
      case "SVGAnimateColorElement":
        return new SVGAnimateColorElementWrappingImplementation._wrap(raw);
      case "SVGAnimateElement":
        return new SVGAnimateElementWrappingImplementation._wrap(raw);
      case "SVGAnimateMotionElement":
        return new SVGAnimateMotionElementWrappingImplementation._wrap(raw);
      case "SVGAnimateTransformElement":
        return new SVGAnimateTransformElementWrappingImplementation._wrap(raw);
      case "SVGAnimationElement":
        return new SVGAnimationElementWrappingImplementation._wrap(raw);
      case "SVGCircleElement":
        return new SVGCircleElementWrappingImplementation._wrap(raw);
      case "SVGClipPathElement":
        return new SVGClipPathElementWrappingImplementation._wrap(raw);
      case "SVGComponentTransferFunctionElement":
        return new SVGComponentTransferFunctionElementWrappingImplementation._wrap(raw);
      case "SVGCursorElement":
        return new SVGCursorElementWrappingImplementation._wrap(raw);
      case "SVGDefsElement":
        return new SVGDefsElementWrappingImplementation._wrap(raw);
      case "SVGDescElement":
        return new SVGDescElementWrappingImplementation._wrap(raw);
      case "SVGElement":
        return new SVGElementWrappingImplementation._wrap(raw);
      case "SVGEllipseElement":
        return new SVGEllipseElementWrappingImplementation._wrap(raw);
      case "SVGFEBlendElement":
        return new SVGFEBlendElementWrappingImplementation._wrap(raw);
      case "SVGFEColorMatrixElement":
        return new SVGFEColorMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEComponentTransferElement":
        return new SVGFEComponentTransferElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFECompositeElement*/
      case "SVGFEConvolveMatrixElement":
        return new SVGFEConvolveMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEDiffuseLightingElement":
        return new SVGFEDiffuseLightingElementWrappingImplementation._wrap(raw);
      case "SVGFEDisplacementMapElement":
        return new SVGFEDisplacementMapElementWrappingImplementation._wrap(raw);
      case "SVGFEDistantLightElement":
        return new SVGFEDistantLightElementWrappingImplementation._wrap(raw);
      case "SVGFEDropShadowElement":
        return new SVGFEDropShadowElementWrappingImplementation._wrap(raw);
      case "SVGFEFloodElement":
        return new SVGFEFloodElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncAElement":
        return new SVGFEFuncAElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncBElement":
        return new SVGFEFuncBElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncGElement":
        return new SVGFEFuncGElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncRElement":
        return new SVGFEFuncRElementWrappingImplementation._wrap(raw);
      case "SVGFEGaussianBlurElement":
        return new SVGFEGaussianBlurElementWrappingImplementation._wrap(raw);
      case "SVGFEImageElement":
        return new SVGFEImageElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeElement":
        return new SVGFEMergeElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeNodeElement":
        return new SVGFEMergeNodeElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFEMorphologyElement*/
      case "SVGFEOffsetElement":
        return new SVGFEOffsetElementWrappingImplementation._wrap(raw);
      case "SVGFEPointLightElement":
        return new SVGFEPointLightElementWrappingImplementation._wrap(raw);
      case "SVGFESpecularLightingElement":
        return new SVGFESpecularLightingElementWrappingImplementation._wrap(raw);
      case "SVGFESpotLightElement":
        return new SVGFESpotLightElementWrappingImplementation._wrap(raw);
      case "SVGFETileElement":
        return new SVGFETileElementWrappingImplementation._wrap(raw);
      case "SVGFETurbulenceElement":
        return new SVGFETurbulenceElementWrappingImplementation._wrap(raw);
      case "SVGFilterElement":
        return new SVGFilterElementWrappingImplementation._wrap(raw);
      case "SVGFontElement":
        return new SVGFontElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceElement":
        return new SVGFontFaceElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceFormatElement":
        return new SVGFontFaceFormatElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceNameElement":
        return new SVGFontFaceNameElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceSrcElement":
        return new SVGFontFaceSrcElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceUriElement":
        return new SVGFontFaceUriElementWrappingImplementation._wrap(raw);
      case "SVGForeignObjectElement":
        return new SVGForeignObjectElementWrappingImplementation._wrap(raw);
      case "SVGGElement":
        return new SVGGElementWrappingImplementation._wrap(raw);
      case "SVGGlyphElement":
        return new SVGGlyphElementWrappingImplementation._wrap(raw);
      case "SVGGlyphRefElement":
        return new SVGGlyphRefElementWrappingImplementation._wrap(raw);
      case "SVGGradientElement":
        return new SVGGradientElementWrappingImplementation._wrap(raw);
      case "SVGHKernElement":
        return new SVGHKernElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLineElement":
        return new SVGLineElementWrappingImplementation._wrap(raw);
      case "SVGLinearGradientElement":
        return new SVGLinearGradientElementWrappingImplementation._wrap(raw);
      case "SVGMPathElement":
        return new SVGMPathElementWrappingImplementation._wrap(raw);
      case "SVGMarkerElement":
        return new SVGMarkerElementWrappingImplementation._wrap(raw);
      case "SVGMaskElement":
        return new SVGMaskElementWrappingImplementation._wrap(raw);
      case "SVGMetadataElement":
        return new SVGMetadataElementWrappingImplementation._wrap(raw);
      case "SVGMissingGlyphElement":
        return new SVGMissingGlyphElementWrappingImplementation._wrap(raw);
      case "SVGPathElement":
        return new SVGPathElementWrappingImplementation._wrap(raw);
      case "SVGPatternElement":
        return new SVGPatternElementWrappingImplementation._wrap(raw);
      case "SVGPolygonElement":
        return new SVGPolygonElementWrappingImplementation._wrap(raw);
      case "SVGPolylineElement":
        return new SVGPolylineElementWrappingImplementation._wrap(raw);
      case "SVGRadialGradientElement":
        return new SVGRadialGradientElementWrappingImplementation._wrap(raw);
      case "SVGRectElement":
        return new SVGRectElementWrappingImplementation._wrap(raw);
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGScriptElement":
        return new SVGScriptElementWrappingImplementation._wrap(raw);
      case "SVGSetElement":
        return new SVGSetElementWrappingImplementation._wrap(raw);
      case "SVGStopElement":
        return new SVGStopElementWrappingImplementation._wrap(raw);
      case "SVGStyleElement":
        return new SVGStyleElementWrappingImplementation._wrap(raw);
      case "SVGSwitchElement":
        return new SVGSwitchElementWrappingImplementation._wrap(raw);
      case "SVGSymbolElement":
        return new SVGSymbolElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTSpanElement":
        return new SVGTSpanElementWrappingImplementation._wrap(raw);
      case "SVGTextContentElement":
        return new SVGTextContentElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTextPathElement":
        return new SVGTextPathElementWrappingImplementation._wrap(raw);
      case "SVGTextPositioningElement":
        return new SVGTextPositioningElementWrappingImplementation._wrap(raw);
      case "SVGTitleElement":
        return new SVGTitleElementWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      case "SVGVKernElement":
        return new SVGVKernElementWrappingImplementation._wrap(raw);
      case "SVGViewElement":
        return new SVGViewElementWrappingImplementation._wrap(raw);
      case "HTMLScriptElement":
        return new ScriptElementWrappingImplementation._wrap(raw);
      case "HTMLSelectElement":
        return new SelectElementWrappingImplementation._wrap(raw);
      case "HTMLSourceElement":
        return new SourceElementWrappingImplementation._wrap(raw);
      case "HTMLSpanElement":
        return new SpanElementWrappingImplementation._wrap(raw);
      case "HTMLStyleElement":
        return new StyleElementWrappingImplementation._wrap(raw);
      case "HTMLTableCaptionElement":
        return new TableCaptionElementWrappingImplementation._wrap(raw);
      case "HTMLTableCellElement":
        return new TableCellElementWrappingImplementation._wrap(raw);
      case "HTMLTableColElement":
        return new TableColElementWrappingImplementation._wrap(raw);
      case "HTMLTableElement":
        return new TableElementWrappingImplementation._wrap(raw);
      case "HTMLTableRowElement":
        return new TableRowElementWrappingImplementation._wrap(raw);
      case "HTMLTableSectionElement":
        return new TableSectionElementWrappingImplementation._wrap(raw);
      case "HTMLTextAreaElement":
        return new TextAreaElementWrappingImplementation._wrap(raw);
      case "HTMLTitleElement":
        return new TitleElementWrappingImplementation._wrap(raw);
      case "HTMLTrackElement":
        return new TrackElementWrappingImplementation._wrap(raw);
      case "HTMLUListElement":
        return new UListElementWrappingImplementation._wrap(raw);
      case "HTMLUnknownElement":
        return new UnknownElementWrappingImplementation._wrap(raw);
      case "HTMLVideoElement":
        return new VideoElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static ElementList wrapElementList(raw) {
    return raw === null ? null : new FrozenElementList._wrap(raw);
  }

  static ElementTimeControl wrapElementTimeControl(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "ElementTimeControl":
        return new ElementTimeControlWrappingImplementation._wrap(raw);
      case "SVGAnimateColorElement":
        return new SVGAnimateColorElementWrappingImplementation._wrap(raw);
      case "SVGAnimateElement":
        return new SVGAnimateElementWrappingImplementation._wrap(raw);
      case "SVGAnimateMotionElement":
        return new SVGAnimateMotionElementWrappingImplementation._wrap(raw);
      case "SVGAnimateTransformElement":
        return new SVGAnimateTransformElementWrappingImplementation._wrap(raw);
      case "SVGAnimationElement":
        return new SVGAnimationElementWrappingImplementation._wrap(raw);
      case "SVGSetElement":
        return new SVGSetElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static EmbedElement wrapEmbedElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new EmbedElementWrappingImplementation._wrap(raw);
  }

  static Entity wrapEntity(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new EntityWrappingImplementation._wrap(raw);
  }

  static EntityReference wrapEntityReference(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new EntityReferenceWrappingImplementation._wrap(raw);
  }

  // Skipped EntriesCallback
  static Entry wrapEntry(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "DirectoryEntry":
        return new DirectoryEntryWrappingImplementation._wrap(raw);
      case "Entry":
        return new EntryWrappingImplementation._wrap(raw);
      case "FileEntry":
        return new FileEntryWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static EntryArray wrapEntryArray(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new EntryArrayWrappingImplementation._wrap(raw);
  }

  static EntryArraySync wrapEntryArraySync(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new EntryArraySyncWrappingImplementation._wrap(raw);
  }

  // Skipped EntryCallback
  static EntrySync wrapEntrySync(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "DirectoryEntrySync":
        return new DirectoryEntrySyncWrappingImplementation._wrap(raw);
      case "EntrySync":
        return new EntrySyncWrappingImplementation._wrap(raw);
      case "FileEntrySync":
        return new FileEntrySyncWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  // Skipped ErrorCallback
  static ErrorEvent wrapErrorEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ErrorEventWrappingImplementation._wrap(raw);
  }

  static Event wrapEvent(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "WebKitAnimationEvent":
        return new AnimationEventWrappingImplementation._wrap(raw);
      case "AudioProcessingEvent":
        return new AudioProcessingEventWrappingImplementation._wrap(raw);
      case "BeforeLoadEvent":
        return new BeforeLoadEventWrappingImplementation._wrap(raw);
      case "CloseEvent":
        return new CloseEventWrappingImplementation._wrap(raw);
      case "CompositionEvent":
        return new CompositionEventWrappingImplementation._wrap(raw);
      case "CustomEvent":
        return new CustomEventWrappingImplementation._wrap(raw);
      case "DeviceMotionEvent":
        return new DeviceMotionEventWrappingImplementation._wrap(raw);
      case "DeviceOrientationEvent":
        return new DeviceOrientationEventWrappingImplementation._wrap(raw);
      case "ErrorEvent":
        return new ErrorEventWrappingImplementation._wrap(raw);
      case "Event":
        return new EventWrappingImplementation._wrap(raw);
      case "HashChangeEvent":
        return new HashChangeEventWrappingImplementation._wrap(raw);
      case "IDBVersionChangeEvent":
        return new IDBVersionChangeEventWrappingImplementation._wrap(raw);
      case "KeyboardEvent":
        return new KeyboardEventWrappingImplementation._wrap(raw);
      case "MessageEvent":
        return new MessageEventWrappingImplementation._wrap(raw);
      case "MouseEvent":
        return new MouseEventWrappingImplementation._wrap(raw);
      case "MutationEvent":
        return new MutationEventWrappingImplementation._wrap(raw);
      case "OfflineAudioCompletionEvent":
        return new OfflineAudioCompletionEventWrappingImplementation._wrap(raw);
      case "OverflowEvent":
        return new OverflowEventWrappingImplementation._wrap(raw);
      case "PageTransitionEvent":
        return new PageTransitionEventWrappingImplementation._wrap(raw);
      case "PopStateEvent":
        return new PopStateEventWrappingImplementation._wrap(raw);
      case "ProgressEvent":
        return new ProgressEventWrappingImplementation._wrap(raw);
      case "SVGZoomEvent":
        return new SVGZoomEventWrappingImplementation._wrap(raw);
      case "SpeechInputEvent":
        return new SpeechInputEventWrappingImplementation._wrap(raw);
      case "StorageEvent":
        return new StorageEventWrappingImplementation._wrap(raw);
      case "TextEvent":
        return new TextEventWrappingImplementation._wrap(raw);
      case "TouchEvent":
        return new TouchEventWrappingImplementation._wrap(raw);
      case "WebKitTransitionEvent":
        return new TransitionEventWrappingImplementation._wrap(raw);
      case "UIEvent":
        return new UIEventWrappingImplementation._wrap(raw);
      case "WebGLContextEvent":
        return new WebGLContextEventWrappingImplementation._wrap(raw);
      case "WheelEvent":
        return new WheelEventWrappingImplementation._wrap(raw);
      case "XMLHttpRequestProgressEvent":
        return new XMLHttpRequestProgressEventWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static EventException wrapEventException(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new EventExceptionWrappingImplementation._wrap(raw);
  }

  static Function wrapEventListener(raw) {
    return raw === null ? null : function(evt) { return raw(LevelDom.wrapEvent(evt)); };
  }

  static EventSource wrapEventSource(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new EventSourceWrappingImplementation._wrap(raw);
  }

  static EventTarget wrapEventTarget(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      /* Skipping AbstractWorker*/
      case "HTMLAnchorElement":
        return new AnchorElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLAppletElement*/
      case "HTMLAreaElement":
        return new AreaElementWrappingImplementation._wrap(raw);
      /* Skipping Attr*/
      case "HTMLAudioElement":
        return new AudioElementWrappingImplementation._wrap(raw);
      case "HTMLBRElement":
        return new BRElementWrappingImplementation._wrap(raw);
      case "HTMLBaseElement":
        return new BaseElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLBaseFontElement*/
      case "HTMLBodyElement":
        return new BodyElementWrappingImplementation._wrap(raw);
      case "HTMLButtonElement":
        return new ButtonElementWrappingImplementation._wrap(raw);
      case "CDATASection":
        return new CDATASectionWrappingImplementation._wrap(raw);
      case "HTMLCanvasElement":
        return new CanvasElementWrappingImplementation._wrap(raw);
      case "CharacterData":
        return new CharacterDataWrappingImplementation._wrap(raw);
      case "Comment":
        return new CommentWrappingImplementation._wrap(raw);
      case "HTMLDListElement":
        return new DListElementWrappingImplementation._wrap(raw);
      case "DOMApplicationCache":
        return new DOMApplicationCacheWrappingImplementation._wrap(raw);
      case "HTMLDataListElement":
        return new DataListElementWrappingImplementation._wrap(raw);
      case "HTMLDetailsElement":
        return new DetailsElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLDirectoryElement*/
      case "HTMLDivElement":
        return new DivElementWrappingImplementation._wrap(raw);
      case "HTMLDocument":
        return new DocumentWrappingImplementation._wrap(raw, raw.documentElement);
      case "DocumentFragment":
        return new DocumentFragmentWrappingImplementation._wrap(raw);
      /* Skipping DocumentType*/
      case "HTMLElement":
        return new ElementWrappingImplementation._wrap(raw);
      case "HTMLEmbedElement":
        return new EmbedElementWrappingImplementation._wrap(raw);
      case "Entity":
        return new EntityWrappingImplementation._wrap(raw);
      case "EntityReference":
        return new EntityReferenceWrappingImplementation._wrap(raw);
      case "EventSource":
        return new EventSourceWrappingImplementation._wrap(raw);
      case "EventTarget":
        return new EventTargetWrappingImplementation._wrap(raw);
      case "HTMLFieldSetElement":
        return new FieldSetElementWrappingImplementation._wrap(raw);
      case "HTMLFontElement":
        return new FontElementWrappingImplementation._wrap(raw);
      case "HTMLFormElement":
        return new FormElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLFrameElement*/
      /* Skipping HTMLFrameSetElement*/
      case "HTMLHRElement":
        return new HRElementWrappingImplementation._wrap(raw);
      case "HTMLHeadElement":
        return new HeadElementWrappingImplementation._wrap(raw);
      case "HTMLHeadingElement":
        return new HeadingElementWrappingImplementation._wrap(raw);
      case "HTMLHtmlElement":
        return new DocumentWrappingImplementation._wrap(raw.parentNode, raw);
      case "HTMLIFrameElement":
        return new IFrameElementWrappingImplementation._wrap(raw);
      case "HTMLImageElement":
        return new ImageElementWrappingImplementation._wrap(raw);
      case "HTMLInputElement":
        return new InputElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLIsIndexElement*/
      case "HTMLKeygenElement":
        return new KeygenElementWrappingImplementation._wrap(raw);
      case "HTMLLIElement":
        return new LIElementWrappingImplementation._wrap(raw);
      case "HTMLLabelElement":
        return new LabelElementWrappingImplementation._wrap(raw);
      case "HTMLLegendElement":
        return new LegendElementWrappingImplementation._wrap(raw);
      case "HTMLLinkElement":
        return new LinkElementWrappingImplementation._wrap(raw);
      case "HTMLMapElement":
        return new MapElementWrappingImplementation._wrap(raw);
      case "HTMLMarqueeElement":
        return new MarqueeElementWrappingImplementation._wrap(raw);
      case "HTMLMediaElement":
        return new MediaElementWrappingImplementation._wrap(raw);
      case "HTMLMenuElement":
        return new MenuElementWrappingImplementation._wrap(raw);
      case "MessagePort":
        return new MessagePortWrappingImplementation._wrap(raw);
      case "HTMLMetaElement":
        return new MetaElementWrappingImplementation._wrap(raw);
      case "HTMLMeterElement":
        return new MeterElementWrappingImplementation._wrap(raw);
      case "HTMLModElement":
        return new ModElementWrappingImplementation._wrap(raw);
      case "Node":
        return new NodeWrappingImplementation._wrap(raw);
      case "Notation":
        return new NotationWrappingImplementation._wrap(raw);
      case "Notification":
        return new NotificationWrappingImplementation._wrap(raw);
      case "HTMLOListElement":
        return new OListElementWrappingImplementation._wrap(raw);
      case "HTMLObjectElement":
        return new ObjectElementWrappingImplementation._wrap(raw);
      case "HTMLOptGroupElement":
        return new OptGroupElementWrappingImplementation._wrap(raw);
      case "HTMLOptionElement":
        return new OptionElementWrappingImplementation._wrap(raw);
      case "HTMLOutputElement":
        return new OutputElementWrappingImplementation._wrap(raw);
      case "HTMLParagraphElement":
        return new ParagraphElementWrappingImplementation._wrap(raw);
      case "HTMLParamElement":
        return new ParamElementWrappingImplementation._wrap(raw);
      case "HTMLPreElement":
        return new PreElementWrappingImplementation._wrap(raw);
      case "ProcessingInstruction":
        return new ProcessingInstructionWrappingImplementation._wrap(raw);
      case "HTMLProgressElement":
        return new ProgressElementWrappingImplementation._wrap(raw);
      case "HTMLQuoteElement":
        return new QuoteElementWrappingImplementation._wrap(raw);
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphDefElement":
        return new SVGAltGlyphDefElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphItemElement":
        return new SVGAltGlyphItemElementWrappingImplementation._wrap(raw);
      case "SVGAnimateColorElement":
        return new SVGAnimateColorElementWrappingImplementation._wrap(raw);
      case "SVGAnimateElement":
        return new SVGAnimateElementWrappingImplementation._wrap(raw);
      case "SVGAnimateMotionElement":
        return new SVGAnimateMotionElementWrappingImplementation._wrap(raw);
      case "SVGAnimateTransformElement":
        return new SVGAnimateTransformElementWrappingImplementation._wrap(raw);
      case "SVGAnimationElement":
        return new SVGAnimationElementWrappingImplementation._wrap(raw);
      case "SVGCircleElement":
        return new SVGCircleElementWrappingImplementation._wrap(raw);
      case "SVGClipPathElement":
        return new SVGClipPathElementWrappingImplementation._wrap(raw);
      case "SVGComponentTransferFunctionElement":
        return new SVGComponentTransferFunctionElementWrappingImplementation._wrap(raw);
      case "SVGCursorElement":
        return new SVGCursorElementWrappingImplementation._wrap(raw);
      case "SVGDefsElement":
        return new SVGDefsElementWrappingImplementation._wrap(raw);
      case "SVGDescElement":
        return new SVGDescElementWrappingImplementation._wrap(raw);
      case "SVGDocument":
        return new SVGDocumentWrappingImplementation._wrap(raw);
      case "SVGElement":
        return new SVGElementWrappingImplementation._wrap(raw);
      case "SVGElementInstance":
        return new SVGElementInstanceWrappingImplementation._wrap(raw);
      case "SVGEllipseElement":
        return new SVGEllipseElementWrappingImplementation._wrap(raw);
      case "SVGFEBlendElement":
        return new SVGFEBlendElementWrappingImplementation._wrap(raw);
      case "SVGFEColorMatrixElement":
        return new SVGFEColorMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEComponentTransferElement":
        return new SVGFEComponentTransferElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFECompositeElement*/
      case "SVGFEConvolveMatrixElement":
        return new SVGFEConvolveMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEDiffuseLightingElement":
        return new SVGFEDiffuseLightingElementWrappingImplementation._wrap(raw);
      case "SVGFEDisplacementMapElement":
        return new SVGFEDisplacementMapElementWrappingImplementation._wrap(raw);
      case "SVGFEDistantLightElement":
        return new SVGFEDistantLightElementWrappingImplementation._wrap(raw);
      case "SVGFEDropShadowElement":
        return new SVGFEDropShadowElementWrappingImplementation._wrap(raw);
      case "SVGFEFloodElement":
        return new SVGFEFloodElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncAElement":
        return new SVGFEFuncAElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncBElement":
        return new SVGFEFuncBElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncGElement":
        return new SVGFEFuncGElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncRElement":
        return new SVGFEFuncRElementWrappingImplementation._wrap(raw);
      case "SVGFEGaussianBlurElement":
        return new SVGFEGaussianBlurElementWrappingImplementation._wrap(raw);
      case "SVGFEImageElement":
        return new SVGFEImageElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeElement":
        return new SVGFEMergeElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeNodeElement":
        return new SVGFEMergeNodeElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFEMorphologyElement*/
      case "SVGFEOffsetElement":
        return new SVGFEOffsetElementWrappingImplementation._wrap(raw);
      case "SVGFEPointLightElement":
        return new SVGFEPointLightElementWrappingImplementation._wrap(raw);
      case "SVGFESpecularLightingElement":
        return new SVGFESpecularLightingElementWrappingImplementation._wrap(raw);
      case "SVGFESpotLightElement":
        return new SVGFESpotLightElementWrappingImplementation._wrap(raw);
      case "SVGFETileElement":
        return new SVGFETileElementWrappingImplementation._wrap(raw);
      case "SVGFETurbulenceElement":
        return new SVGFETurbulenceElementWrappingImplementation._wrap(raw);
      case "SVGFilterElement":
        return new SVGFilterElementWrappingImplementation._wrap(raw);
      case "SVGFontElement":
        return new SVGFontElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceElement":
        return new SVGFontFaceElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceFormatElement":
        return new SVGFontFaceFormatElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceNameElement":
        return new SVGFontFaceNameElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceSrcElement":
        return new SVGFontFaceSrcElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceUriElement":
        return new SVGFontFaceUriElementWrappingImplementation._wrap(raw);
      case "SVGForeignObjectElement":
        return new SVGForeignObjectElementWrappingImplementation._wrap(raw);
      case "SVGGElement":
        return new SVGGElementWrappingImplementation._wrap(raw);
      case "SVGGlyphElement":
        return new SVGGlyphElementWrappingImplementation._wrap(raw);
      case "SVGGlyphRefElement":
        return new SVGGlyphRefElementWrappingImplementation._wrap(raw);
      case "SVGGradientElement":
        return new SVGGradientElementWrappingImplementation._wrap(raw);
      case "SVGHKernElement":
        return new SVGHKernElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLineElement":
        return new SVGLineElementWrappingImplementation._wrap(raw);
      case "SVGLinearGradientElement":
        return new SVGLinearGradientElementWrappingImplementation._wrap(raw);
      case "SVGMPathElement":
        return new SVGMPathElementWrappingImplementation._wrap(raw);
      case "SVGMarkerElement":
        return new SVGMarkerElementWrappingImplementation._wrap(raw);
      case "SVGMaskElement":
        return new SVGMaskElementWrappingImplementation._wrap(raw);
      case "SVGMetadataElement":
        return new SVGMetadataElementWrappingImplementation._wrap(raw);
      case "SVGMissingGlyphElement":
        return new SVGMissingGlyphElementWrappingImplementation._wrap(raw);
      case "SVGPathElement":
        return new SVGPathElementWrappingImplementation._wrap(raw);
      case "SVGPatternElement":
        return new SVGPatternElementWrappingImplementation._wrap(raw);
      case "SVGPolygonElement":
        return new SVGPolygonElementWrappingImplementation._wrap(raw);
      case "SVGPolylineElement":
        return new SVGPolylineElementWrappingImplementation._wrap(raw);
      case "SVGRadialGradientElement":
        return new SVGRadialGradientElementWrappingImplementation._wrap(raw);
      case "SVGRectElement":
        return new SVGRectElementWrappingImplementation._wrap(raw);
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGScriptElement":
        return new SVGScriptElementWrappingImplementation._wrap(raw);
      case "SVGSetElement":
        return new SVGSetElementWrappingImplementation._wrap(raw);
      case "SVGStopElement":
        return new SVGStopElementWrappingImplementation._wrap(raw);
      case "SVGStyleElement":
        return new SVGStyleElementWrappingImplementation._wrap(raw);
      case "SVGSwitchElement":
        return new SVGSwitchElementWrappingImplementation._wrap(raw);
      case "SVGSymbolElement":
        return new SVGSymbolElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTSpanElement":
        return new SVGTSpanElementWrappingImplementation._wrap(raw);
      case "SVGTextContentElement":
        return new SVGTextContentElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTextPathElement":
        return new SVGTextPathElementWrappingImplementation._wrap(raw);
      case "SVGTextPositioningElement":
        return new SVGTextPositioningElementWrappingImplementation._wrap(raw);
      case "SVGTitleElement":
        return new SVGTitleElementWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      case "SVGVKernElement":
        return new SVGVKernElementWrappingImplementation._wrap(raw);
      case "SVGViewElement":
        return new SVGViewElementWrappingImplementation._wrap(raw);
      case "HTMLScriptElement":
        return new ScriptElementWrappingImplementation._wrap(raw);
      case "HTMLSelectElement":
        return new SelectElementWrappingImplementation._wrap(raw);
      case "SharedWorker":
        return new SharedWorkerWrappingImplementation._wrap(raw);
      case "HTMLSourceElement":
        return new SourceElementWrappingImplementation._wrap(raw);
      case "HTMLSpanElement":
        return new SpanElementWrappingImplementation._wrap(raw);
      case "HTMLStyleElement":
        return new StyleElementWrappingImplementation._wrap(raw);
      case "HTMLTableCaptionElement":
        return new TableCaptionElementWrappingImplementation._wrap(raw);
      case "HTMLTableCellElement":
        return new TableCellElementWrappingImplementation._wrap(raw);
      case "HTMLTableColElement":
        return new TableColElementWrappingImplementation._wrap(raw);
      case "HTMLTableElement":
        return new TableElementWrappingImplementation._wrap(raw);
      case "HTMLTableRowElement":
        return new TableRowElementWrappingImplementation._wrap(raw);
      case "HTMLTableSectionElement":
        return new TableSectionElementWrappingImplementation._wrap(raw);
      case "Text":
        return new TextWrappingImplementation._wrap(raw);
      case "HTMLTextAreaElement":
        return new TextAreaElementWrappingImplementation._wrap(raw);
      case "HTMLTitleElement":
        return new TitleElementWrappingImplementation._wrap(raw);
      case "HTMLTrackElement":
        return new TrackElementWrappingImplementation._wrap(raw);
      case "HTMLUListElement":
        return new UListElementWrappingImplementation._wrap(raw);
      case "HTMLUnknownElement":
        return new UnknownElementWrappingImplementation._wrap(raw);
      case "HTMLVideoElement":
        return new VideoElementWrappingImplementation._wrap(raw);
      case "WebSocket":
        return new WebSocketWrappingImplementation._wrap(raw);
      case "Window":
        return new WindowWrappingImplementation._wrap(raw);
      case "Worker":
        return new WorkerWrappingImplementation._wrap(raw);
      case "XMLHttpRequest":
        return new XMLHttpRequestWrappingImplementation._wrap(raw);
      case "XMLHttpRequestUpload":
        return new XMLHttpRequestUploadWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static FieldSetElement wrapFieldSetElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FieldSetElementWrappingImplementation._wrap(raw);
  }

  static File wrapFile(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FileWrappingImplementation._wrap(raw);
  }

  // Skipped FileCallback
  static FileEntry wrapFileEntry(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FileEntryWrappingImplementation._wrap(raw);
  }

  static FileEntrySync wrapFileEntrySync(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FileEntrySyncWrappingImplementation._wrap(raw);
  }

  static FileError wrapFileError(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FileErrorWrappingImplementation._wrap(raw);
  }

  static FileException wrapFileException(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FileExceptionWrappingImplementation._wrap(raw);
  }

  static FileList wrapFileList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FileListWrappingImplementation._wrap(raw);
  }

  static FileReader wrapFileReader(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FileReaderWrappingImplementation._wrap(raw);
  }

  static FileReaderSync wrapFileReaderSync(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FileReaderSyncWrappingImplementation._wrap(raw);
  }

  // Skipped FileSystemCallback
  static FileWriter wrapFileWriter(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FileWriterWrappingImplementation._wrap(raw);
  }

  // Skipped FileWriterCallback
  static FileWriterSync wrapFileWriterSync(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FileWriterSyncWrappingImplementation._wrap(raw);
  }

  static Flags wrapFlags(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FlagsWrappingImplementation._wrap(raw);
  }

  static Float32Array wrapFloat32Array(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new Float32ArrayWrappingImplementation._wrap(raw);
  }

  static Float64Array wrapFloat64Array(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new Float64ArrayWrappingImplementation._wrap(raw);
  }

  static FontElement wrapFontElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FontElementWrappingImplementation._wrap(raw);
  }

  static FormElement wrapFormElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new FormElementWrappingImplementation._wrap(raw);
  }

  static Geolocation wrapGeolocation(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new GeolocationWrappingImplementation._wrap(raw);
  }

  static Geoposition wrapGeoposition(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new GeopositionWrappingImplementation._wrap(raw);
  }

  static HRElement wrapHRElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new HRElementWrappingImplementation._wrap(raw);
  }

  static HTMLAllCollection wrapHTMLAllCollection(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new HTMLAllCollectionWrappingImplementation._wrap(raw);
  }

  static HashChangeEvent wrapHashChangeEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new HashChangeEventWrappingImplementation._wrap(raw);
  }

  static HeadElement wrapHeadElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new HeadElementWrappingImplementation._wrap(raw);
  }

  static HeadingElement wrapHeadingElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new HeadingElementWrappingImplementation._wrap(raw);
  }

  static HighPass2FilterNode wrapHighPass2FilterNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new HighPass2FilterNodeWrappingImplementation._wrap(raw);
  }

  static History wrapHistory(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new HistoryWrappingImplementation._wrap(raw);
  }

  static IDBAny wrapIDBAny(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBAnyWrappingImplementation._wrap(raw);
  }

  static IDBCursor wrapIDBCursor(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "IDBCursor":
        return new IDBCursorWrappingImplementation._wrap(raw);
      case "IDBCursorWithValue":
        return new IDBCursorWithValueWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static IDBCursorWithValue wrapIDBCursorWithValue(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBCursorWithValueWrappingImplementation._wrap(raw);
  }

  static IDBDatabase wrapIDBDatabase(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBDatabaseWrappingImplementation._wrap(raw);
  }

  static IDBDatabaseError wrapIDBDatabaseError(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBDatabaseErrorWrappingImplementation._wrap(raw);
  }

  static IDBDatabaseException wrapIDBDatabaseException(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBDatabaseExceptionWrappingImplementation._wrap(raw);
  }

  static IDBFactory wrapIDBFactory(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBFactoryWrappingImplementation._wrap(raw);
  }

  static IDBIndex wrapIDBIndex(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBIndexWrappingImplementation._wrap(raw);
  }

  static IDBKey wrapIDBKey(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBKeyWrappingImplementation._wrap(raw);
  }

  static IDBKeyRange wrapIDBKeyRange(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBKeyRangeWrappingImplementation._wrap(raw);
  }

  static IDBObjectStore wrapIDBObjectStore(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBObjectStoreWrappingImplementation._wrap(raw);
  }

  static IDBRequest wrapIDBRequest(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "IDBRequest":
        return new IDBRequestWrappingImplementation._wrap(raw);
      case "IDBVersionChangeRequest":
        return new IDBVersionChangeRequestWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static IDBTransaction wrapIDBTransaction(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBTransactionWrappingImplementation._wrap(raw);
  }

  static IDBVersionChangeEvent wrapIDBVersionChangeEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBVersionChangeEventWrappingImplementation._wrap(raw);
  }

  static IDBVersionChangeRequest wrapIDBVersionChangeRequest(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IDBVersionChangeRequestWrappingImplementation._wrap(raw);
  }

  static IFrameElement wrapIFrameElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new IFrameElementWrappingImplementation._wrap(raw);
  }

  static ImageData wrapImageData(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ImageDataWrappingImplementation._wrap(raw);
  }

  static ImageElement wrapImageElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ImageElementWrappingImplementation._wrap(raw);
  }

  static InputElement wrapInputElement(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "HTMLInputElement":
        return new InputElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLIsIndexElement*/
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static Int16Array wrapInt16Array(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new Int16ArrayWrappingImplementation._wrap(raw);
  }

  static Int32Array wrapInt32Array(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new Int32ArrayWrappingImplementation._wrap(raw);
  }

  static Int8Array wrapInt8Array(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new Int8ArrayWrappingImplementation._wrap(raw);
  }

  static JavaScriptAudioNode wrapJavaScriptAudioNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new JavaScriptAudioNodeWrappingImplementation._wrap(raw);
  }

  static KeyboardEvent wrapKeyboardEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new KeyboardEventWrappingImplementation._wrap(raw);
  }

  static KeygenElement wrapKeygenElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new KeygenElementWrappingImplementation._wrap(raw);
  }

  static LIElement wrapLIElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new LIElementWrappingImplementation._wrap(raw);
  }

  static LabelElement wrapLabelElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new LabelElementWrappingImplementation._wrap(raw);
  }

  static LegendElement wrapLegendElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new LegendElementWrappingImplementation._wrap(raw);
  }

  static LinkElement wrapLinkElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new LinkElementWrappingImplementation._wrap(raw);
  }

  static Location wrapLocation(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new LocationWrappingImplementation._wrap(raw);
  }

  static LoseContext wrapLoseContext(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new LoseContextWrappingImplementation._wrap(raw);
  }

  static LowPass2FilterNode wrapLowPass2FilterNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new LowPass2FilterNodeWrappingImplementation._wrap(raw);
  }

  static MapElement wrapMapElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MapElementWrappingImplementation._wrap(raw);
  }

  static MarqueeElement wrapMarqueeElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MarqueeElementWrappingImplementation._wrap(raw);
  }

  static MediaElement wrapMediaElement(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "HTMLAudioElement":
        return new AudioElementWrappingImplementation._wrap(raw);
      case "HTMLMediaElement":
        return new MediaElementWrappingImplementation._wrap(raw);
      case "HTMLVideoElement":
        return new VideoElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static MediaElementAudioSourceNode wrapMediaElementAudioSourceNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MediaElementAudioSourceNodeWrappingImplementation._wrap(raw);
  }

  static MediaError wrapMediaError(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MediaErrorWrappingImplementation._wrap(raw);
  }

  static MediaList wrapMediaList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MediaListWrappingImplementation._wrap(raw);
  }

  static MediaQueryList wrapMediaQueryList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MediaQueryListWrappingImplementation._wrap(raw);
  }

  static MediaQueryListListener wrapMediaQueryListListener(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MediaQueryListListenerWrappingImplementation._wrap(raw);
  }

  static MenuElement wrapMenuElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MenuElementWrappingImplementation._wrap(raw);
  }

  static MessageChannel wrapMessageChannel(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MessageChannelWrappingImplementation._wrap(raw);
  }

  static MessageEvent wrapMessageEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MessageEventWrappingImplementation._wrap(raw);
  }

  static MessagePort wrapMessagePort(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MessagePortWrappingImplementation._wrap(raw);
  }

  static MetaElement wrapMetaElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MetaElementWrappingImplementation._wrap(raw);
  }

  static Metadata wrapMetadata(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MetadataWrappingImplementation._wrap(raw);
  }

  // Skipped MetadataCallback
  static MeterElement wrapMeterElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MeterElementWrappingImplementation._wrap(raw);
  }

  static ModElement wrapModElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ModElementWrappingImplementation._wrap(raw);
  }

  static MouseEvent wrapMouseEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MouseEventWrappingImplementation._wrap(raw);
  }

  static MutationCallback wrapMutationCallback(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MutationCallbackWrappingImplementation._wrap(raw);
  }

  static MutationEvent wrapMutationEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MutationEventWrappingImplementation._wrap(raw);
  }

  static MutationRecord wrapMutationRecord(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new MutationRecordWrappingImplementation._wrap(raw);
  }

  static Navigator wrapNavigator(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new NavigatorWrappingImplementation._wrap(raw);
  }

  static NavigatorUserMediaError wrapNavigatorUserMediaError(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new NavigatorUserMediaErrorWrappingImplementation._wrap(raw);
  }

  // Skipped NavigatorUserMediaErrorCallback
  static NavigatorUserMediaSuccessCallback wrapNavigatorUserMediaSuccessCallback(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new NavigatorUserMediaSuccessCallbackWrappingImplementation._wrap(raw);
  }

  static Node wrapNode(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "HTMLAnchorElement":
        return new AnchorElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLAppletElement*/
      case "HTMLAreaElement":
        return new AreaElementWrappingImplementation._wrap(raw);
      /* Skipping Attr*/
      case "HTMLAudioElement":
        return new AudioElementWrappingImplementation._wrap(raw);
      case "HTMLBRElement":
        return new BRElementWrappingImplementation._wrap(raw);
      case "HTMLBaseElement":
        return new BaseElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLBaseFontElement*/
      case "HTMLBodyElement":
        return new BodyElementWrappingImplementation._wrap(raw);
      case "HTMLButtonElement":
        return new ButtonElementWrappingImplementation._wrap(raw);
      case "CDATASection":
        return new CDATASectionWrappingImplementation._wrap(raw);
      case "HTMLCanvasElement":
        return new CanvasElementWrappingImplementation._wrap(raw);
      case "CharacterData":
        return new CharacterDataWrappingImplementation._wrap(raw);
      case "Comment":
        return new CommentWrappingImplementation._wrap(raw);
      case "HTMLDListElement":
        return new DListElementWrappingImplementation._wrap(raw);
      case "HTMLDataListElement":
        return new DataListElementWrappingImplementation._wrap(raw);
      case "HTMLDetailsElement":
        return new DetailsElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLDirectoryElement*/
      case "HTMLDivElement":
        return new DivElementWrappingImplementation._wrap(raw);
      case "HTMLDocument":
        return new DocumentWrappingImplementation._wrap(raw, raw.documentElement);
      case "DocumentFragment":
        return new DocumentFragmentWrappingImplementation._wrap(raw);
      /* Skipping DocumentType*/
      case "HTMLElement":
        return new ElementWrappingImplementation._wrap(raw);
      case "HTMLEmbedElement":
        return new EmbedElementWrappingImplementation._wrap(raw);
      case "Entity":
        return new EntityWrappingImplementation._wrap(raw);
      case "EntityReference":
        return new EntityReferenceWrappingImplementation._wrap(raw);
      case "HTMLFieldSetElement":
        return new FieldSetElementWrappingImplementation._wrap(raw);
      case "HTMLFontElement":
        return new FontElementWrappingImplementation._wrap(raw);
      case "HTMLFormElement":
        return new FormElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLFrameElement*/
      /* Skipping HTMLFrameSetElement*/
      case "HTMLHRElement":
        return new HRElementWrappingImplementation._wrap(raw);
      case "HTMLHeadElement":
        return new HeadElementWrappingImplementation._wrap(raw);
      case "HTMLHeadingElement":
        return new HeadingElementWrappingImplementation._wrap(raw);
      case "HTMLHtmlElement":
        return new DocumentWrappingImplementation._wrap(raw.parentNode, raw);
      case "HTMLIFrameElement":
        return new IFrameElementWrappingImplementation._wrap(raw);
      case "HTMLImageElement":
        return new ImageElementWrappingImplementation._wrap(raw);
      case "HTMLInputElement":
        return new InputElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLIsIndexElement*/
      case "HTMLKeygenElement":
        return new KeygenElementWrappingImplementation._wrap(raw);
      case "HTMLLIElement":
        return new LIElementWrappingImplementation._wrap(raw);
      case "HTMLLabelElement":
        return new LabelElementWrappingImplementation._wrap(raw);
      case "HTMLLegendElement":
        return new LegendElementWrappingImplementation._wrap(raw);
      case "HTMLLinkElement":
        return new LinkElementWrappingImplementation._wrap(raw);
      case "HTMLMapElement":
        return new MapElementWrappingImplementation._wrap(raw);
      case "HTMLMarqueeElement":
        return new MarqueeElementWrappingImplementation._wrap(raw);
      case "HTMLMediaElement":
        return new MediaElementWrappingImplementation._wrap(raw);
      case "HTMLMenuElement":
        return new MenuElementWrappingImplementation._wrap(raw);
      case "HTMLMetaElement":
        return new MetaElementWrappingImplementation._wrap(raw);
      case "HTMLMeterElement":
        return new MeterElementWrappingImplementation._wrap(raw);
      case "HTMLModElement":
        return new ModElementWrappingImplementation._wrap(raw);
      case "Node":
        return new NodeWrappingImplementation._wrap(raw);
      case "Notation":
        return new NotationWrappingImplementation._wrap(raw);
      case "HTMLOListElement":
        return new OListElementWrappingImplementation._wrap(raw);
      case "HTMLObjectElement":
        return new ObjectElementWrappingImplementation._wrap(raw);
      case "HTMLOptGroupElement":
        return new OptGroupElementWrappingImplementation._wrap(raw);
      case "HTMLOptionElement":
        return new OptionElementWrappingImplementation._wrap(raw);
      case "HTMLOutputElement":
        return new OutputElementWrappingImplementation._wrap(raw);
      case "HTMLParagraphElement":
        return new ParagraphElementWrappingImplementation._wrap(raw);
      case "HTMLParamElement":
        return new ParamElementWrappingImplementation._wrap(raw);
      case "HTMLPreElement":
        return new PreElementWrappingImplementation._wrap(raw);
      case "ProcessingInstruction":
        return new ProcessingInstructionWrappingImplementation._wrap(raw);
      case "HTMLProgressElement":
        return new ProgressElementWrappingImplementation._wrap(raw);
      case "HTMLQuoteElement":
        return new QuoteElementWrappingImplementation._wrap(raw);
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphDefElement":
        return new SVGAltGlyphDefElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphItemElement":
        return new SVGAltGlyphItemElementWrappingImplementation._wrap(raw);
      case "SVGAnimateColorElement":
        return new SVGAnimateColorElementWrappingImplementation._wrap(raw);
      case "SVGAnimateElement":
        return new SVGAnimateElementWrappingImplementation._wrap(raw);
      case "SVGAnimateMotionElement":
        return new SVGAnimateMotionElementWrappingImplementation._wrap(raw);
      case "SVGAnimateTransformElement":
        return new SVGAnimateTransformElementWrappingImplementation._wrap(raw);
      case "SVGAnimationElement":
        return new SVGAnimationElementWrappingImplementation._wrap(raw);
      case "SVGCircleElement":
        return new SVGCircleElementWrappingImplementation._wrap(raw);
      case "SVGClipPathElement":
        return new SVGClipPathElementWrappingImplementation._wrap(raw);
      case "SVGComponentTransferFunctionElement":
        return new SVGComponentTransferFunctionElementWrappingImplementation._wrap(raw);
      case "SVGCursorElement":
        return new SVGCursorElementWrappingImplementation._wrap(raw);
      case "SVGDefsElement":
        return new SVGDefsElementWrappingImplementation._wrap(raw);
      case "SVGDescElement":
        return new SVGDescElementWrappingImplementation._wrap(raw);
      case "SVGDocument":
        return new SVGDocumentWrappingImplementation._wrap(raw);
      case "SVGElement":
        return new SVGElementWrappingImplementation._wrap(raw);
      case "SVGEllipseElement":
        return new SVGEllipseElementWrappingImplementation._wrap(raw);
      case "SVGFEBlendElement":
        return new SVGFEBlendElementWrappingImplementation._wrap(raw);
      case "SVGFEColorMatrixElement":
        return new SVGFEColorMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEComponentTransferElement":
        return new SVGFEComponentTransferElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFECompositeElement*/
      case "SVGFEConvolveMatrixElement":
        return new SVGFEConvolveMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEDiffuseLightingElement":
        return new SVGFEDiffuseLightingElementWrappingImplementation._wrap(raw);
      case "SVGFEDisplacementMapElement":
        return new SVGFEDisplacementMapElementWrappingImplementation._wrap(raw);
      case "SVGFEDistantLightElement":
        return new SVGFEDistantLightElementWrappingImplementation._wrap(raw);
      case "SVGFEDropShadowElement":
        return new SVGFEDropShadowElementWrappingImplementation._wrap(raw);
      case "SVGFEFloodElement":
        return new SVGFEFloodElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncAElement":
        return new SVGFEFuncAElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncBElement":
        return new SVGFEFuncBElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncGElement":
        return new SVGFEFuncGElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncRElement":
        return new SVGFEFuncRElementWrappingImplementation._wrap(raw);
      case "SVGFEGaussianBlurElement":
        return new SVGFEGaussianBlurElementWrappingImplementation._wrap(raw);
      case "SVGFEImageElement":
        return new SVGFEImageElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeElement":
        return new SVGFEMergeElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeNodeElement":
        return new SVGFEMergeNodeElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFEMorphologyElement*/
      case "SVGFEOffsetElement":
        return new SVGFEOffsetElementWrappingImplementation._wrap(raw);
      case "SVGFEPointLightElement":
        return new SVGFEPointLightElementWrappingImplementation._wrap(raw);
      case "SVGFESpecularLightingElement":
        return new SVGFESpecularLightingElementWrappingImplementation._wrap(raw);
      case "SVGFESpotLightElement":
        return new SVGFESpotLightElementWrappingImplementation._wrap(raw);
      case "SVGFETileElement":
        return new SVGFETileElementWrappingImplementation._wrap(raw);
      case "SVGFETurbulenceElement":
        return new SVGFETurbulenceElementWrappingImplementation._wrap(raw);
      case "SVGFilterElement":
        return new SVGFilterElementWrappingImplementation._wrap(raw);
      case "SVGFontElement":
        return new SVGFontElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceElement":
        return new SVGFontFaceElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceFormatElement":
        return new SVGFontFaceFormatElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceNameElement":
        return new SVGFontFaceNameElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceSrcElement":
        return new SVGFontFaceSrcElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceUriElement":
        return new SVGFontFaceUriElementWrappingImplementation._wrap(raw);
      case "SVGForeignObjectElement":
        return new SVGForeignObjectElementWrappingImplementation._wrap(raw);
      case "SVGGElement":
        return new SVGGElementWrappingImplementation._wrap(raw);
      case "SVGGlyphElement":
        return new SVGGlyphElementWrappingImplementation._wrap(raw);
      case "SVGGlyphRefElement":
        return new SVGGlyphRefElementWrappingImplementation._wrap(raw);
      case "SVGGradientElement":
        return new SVGGradientElementWrappingImplementation._wrap(raw);
      case "SVGHKernElement":
        return new SVGHKernElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLineElement":
        return new SVGLineElementWrappingImplementation._wrap(raw);
      case "SVGLinearGradientElement":
        return new SVGLinearGradientElementWrappingImplementation._wrap(raw);
      case "SVGMPathElement":
        return new SVGMPathElementWrappingImplementation._wrap(raw);
      case "SVGMarkerElement":
        return new SVGMarkerElementWrappingImplementation._wrap(raw);
      case "SVGMaskElement":
        return new SVGMaskElementWrappingImplementation._wrap(raw);
      case "SVGMetadataElement":
        return new SVGMetadataElementWrappingImplementation._wrap(raw);
      case "SVGMissingGlyphElement":
        return new SVGMissingGlyphElementWrappingImplementation._wrap(raw);
      case "SVGPathElement":
        return new SVGPathElementWrappingImplementation._wrap(raw);
      case "SVGPatternElement":
        return new SVGPatternElementWrappingImplementation._wrap(raw);
      case "SVGPolygonElement":
        return new SVGPolygonElementWrappingImplementation._wrap(raw);
      case "SVGPolylineElement":
        return new SVGPolylineElementWrappingImplementation._wrap(raw);
      case "SVGRadialGradientElement":
        return new SVGRadialGradientElementWrappingImplementation._wrap(raw);
      case "SVGRectElement":
        return new SVGRectElementWrappingImplementation._wrap(raw);
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGScriptElement":
        return new SVGScriptElementWrappingImplementation._wrap(raw);
      case "SVGSetElement":
        return new SVGSetElementWrappingImplementation._wrap(raw);
      case "SVGStopElement":
        return new SVGStopElementWrappingImplementation._wrap(raw);
      case "SVGStyleElement":
        return new SVGStyleElementWrappingImplementation._wrap(raw);
      case "SVGSwitchElement":
        return new SVGSwitchElementWrappingImplementation._wrap(raw);
      case "SVGSymbolElement":
        return new SVGSymbolElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTSpanElement":
        return new SVGTSpanElementWrappingImplementation._wrap(raw);
      case "SVGTextContentElement":
        return new SVGTextContentElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTextPathElement":
        return new SVGTextPathElementWrappingImplementation._wrap(raw);
      case "SVGTextPositioningElement":
        return new SVGTextPositioningElementWrappingImplementation._wrap(raw);
      case "SVGTitleElement":
        return new SVGTitleElementWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      case "SVGVKernElement":
        return new SVGVKernElementWrappingImplementation._wrap(raw);
      case "SVGViewElement":
        return new SVGViewElementWrappingImplementation._wrap(raw);
      case "HTMLScriptElement":
        return new ScriptElementWrappingImplementation._wrap(raw);
      case "HTMLSelectElement":
        return new SelectElementWrappingImplementation._wrap(raw);
      case "HTMLSourceElement":
        return new SourceElementWrappingImplementation._wrap(raw);
      case "HTMLSpanElement":
        return new SpanElementWrappingImplementation._wrap(raw);
      case "HTMLStyleElement":
        return new StyleElementWrappingImplementation._wrap(raw);
      case "HTMLTableCaptionElement":
        return new TableCaptionElementWrappingImplementation._wrap(raw);
      case "HTMLTableCellElement":
        return new TableCellElementWrappingImplementation._wrap(raw);
      case "HTMLTableColElement":
        return new TableColElementWrappingImplementation._wrap(raw);
      case "HTMLTableElement":
        return new TableElementWrappingImplementation._wrap(raw);
      case "HTMLTableRowElement":
        return new TableRowElementWrappingImplementation._wrap(raw);
      case "HTMLTableSectionElement":
        return new TableSectionElementWrappingImplementation._wrap(raw);
      case "Text":
        return new TextWrappingImplementation._wrap(raw);
      case "HTMLTextAreaElement":
        return new TextAreaElementWrappingImplementation._wrap(raw);
      case "HTMLTitleElement":
        return new TitleElementWrappingImplementation._wrap(raw);
      case "HTMLTrackElement":
        return new TrackElementWrappingImplementation._wrap(raw);
      case "HTMLUListElement":
        return new UListElementWrappingImplementation._wrap(raw);
      case "HTMLUnknownElement":
        return new UnknownElementWrappingImplementation._wrap(raw);
      case "HTMLVideoElement":
        return new VideoElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static Notation wrapNotation(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new NotationWrappingImplementation._wrap(raw);
  }

  static Notification wrapNotification(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new NotificationWrappingImplementation._wrap(raw);
  }

  static NotificationCenter wrapNotificationCenter(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new NotificationCenterWrappingImplementation._wrap(raw);
  }

  static OESStandardDerivatives wrapOESStandardDerivatives(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new OESStandardDerivativesWrappingImplementation._wrap(raw);
  }

  static OESTextureFloat wrapOESTextureFloat(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new OESTextureFloatWrappingImplementation._wrap(raw);
  }

  static OESVertexArrayObject wrapOESVertexArrayObject(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new OESVertexArrayObjectWrappingImplementation._wrap(raw);
  }

  static OListElement wrapOListElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new OListElementWrappingImplementation._wrap(raw);
  }

  static ObjectElement wrapObjectElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ObjectElementWrappingImplementation._wrap(raw);
  }

  static OfflineAudioCompletionEvent wrapOfflineAudioCompletionEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new OfflineAudioCompletionEventWrappingImplementation._wrap(raw);
  }

  static OperationNotAllowedException wrapOperationNotAllowedException(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new OperationNotAllowedExceptionWrappingImplementation._wrap(raw);
  }

  static OptGroupElement wrapOptGroupElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new OptGroupElementWrappingImplementation._wrap(raw);
  }

  static OptionElement wrapOptionElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new OptionElementWrappingImplementation._wrap(raw);
  }

  static OutputElement wrapOutputElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new OutputElementWrappingImplementation._wrap(raw);
  }

  static OverflowEvent wrapOverflowEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new OverflowEventWrappingImplementation._wrap(raw);
  }

  static PageTransitionEvent wrapPageTransitionEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new PageTransitionEventWrappingImplementation._wrap(raw);
  }

  static ParagraphElement wrapParagraphElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ParagraphElementWrappingImplementation._wrap(raw);
  }

  static ParamElement wrapParamElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ParamElementWrappingImplementation._wrap(raw);
  }

  static Point wrapPoint(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new PointWrappingImplementation._wrap(raw);
  }

  static PopStateEvent wrapPopStateEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new PopStateEventWrappingImplementation._wrap(raw);
  }

  // Skipped PositionCallback
  static PositionError wrapPositionError(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new PositionErrorWrappingImplementation._wrap(raw);
  }

  // Skipped PositionErrorCallback
  static PreElement wrapPreElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new PreElementWrappingImplementation._wrap(raw);
  }

  static ProcessingInstruction wrapProcessingInstruction(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ProcessingInstructionWrappingImplementation._wrap(raw);
  }

  static ProgressElement wrapProgressElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ProgressElementWrappingImplementation._wrap(raw);
  }

  static ProgressEvent wrapProgressEvent(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "ProgressEvent":
        return new ProgressEventWrappingImplementation._wrap(raw);
      case "XMLHttpRequestProgressEvent":
        return new XMLHttpRequestProgressEventWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static QuoteElement wrapQuoteElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new QuoteElementWrappingImplementation._wrap(raw);
  }

  static RGBColor wrapRGBColor(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new RGBColorWrappingImplementation._wrap(raw);
  }

  static Range wrapRange(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new RangeWrappingImplementation._wrap(raw);
  }

  static RangeException wrapRangeException(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new RangeExceptionWrappingImplementation._wrap(raw);
  }

  static RealtimeAnalyserNode wrapRealtimeAnalyserNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new RealtimeAnalyserNodeWrappingImplementation._wrap(raw);
  }

  static Rect wrapRect(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new RectWrappingImplementation._wrap(raw);
  }

  // Skipped RequestAnimationFrameCallback
  // Skipped SQLStatementCallback
  // Skipped SQLStatementErrorCallback
  // Skipped SQLTransactionCallback
  // Skipped SQLTransactionErrorCallback
  // Skipped SQLTransactionSyncCallback
  static SVGAElement wrapSVGAElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAElementWrappingImplementation._wrap(raw);
  }

  static SVGAltGlyphDefElement wrapSVGAltGlyphDefElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAltGlyphDefElementWrappingImplementation._wrap(raw);
  }

  static SVGAltGlyphElement wrapSVGAltGlyphElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAltGlyphElementWrappingImplementation._wrap(raw);
  }

  static SVGAltGlyphItemElement wrapSVGAltGlyphItemElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAltGlyphItemElementWrappingImplementation._wrap(raw);
  }

  static SVGAngle wrapSVGAngle(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAngleWrappingImplementation._wrap(raw);
  }

  static SVGAnimateColorElement wrapSVGAnimateColorElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimateColorElementWrappingImplementation._wrap(raw);
  }

  static SVGAnimateElement wrapSVGAnimateElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimateElementWrappingImplementation._wrap(raw);
  }

  static SVGAnimateMotionElement wrapSVGAnimateMotionElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimateMotionElementWrappingImplementation._wrap(raw);
  }

  static SVGAnimateTransformElement wrapSVGAnimateTransformElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimateTransformElementWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedAngle wrapSVGAnimatedAngle(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedAngleWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedBoolean wrapSVGAnimatedBoolean(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedBooleanWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedEnumeration wrapSVGAnimatedEnumeration(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedEnumerationWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedInteger wrapSVGAnimatedInteger(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedIntegerWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedLength wrapSVGAnimatedLength(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedLengthWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedLengthList wrapSVGAnimatedLengthList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedLengthListWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedNumber wrapSVGAnimatedNumber(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedNumberWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedNumberList wrapSVGAnimatedNumberList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedNumberListWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedPreserveAspectRatio wrapSVGAnimatedPreserveAspectRatio(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedPreserveAspectRatioWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedRect wrapSVGAnimatedRect(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedRectWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedString wrapSVGAnimatedString(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedStringWrappingImplementation._wrap(raw);
  }

  static SVGAnimatedTransformList wrapSVGAnimatedTransformList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGAnimatedTransformListWrappingImplementation._wrap(raw);
  }

  static SVGAnimationElement wrapSVGAnimationElement(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGAnimateColorElement":
        return new SVGAnimateColorElementWrappingImplementation._wrap(raw);
      case "SVGAnimateElement":
        return new SVGAnimateElementWrappingImplementation._wrap(raw);
      case "SVGAnimateMotionElement":
        return new SVGAnimateMotionElementWrappingImplementation._wrap(raw);
      case "SVGAnimateTransformElement":
        return new SVGAnimateTransformElementWrappingImplementation._wrap(raw);
      case "SVGAnimationElement":
        return new SVGAnimationElementWrappingImplementation._wrap(raw);
      case "SVGSetElement":
        return new SVGSetElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGCircleElement wrapSVGCircleElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGCircleElementWrappingImplementation._wrap(raw);
  }

  static SVGClipPathElement wrapSVGClipPathElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGClipPathElementWrappingImplementation._wrap(raw);
  }

  static SVGColor wrapSVGColor(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGColor":
        return new SVGColorWrappingImplementation._wrap(raw);
      case "SVGPaint":
        return new SVGPaintWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGComponentTransferFunctionElement wrapSVGComponentTransferFunctionElement(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGComponentTransferFunctionElement":
        return new SVGComponentTransferFunctionElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncAElement":
        return new SVGFEFuncAElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncBElement":
        return new SVGFEFuncBElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncGElement":
        return new SVGFEFuncGElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncRElement":
        return new SVGFEFuncRElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGCursorElement wrapSVGCursorElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGCursorElementWrappingImplementation._wrap(raw);
  }

  static SVGDefsElement wrapSVGDefsElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGDefsElementWrappingImplementation._wrap(raw);
  }

  static SVGDescElement wrapSVGDescElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGDescElementWrappingImplementation._wrap(raw);
  }

  static SVGDocument wrapSVGDocument(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGDocumentWrappingImplementation._wrap(raw);
  }

  static SVGElement wrapSVGElement(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphDefElement":
        return new SVGAltGlyphDefElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphItemElement":
        return new SVGAltGlyphItemElementWrappingImplementation._wrap(raw);
      case "SVGAnimateColorElement":
        return new SVGAnimateColorElementWrappingImplementation._wrap(raw);
      case "SVGAnimateElement":
        return new SVGAnimateElementWrappingImplementation._wrap(raw);
      case "SVGAnimateMotionElement":
        return new SVGAnimateMotionElementWrappingImplementation._wrap(raw);
      case "SVGAnimateTransformElement":
        return new SVGAnimateTransformElementWrappingImplementation._wrap(raw);
      case "SVGAnimationElement":
        return new SVGAnimationElementWrappingImplementation._wrap(raw);
      case "SVGCircleElement":
        return new SVGCircleElementWrappingImplementation._wrap(raw);
      case "SVGClipPathElement":
        return new SVGClipPathElementWrappingImplementation._wrap(raw);
      case "SVGComponentTransferFunctionElement":
        return new SVGComponentTransferFunctionElementWrappingImplementation._wrap(raw);
      case "SVGCursorElement":
        return new SVGCursorElementWrappingImplementation._wrap(raw);
      case "SVGDefsElement":
        return new SVGDefsElementWrappingImplementation._wrap(raw);
      case "SVGDescElement":
        return new SVGDescElementWrappingImplementation._wrap(raw);
      case "SVGElement":
        return new SVGElementWrappingImplementation._wrap(raw);
      case "SVGEllipseElement":
        return new SVGEllipseElementWrappingImplementation._wrap(raw);
      case "SVGFEBlendElement":
        return new SVGFEBlendElementWrappingImplementation._wrap(raw);
      case "SVGFEColorMatrixElement":
        return new SVGFEColorMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEComponentTransferElement":
        return new SVGFEComponentTransferElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFECompositeElement*/
      case "SVGFEConvolveMatrixElement":
        return new SVGFEConvolveMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEDiffuseLightingElement":
        return new SVGFEDiffuseLightingElementWrappingImplementation._wrap(raw);
      case "SVGFEDisplacementMapElement":
        return new SVGFEDisplacementMapElementWrappingImplementation._wrap(raw);
      case "SVGFEDistantLightElement":
        return new SVGFEDistantLightElementWrappingImplementation._wrap(raw);
      case "SVGFEDropShadowElement":
        return new SVGFEDropShadowElementWrappingImplementation._wrap(raw);
      case "SVGFEFloodElement":
        return new SVGFEFloodElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncAElement":
        return new SVGFEFuncAElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncBElement":
        return new SVGFEFuncBElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncGElement":
        return new SVGFEFuncGElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncRElement":
        return new SVGFEFuncRElementWrappingImplementation._wrap(raw);
      case "SVGFEGaussianBlurElement":
        return new SVGFEGaussianBlurElementWrappingImplementation._wrap(raw);
      case "SVGFEImageElement":
        return new SVGFEImageElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeElement":
        return new SVGFEMergeElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeNodeElement":
        return new SVGFEMergeNodeElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFEMorphologyElement*/
      case "SVGFEOffsetElement":
        return new SVGFEOffsetElementWrappingImplementation._wrap(raw);
      case "SVGFEPointLightElement":
        return new SVGFEPointLightElementWrappingImplementation._wrap(raw);
      case "SVGFESpecularLightingElement":
        return new SVGFESpecularLightingElementWrappingImplementation._wrap(raw);
      case "SVGFESpotLightElement":
        return new SVGFESpotLightElementWrappingImplementation._wrap(raw);
      case "SVGFETileElement":
        return new SVGFETileElementWrappingImplementation._wrap(raw);
      case "SVGFETurbulenceElement":
        return new SVGFETurbulenceElementWrappingImplementation._wrap(raw);
      case "SVGFilterElement":
        return new SVGFilterElementWrappingImplementation._wrap(raw);
      case "SVGFontElement":
        return new SVGFontElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceElement":
        return new SVGFontFaceElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceFormatElement":
        return new SVGFontFaceFormatElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceNameElement":
        return new SVGFontFaceNameElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceSrcElement":
        return new SVGFontFaceSrcElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceUriElement":
        return new SVGFontFaceUriElementWrappingImplementation._wrap(raw);
      case "SVGForeignObjectElement":
        return new SVGForeignObjectElementWrappingImplementation._wrap(raw);
      case "SVGGElement":
        return new SVGGElementWrappingImplementation._wrap(raw);
      case "SVGGlyphElement":
        return new SVGGlyphElementWrappingImplementation._wrap(raw);
      case "SVGGlyphRefElement":
        return new SVGGlyphRefElementWrappingImplementation._wrap(raw);
      case "SVGGradientElement":
        return new SVGGradientElementWrappingImplementation._wrap(raw);
      case "SVGHKernElement":
        return new SVGHKernElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLineElement":
        return new SVGLineElementWrappingImplementation._wrap(raw);
      case "SVGLinearGradientElement":
        return new SVGLinearGradientElementWrappingImplementation._wrap(raw);
      case "SVGMPathElement":
        return new SVGMPathElementWrappingImplementation._wrap(raw);
      case "SVGMarkerElement":
        return new SVGMarkerElementWrappingImplementation._wrap(raw);
      case "SVGMaskElement":
        return new SVGMaskElementWrappingImplementation._wrap(raw);
      case "SVGMetadataElement":
        return new SVGMetadataElementWrappingImplementation._wrap(raw);
      case "SVGMissingGlyphElement":
        return new SVGMissingGlyphElementWrappingImplementation._wrap(raw);
      case "SVGPathElement":
        return new SVGPathElementWrappingImplementation._wrap(raw);
      case "SVGPatternElement":
        return new SVGPatternElementWrappingImplementation._wrap(raw);
      case "SVGPolygonElement":
        return new SVGPolygonElementWrappingImplementation._wrap(raw);
      case "SVGPolylineElement":
        return new SVGPolylineElementWrappingImplementation._wrap(raw);
      case "SVGRadialGradientElement":
        return new SVGRadialGradientElementWrappingImplementation._wrap(raw);
      case "SVGRectElement":
        return new SVGRectElementWrappingImplementation._wrap(raw);
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGScriptElement":
        return new SVGScriptElementWrappingImplementation._wrap(raw);
      case "SVGSetElement":
        return new SVGSetElementWrappingImplementation._wrap(raw);
      case "SVGStopElement":
        return new SVGStopElementWrappingImplementation._wrap(raw);
      case "SVGStyleElement":
        return new SVGStyleElementWrappingImplementation._wrap(raw);
      case "SVGSwitchElement":
        return new SVGSwitchElementWrappingImplementation._wrap(raw);
      case "SVGSymbolElement":
        return new SVGSymbolElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTSpanElement":
        return new SVGTSpanElementWrappingImplementation._wrap(raw);
      case "SVGTextContentElement":
        return new SVGTextContentElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTextPathElement":
        return new SVGTextPathElementWrappingImplementation._wrap(raw);
      case "SVGTextPositioningElement":
        return new SVGTextPositioningElementWrappingImplementation._wrap(raw);
      case "SVGTitleElement":
        return new SVGTitleElementWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      case "SVGVKernElement":
        return new SVGVKernElementWrappingImplementation._wrap(raw);
      case "SVGViewElement":
        return new SVGViewElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGElementInstance wrapSVGElementInstance(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGElementInstanceWrappingImplementation._wrap(raw);
  }

  static SVGElementInstanceList wrapSVGElementInstanceList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGElementInstanceListWrappingImplementation._wrap(raw);
  }

  static SVGEllipseElement wrapSVGEllipseElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGEllipseElementWrappingImplementation._wrap(raw);
  }

  static SVGException wrapSVGException(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGExceptionWrappingImplementation._wrap(raw);
  }

  static SVGExternalResourcesRequired wrapSVGExternalResourcesRequired(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGAnimateColorElement":
        return new SVGAnimateColorElementWrappingImplementation._wrap(raw);
      case "SVGAnimateElement":
        return new SVGAnimateElementWrappingImplementation._wrap(raw);
      case "SVGAnimateMotionElement":
        return new SVGAnimateMotionElementWrappingImplementation._wrap(raw);
      case "SVGAnimateTransformElement":
        return new SVGAnimateTransformElementWrappingImplementation._wrap(raw);
      case "SVGAnimationElement":
        return new SVGAnimationElementWrappingImplementation._wrap(raw);
      case "SVGCircleElement":
        return new SVGCircleElementWrappingImplementation._wrap(raw);
      case "SVGClipPathElement":
        return new SVGClipPathElementWrappingImplementation._wrap(raw);
      case "SVGCursorElement":
        return new SVGCursorElementWrappingImplementation._wrap(raw);
      case "SVGDefsElement":
        return new SVGDefsElementWrappingImplementation._wrap(raw);
      case "SVGEllipseElement":
        return new SVGEllipseElementWrappingImplementation._wrap(raw);
      case "SVGExternalResourcesRequired":
        return new SVGExternalResourcesRequiredWrappingImplementation._wrap(raw);
      case "SVGFEImageElement":
        return new SVGFEImageElementWrappingImplementation._wrap(raw);
      case "SVGFilterElement":
        return new SVGFilterElementWrappingImplementation._wrap(raw);
      case "SVGForeignObjectElement":
        return new SVGForeignObjectElementWrappingImplementation._wrap(raw);
      case "SVGGElement":
        return new SVGGElementWrappingImplementation._wrap(raw);
      case "SVGGradientElement":
        return new SVGGradientElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLineElement":
        return new SVGLineElementWrappingImplementation._wrap(raw);
      case "SVGLinearGradientElement":
        return new SVGLinearGradientElementWrappingImplementation._wrap(raw);
      case "SVGMPathElement":
        return new SVGMPathElementWrappingImplementation._wrap(raw);
      case "SVGMarkerElement":
        return new SVGMarkerElementWrappingImplementation._wrap(raw);
      case "SVGMaskElement":
        return new SVGMaskElementWrappingImplementation._wrap(raw);
      case "SVGPathElement":
        return new SVGPathElementWrappingImplementation._wrap(raw);
      case "SVGPatternElement":
        return new SVGPatternElementWrappingImplementation._wrap(raw);
      case "SVGPolygonElement":
        return new SVGPolygonElementWrappingImplementation._wrap(raw);
      case "SVGPolylineElement":
        return new SVGPolylineElementWrappingImplementation._wrap(raw);
      case "SVGRadialGradientElement":
        return new SVGRadialGradientElementWrappingImplementation._wrap(raw);
      case "SVGRectElement":
        return new SVGRectElementWrappingImplementation._wrap(raw);
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGScriptElement":
        return new SVGScriptElementWrappingImplementation._wrap(raw);
      case "SVGSetElement":
        return new SVGSetElementWrappingImplementation._wrap(raw);
      case "SVGSwitchElement":
        return new SVGSwitchElementWrappingImplementation._wrap(raw);
      case "SVGSymbolElement":
        return new SVGSymbolElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTSpanElement":
        return new SVGTSpanElementWrappingImplementation._wrap(raw);
      case "SVGTextContentElement":
        return new SVGTextContentElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTextPathElement":
        return new SVGTextPathElementWrappingImplementation._wrap(raw);
      case "SVGTextPositioningElement":
        return new SVGTextPositioningElementWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      case "SVGViewElement":
        return new SVGViewElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGFEBlendElement wrapSVGFEBlendElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEBlendElementWrappingImplementation._wrap(raw);
  }

  static SVGFEColorMatrixElement wrapSVGFEColorMatrixElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEColorMatrixElementWrappingImplementation._wrap(raw);
  }

  static SVGFEComponentTransferElement wrapSVGFEComponentTransferElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEComponentTransferElementWrappingImplementation._wrap(raw);
  }

  static SVGFEConvolveMatrixElement wrapSVGFEConvolveMatrixElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEConvolveMatrixElementWrappingImplementation._wrap(raw);
  }

  static SVGFEDiffuseLightingElement wrapSVGFEDiffuseLightingElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEDiffuseLightingElementWrappingImplementation._wrap(raw);
  }

  static SVGFEDisplacementMapElement wrapSVGFEDisplacementMapElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEDisplacementMapElementWrappingImplementation._wrap(raw);
  }

  static SVGFEDistantLightElement wrapSVGFEDistantLightElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEDistantLightElementWrappingImplementation._wrap(raw);
  }

  static SVGFEDropShadowElement wrapSVGFEDropShadowElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEDropShadowElementWrappingImplementation._wrap(raw);
  }

  static SVGFEFloodElement wrapSVGFEFloodElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEFloodElementWrappingImplementation._wrap(raw);
  }

  static SVGFEFuncAElement wrapSVGFEFuncAElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEFuncAElementWrappingImplementation._wrap(raw);
  }

  static SVGFEFuncBElement wrapSVGFEFuncBElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEFuncBElementWrappingImplementation._wrap(raw);
  }

  static SVGFEFuncGElement wrapSVGFEFuncGElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEFuncGElementWrappingImplementation._wrap(raw);
  }

  static SVGFEFuncRElement wrapSVGFEFuncRElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEFuncRElementWrappingImplementation._wrap(raw);
  }

  static SVGFEGaussianBlurElement wrapSVGFEGaussianBlurElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEGaussianBlurElementWrappingImplementation._wrap(raw);
  }

  static SVGFEImageElement wrapSVGFEImageElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEImageElementWrappingImplementation._wrap(raw);
  }

  static SVGFEMergeElement wrapSVGFEMergeElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEMergeElementWrappingImplementation._wrap(raw);
  }

  static SVGFEMergeNodeElement wrapSVGFEMergeNodeElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEMergeNodeElementWrappingImplementation._wrap(raw);
  }

  static SVGFEOffsetElement wrapSVGFEOffsetElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEOffsetElementWrappingImplementation._wrap(raw);
  }

  static SVGFEPointLightElement wrapSVGFEPointLightElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFEPointLightElementWrappingImplementation._wrap(raw);
  }

  static SVGFESpecularLightingElement wrapSVGFESpecularLightingElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFESpecularLightingElementWrappingImplementation._wrap(raw);
  }

  static SVGFESpotLightElement wrapSVGFESpotLightElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFESpotLightElementWrappingImplementation._wrap(raw);
  }

  static SVGFETileElement wrapSVGFETileElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFETileElementWrappingImplementation._wrap(raw);
  }

  static SVGFETurbulenceElement wrapSVGFETurbulenceElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFETurbulenceElementWrappingImplementation._wrap(raw);
  }

  static SVGFilterElement wrapSVGFilterElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFilterElementWrappingImplementation._wrap(raw);
  }

  static SVGFilterPrimitiveStandardAttributes wrapSVGFilterPrimitiveStandardAttributes(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGFEBlendElement":
        return new SVGFEBlendElementWrappingImplementation._wrap(raw);
      case "SVGFEColorMatrixElement":
        return new SVGFEColorMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEComponentTransferElement":
        return new SVGFEComponentTransferElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFECompositeElement*/
      case "SVGFEConvolveMatrixElement":
        return new SVGFEConvolveMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEDiffuseLightingElement":
        return new SVGFEDiffuseLightingElementWrappingImplementation._wrap(raw);
      case "SVGFEDisplacementMapElement":
        return new SVGFEDisplacementMapElementWrappingImplementation._wrap(raw);
      case "SVGFEDropShadowElement":
        return new SVGFEDropShadowElementWrappingImplementation._wrap(raw);
      case "SVGFEFloodElement":
        return new SVGFEFloodElementWrappingImplementation._wrap(raw);
      case "SVGFEGaussianBlurElement":
        return new SVGFEGaussianBlurElementWrappingImplementation._wrap(raw);
      case "SVGFEImageElement":
        return new SVGFEImageElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeElement":
        return new SVGFEMergeElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFEMorphologyElement*/
      case "SVGFEOffsetElement":
        return new SVGFEOffsetElementWrappingImplementation._wrap(raw);
      case "SVGFESpecularLightingElement":
        return new SVGFESpecularLightingElementWrappingImplementation._wrap(raw);
      case "SVGFETileElement":
        return new SVGFETileElementWrappingImplementation._wrap(raw);
      case "SVGFETurbulenceElement":
        return new SVGFETurbulenceElementWrappingImplementation._wrap(raw);
      case "SVGFilterPrimitiveStandardAttributes":
        return new SVGFilterPrimitiveStandardAttributesWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGFitToViewBox wrapSVGFitToViewBox(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGFitToViewBox":
        return new SVGFitToViewBoxWrappingImplementation._wrap(raw);
      case "SVGMarkerElement":
        return new SVGMarkerElementWrappingImplementation._wrap(raw);
      case "SVGPatternElement":
        return new SVGPatternElementWrappingImplementation._wrap(raw);
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGSymbolElement":
        return new SVGSymbolElementWrappingImplementation._wrap(raw);
      case "SVGViewElement":
        return new SVGViewElementWrappingImplementation._wrap(raw);
      case "SVGViewSpec":
        return new SVGViewSpecWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGFontElement wrapSVGFontElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFontElementWrappingImplementation._wrap(raw);
  }

  static SVGFontFaceElement wrapSVGFontFaceElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFontFaceElementWrappingImplementation._wrap(raw);
  }

  static SVGFontFaceFormatElement wrapSVGFontFaceFormatElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFontFaceFormatElementWrappingImplementation._wrap(raw);
  }

  static SVGFontFaceNameElement wrapSVGFontFaceNameElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFontFaceNameElementWrappingImplementation._wrap(raw);
  }

  static SVGFontFaceSrcElement wrapSVGFontFaceSrcElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFontFaceSrcElementWrappingImplementation._wrap(raw);
  }

  static SVGFontFaceUriElement wrapSVGFontFaceUriElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGFontFaceUriElementWrappingImplementation._wrap(raw);
  }

  static SVGForeignObjectElement wrapSVGForeignObjectElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGForeignObjectElementWrappingImplementation._wrap(raw);
  }

  static SVGGElement wrapSVGGElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGGElementWrappingImplementation._wrap(raw);
  }

  static SVGGlyphElement wrapSVGGlyphElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGGlyphElementWrappingImplementation._wrap(raw);
  }

  static SVGGlyphRefElement wrapSVGGlyphRefElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGGlyphRefElementWrappingImplementation._wrap(raw);
  }

  static SVGGradientElement wrapSVGGradientElement(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGGradientElement":
        return new SVGGradientElementWrappingImplementation._wrap(raw);
      case "SVGLinearGradientElement":
        return new SVGLinearGradientElementWrappingImplementation._wrap(raw);
      case "SVGRadialGradientElement":
        return new SVGRadialGradientElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGHKernElement wrapSVGHKernElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGHKernElementWrappingImplementation._wrap(raw);
  }

  static SVGImageElement wrapSVGImageElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGImageElementWrappingImplementation._wrap(raw);
  }

  static SVGLangSpace wrapSVGLangSpace(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGCircleElement":
        return new SVGCircleElementWrappingImplementation._wrap(raw);
      case "SVGClipPathElement":
        return new SVGClipPathElementWrappingImplementation._wrap(raw);
      case "SVGDefsElement":
        return new SVGDefsElementWrappingImplementation._wrap(raw);
      case "SVGDescElement":
        return new SVGDescElementWrappingImplementation._wrap(raw);
      case "SVGEllipseElement":
        return new SVGEllipseElementWrappingImplementation._wrap(raw);
      case "SVGFEImageElement":
        return new SVGFEImageElementWrappingImplementation._wrap(raw);
      case "SVGFilterElement":
        return new SVGFilterElementWrappingImplementation._wrap(raw);
      case "SVGForeignObjectElement":
        return new SVGForeignObjectElementWrappingImplementation._wrap(raw);
      case "SVGGElement":
        return new SVGGElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLangSpace":
        return new SVGLangSpaceWrappingImplementation._wrap(raw);
      case "SVGLineElement":
        return new SVGLineElementWrappingImplementation._wrap(raw);
      case "SVGMarkerElement":
        return new SVGMarkerElementWrappingImplementation._wrap(raw);
      case "SVGMaskElement":
        return new SVGMaskElementWrappingImplementation._wrap(raw);
      case "SVGPathElement":
        return new SVGPathElementWrappingImplementation._wrap(raw);
      case "SVGPatternElement":
        return new SVGPatternElementWrappingImplementation._wrap(raw);
      case "SVGPolygonElement":
        return new SVGPolygonElementWrappingImplementation._wrap(raw);
      case "SVGPolylineElement":
        return new SVGPolylineElementWrappingImplementation._wrap(raw);
      case "SVGRectElement":
        return new SVGRectElementWrappingImplementation._wrap(raw);
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGStyleElement":
        return new SVGStyleElementWrappingImplementation._wrap(raw);
      case "SVGSwitchElement":
        return new SVGSwitchElementWrappingImplementation._wrap(raw);
      case "SVGSymbolElement":
        return new SVGSymbolElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTSpanElement":
        return new SVGTSpanElementWrappingImplementation._wrap(raw);
      case "SVGTextContentElement":
        return new SVGTextContentElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTextPathElement":
        return new SVGTextPathElementWrappingImplementation._wrap(raw);
      case "SVGTextPositioningElement":
        return new SVGTextPositioningElementWrappingImplementation._wrap(raw);
      case "SVGTitleElement":
        return new SVGTitleElementWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGLength wrapSVGLength(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGLengthWrappingImplementation._wrap(raw);
  }

  static SVGLengthList wrapSVGLengthList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGLengthListWrappingImplementation._wrap(raw);
  }

  static SVGLineElement wrapSVGLineElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGLineElementWrappingImplementation._wrap(raw);
  }

  static SVGLinearGradientElement wrapSVGLinearGradientElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGLinearGradientElementWrappingImplementation._wrap(raw);
  }

  static SVGLocatable wrapSVGLocatable(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGCircleElement":
        return new SVGCircleElementWrappingImplementation._wrap(raw);
      case "SVGClipPathElement":
        return new SVGClipPathElementWrappingImplementation._wrap(raw);
      case "SVGDefsElement":
        return new SVGDefsElementWrappingImplementation._wrap(raw);
      case "SVGEllipseElement":
        return new SVGEllipseElementWrappingImplementation._wrap(raw);
      case "SVGForeignObjectElement":
        return new SVGForeignObjectElementWrappingImplementation._wrap(raw);
      case "SVGGElement":
        return new SVGGElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLineElement":
        return new SVGLineElementWrappingImplementation._wrap(raw);
      case "SVGLocatable":
        return new SVGLocatableWrappingImplementation._wrap(raw);
      case "SVGPathElement":
        return new SVGPathElementWrappingImplementation._wrap(raw);
      case "SVGPolygonElement":
        return new SVGPolygonElementWrappingImplementation._wrap(raw);
      case "SVGPolylineElement":
        return new SVGPolylineElementWrappingImplementation._wrap(raw);
      case "SVGRectElement":
        return new SVGRectElementWrappingImplementation._wrap(raw);
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGSwitchElement":
        return new SVGSwitchElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTransformable":
        return new SVGTransformableWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGMPathElement wrapSVGMPathElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGMPathElementWrappingImplementation._wrap(raw);
  }

  static SVGMarkerElement wrapSVGMarkerElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGMarkerElementWrappingImplementation._wrap(raw);
  }

  static SVGMaskElement wrapSVGMaskElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGMaskElementWrappingImplementation._wrap(raw);
  }

  static SVGMatrix wrapSVGMatrix(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGMatrixWrappingImplementation._wrap(raw);
  }

  static SVGMetadataElement wrapSVGMetadataElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGMetadataElementWrappingImplementation._wrap(raw);
  }

  static SVGMissingGlyphElement wrapSVGMissingGlyphElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGMissingGlyphElementWrappingImplementation._wrap(raw);
  }

  static SVGNumber wrapSVGNumber(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGNumberWrappingImplementation._wrap(raw);
  }

  static SVGNumberList wrapSVGNumberList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGNumberListWrappingImplementation._wrap(raw);
  }

  static SVGPaint wrapSVGPaint(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPaintWrappingImplementation._wrap(raw);
  }

  static SVGPathElement wrapSVGPathElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathElementWrappingImplementation._wrap(raw);
  }

  static SVGPathSeg wrapSVGPathSeg(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGPathSeg":
        return new SVGPathSegWrappingImplementation._wrap(raw);
      case "SVGPathSegArcAbs":
        return new SVGPathSegArcAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegArcRel":
        return new SVGPathSegArcRelWrappingImplementation._wrap(raw);
      case "SVGPathSegClosePath":
        return new SVGPathSegClosePathWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoCubicAbs":
        return new SVGPathSegCurvetoCubicAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoCubicRel":
        return new SVGPathSegCurvetoCubicRelWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoCubicSmoothAbs":
        return new SVGPathSegCurvetoCubicSmoothAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoCubicSmoothRel":
        return new SVGPathSegCurvetoCubicSmoothRelWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoQuadraticAbs":
        return new SVGPathSegCurvetoQuadraticAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoQuadraticRel":
        return new SVGPathSegCurvetoQuadraticRelWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoQuadraticSmoothAbs":
        return new SVGPathSegCurvetoQuadraticSmoothAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoQuadraticSmoothRel":
        return new SVGPathSegCurvetoQuadraticSmoothRelWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoAbs":
        return new SVGPathSegLinetoAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoHorizontalAbs":
        return new SVGPathSegLinetoHorizontalAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoHorizontalRel":
        return new SVGPathSegLinetoHorizontalRelWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoRel":
        return new SVGPathSegLinetoRelWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoVerticalAbs":
        return new SVGPathSegLinetoVerticalAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoVerticalRel":
        return new SVGPathSegLinetoVerticalRelWrappingImplementation._wrap(raw);
      case "SVGPathSegMovetoAbs":
        return new SVGPathSegMovetoAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegMovetoRel":
        return new SVGPathSegMovetoRelWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGPathSegArcAbs wrapSVGPathSegArcAbs(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegArcAbsWrappingImplementation._wrap(raw);
  }

  static SVGPathSegArcRel wrapSVGPathSegArcRel(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegArcRelWrappingImplementation._wrap(raw);
  }

  static SVGPathSegClosePath wrapSVGPathSegClosePath(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegClosePathWrappingImplementation._wrap(raw);
  }

  static SVGPathSegCurvetoCubicAbs wrapSVGPathSegCurvetoCubicAbs(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegCurvetoCubicAbsWrappingImplementation._wrap(raw);
  }

  static SVGPathSegCurvetoCubicRel wrapSVGPathSegCurvetoCubicRel(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegCurvetoCubicRelWrappingImplementation._wrap(raw);
  }

  static SVGPathSegCurvetoCubicSmoothAbs wrapSVGPathSegCurvetoCubicSmoothAbs(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegCurvetoCubicSmoothAbsWrappingImplementation._wrap(raw);
  }

  static SVGPathSegCurvetoCubicSmoothRel wrapSVGPathSegCurvetoCubicSmoothRel(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegCurvetoCubicSmoothRelWrappingImplementation._wrap(raw);
  }

  static SVGPathSegCurvetoQuadraticAbs wrapSVGPathSegCurvetoQuadraticAbs(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegCurvetoQuadraticAbsWrappingImplementation._wrap(raw);
  }

  static SVGPathSegCurvetoQuadraticRel wrapSVGPathSegCurvetoQuadraticRel(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegCurvetoQuadraticRelWrappingImplementation._wrap(raw);
  }

  static SVGPathSegCurvetoQuadraticSmoothAbs wrapSVGPathSegCurvetoQuadraticSmoothAbs(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegCurvetoQuadraticSmoothAbsWrappingImplementation._wrap(raw);
  }

  static SVGPathSegCurvetoQuadraticSmoothRel wrapSVGPathSegCurvetoQuadraticSmoothRel(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegCurvetoQuadraticSmoothRelWrappingImplementation._wrap(raw);
  }

  static SVGPathSegLinetoAbs wrapSVGPathSegLinetoAbs(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegLinetoAbsWrappingImplementation._wrap(raw);
  }

  static SVGPathSegLinetoHorizontalAbs wrapSVGPathSegLinetoHorizontalAbs(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegLinetoHorizontalAbsWrappingImplementation._wrap(raw);
  }

  static SVGPathSegLinetoHorizontalRel wrapSVGPathSegLinetoHorizontalRel(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegLinetoHorizontalRelWrappingImplementation._wrap(raw);
  }

  static SVGPathSegLinetoRel wrapSVGPathSegLinetoRel(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegLinetoRelWrappingImplementation._wrap(raw);
  }

  static SVGPathSegLinetoVerticalAbs wrapSVGPathSegLinetoVerticalAbs(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegLinetoVerticalAbsWrappingImplementation._wrap(raw);
  }

  static SVGPathSegLinetoVerticalRel wrapSVGPathSegLinetoVerticalRel(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegLinetoVerticalRelWrappingImplementation._wrap(raw);
  }

  static SVGPathSegList wrapSVGPathSegList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegListWrappingImplementation._wrap(raw);
  }

  static SVGPathSegMovetoAbs wrapSVGPathSegMovetoAbs(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegMovetoAbsWrappingImplementation._wrap(raw);
  }

  static SVGPathSegMovetoRel wrapSVGPathSegMovetoRel(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPathSegMovetoRelWrappingImplementation._wrap(raw);
  }

  static SVGPatternElement wrapSVGPatternElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPatternElementWrappingImplementation._wrap(raw);
  }

  static SVGPoint wrapSVGPoint(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPointWrappingImplementation._wrap(raw);
  }

  static SVGPointList wrapSVGPointList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPointListWrappingImplementation._wrap(raw);
  }

  static SVGPolygonElement wrapSVGPolygonElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPolygonElementWrappingImplementation._wrap(raw);
  }

  static SVGPolylineElement wrapSVGPolylineElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPolylineElementWrappingImplementation._wrap(raw);
  }

  static SVGPreserveAspectRatio wrapSVGPreserveAspectRatio(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGPreserveAspectRatioWrappingImplementation._wrap(raw);
  }

  static SVGRadialGradientElement wrapSVGRadialGradientElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGRadialGradientElementWrappingImplementation._wrap(raw);
  }

  static SVGRect wrapSVGRect(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGRectWrappingImplementation._wrap(raw);
  }

  static SVGRectElement wrapSVGRectElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGRectElementWrappingImplementation._wrap(raw);
  }

  static SVGRenderingIntent wrapSVGRenderingIntent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGRenderingIntentWrappingImplementation._wrap(raw);
  }

  static SVGSVGElement wrapSVGSVGElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGSVGElementWrappingImplementation._wrap(raw);
  }

  static SVGScriptElement wrapSVGScriptElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGScriptElementWrappingImplementation._wrap(raw);
  }

  static SVGSetElement wrapSVGSetElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGSetElementWrappingImplementation._wrap(raw);
  }

  static SVGStopElement wrapSVGStopElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGStopElementWrappingImplementation._wrap(raw);
  }

  static SVGStringList wrapSVGStringList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGStringListWrappingImplementation._wrap(raw);
  }

  static SVGStylable wrapSVGStylable(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGCircleElement":
        return new SVGCircleElementWrappingImplementation._wrap(raw);
      case "SVGClipPathElement":
        return new SVGClipPathElementWrappingImplementation._wrap(raw);
      case "SVGDefsElement":
        return new SVGDefsElementWrappingImplementation._wrap(raw);
      case "SVGDescElement":
        return new SVGDescElementWrappingImplementation._wrap(raw);
      case "SVGEllipseElement":
        return new SVGEllipseElementWrappingImplementation._wrap(raw);
      case "SVGFEBlendElement":
        return new SVGFEBlendElementWrappingImplementation._wrap(raw);
      case "SVGFEColorMatrixElement":
        return new SVGFEColorMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEComponentTransferElement":
        return new SVGFEComponentTransferElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFECompositeElement*/
      case "SVGFEConvolveMatrixElement":
        return new SVGFEConvolveMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEDiffuseLightingElement":
        return new SVGFEDiffuseLightingElementWrappingImplementation._wrap(raw);
      case "SVGFEDisplacementMapElement":
        return new SVGFEDisplacementMapElementWrappingImplementation._wrap(raw);
      case "SVGFEDropShadowElement":
        return new SVGFEDropShadowElementWrappingImplementation._wrap(raw);
      case "SVGFEFloodElement":
        return new SVGFEFloodElementWrappingImplementation._wrap(raw);
      case "SVGFEGaussianBlurElement":
        return new SVGFEGaussianBlurElementWrappingImplementation._wrap(raw);
      case "SVGFEImageElement":
        return new SVGFEImageElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeElement":
        return new SVGFEMergeElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFEMorphologyElement*/
      case "SVGFEOffsetElement":
        return new SVGFEOffsetElementWrappingImplementation._wrap(raw);
      case "SVGFESpecularLightingElement":
        return new SVGFESpecularLightingElementWrappingImplementation._wrap(raw);
      case "SVGFETileElement":
        return new SVGFETileElementWrappingImplementation._wrap(raw);
      case "SVGFETurbulenceElement":
        return new SVGFETurbulenceElementWrappingImplementation._wrap(raw);
      case "SVGFilterElement":
        return new SVGFilterElementWrappingImplementation._wrap(raw);
      case "SVGFilterPrimitiveStandardAttributes":
        return new SVGFilterPrimitiveStandardAttributesWrappingImplementation._wrap(raw);
      case "SVGForeignObjectElement":
        return new SVGForeignObjectElementWrappingImplementation._wrap(raw);
      case "SVGGElement":
        return new SVGGElementWrappingImplementation._wrap(raw);
      case "SVGGlyphRefElement":
        return new SVGGlyphRefElementWrappingImplementation._wrap(raw);
      case "SVGGradientElement":
        return new SVGGradientElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLineElement":
        return new SVGLineElementWrappingImplementation._wrap(raw);
      case "SVGLinearGradientElement":
        return new SVGLinearGradientElementWrappingImplementation._wrap(raw);
      case "SVGMarkerElement":
        return new SVGMarkerElementWrappingImplementation._wrap(raw);
      case "SVGMaskElement":
        return new SVGMaskElementWrappingImplementation._wrap(raw);
      case "SVGPathElement":
        return new SVGPathElementWrappingImplementation._wrap(raw);
      case "SVGPatternElement":
        return new SVGPatternElementWrappingImplementation._wrap(raw);
      case "SVGPolygonElement":
        return new SVGPolygonElementWrappingImplementation._wrap(raw);
      case "SVGPolylineElement":
        return new SVGPolylineElementWrappingImplementation._wrap(raw);
      case "SVGRadialGradientElement":
        return new SVGRadialGradientElementWrappingImplementation._wrap(raw);
      case "SVGRectElement":
        return new SVGRectElementWrappingImplementation._wrap(raw);
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGStopElement":
        return new SVGStopElementWrappingImplementation._wrap(raw);
      case "SVGStylable":
        return new SVGStylableWrappingImplementation._wrap(raw);
      case "SVGSwitchElement":
        return new SVGSwitchElementWrappingImplementation._wrap(raw);
      case "SVGSymbolElement":
        return new SVGSymbolElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTSpanElement":
        return new SVGTSpanElementWrappingImplementation._wrap(raw);
      case "SVGTextContentElement":
        return new SVGTextContentElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTextPathElement":
        return new SVGTextPathElementWrappingImplementation._wrap(raw);
      case "SVGTextPositioningElement":
        return new SVGTextPositioningElementWrappingImplementation._wrap(raw);
      case "SVGTitleElement":
        return new SVGTitleElementWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGStyleElement wrapSVGStyleElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGStyleElementWrappingImplementation._wrap(raw);
  }

  static SVGSwitchElement wrapSVGSwitchElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGSwitchElementWrappingImplementation._wrap(raw);
  }

  static SVGSymbolElement wrapSVGSymbolElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGSymbolElementWrappingImplementation._wrap(raw);
  }

  static SVGTRefElement wrapSVGTRefElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGTRefElementWrappingImplementation._wrap(raw);
  }

  static SVGTSpanElement wrapSVGTSpanElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGTSpanElementWrappingImplementation._wrap(raw);
  }

  static SVGTests wrapSVGTests(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGAnimateColorElement":
        return new SVGAnimateColorElementWrappingImplementation._wrap(raw);
      case "SVGAnimateElement":
        return new SVGAnimateElementWrappingImplementation._wrap(raw);
      case "SVGAnimateMotionElement":
        return new SVGAnimateMotionElementWrappingImplementation._wrap(raw);
      case "SVGAnimateTransformElement":
        return new SVGAnimateTransformElementWrappingImplementation._wrap(raw);
      case "SVGAnimationElement":
        return new SVGAnimationElementWrappingImplementation._wrap(raw);
      case "SVGCircleElement":
        return new SVGCircleElementWrappingImplementation._wrap(raw);
      case "SVGClipPathElement":
        return new SVGClipPathElementWrappingImplementation._wrap(raw);
      case "SVGCursorElement":
        return new SVGCursorElementWrappingImplementation._wrap(raw);
      case "SVGDefsElement":
        return new SVGDefsElementWrappingImplementation._wrap(raw);
      case "SVGEllipseElement":
        return new SVGEllipseElementWrappingImplementation._wrap(raw);
      case "SVGForeignObjectElement":
        return new SVGForeignObjectElementWrappingImplementation._wrap(raw);
      case "SVGGElement":
        return new SVGGElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLineElement":
        return new SVGLineElementWrappingImplementation._wrap(raw);
      case "SVGMaskElement":
        return new SVGMaskElementWrappingImplementation._wrap(raw);
      case "SVGPathElement":
        return new SVGPathElementWrappingImplementation._wrap(raw);
      case "SVGPatternElement":
        return new SVGPatternElementWrappingImplementation._wrap(raw);
      case "SVGPolygonElement":
        return new SVGPolygonElementWrappingImplementation._wrap(raw);
      case "SVGPolylineElement":
        return new SVGPolylineElementWrappingImplementation._wrap(raw);
      case "SVGRectElement":
        return new SVGRectElementWrappingImplementation._wrap(raw);
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGSetElement":
        return new SVGSetElementWrappingImplementation._wrap(raw);
      case "SVGSwitchElement":
        return new SVGSwitchElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTSpanElement":
        return new SVGTSpanElementWrappingImplementation._wrap(raw);
      case "SVGTests":
        return new SVGTestsWrappingImplementation._wrap(raw);
      case "SVGTextContentElement":
        return new SVGTextContentElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTextPathElement":
        return new SVGTextPathElementWrappingImplementation._wrap(raw);
      case "SVGTextPositioningElement":
        return new SVGTextPositioningElementWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGTextContentElement wrapSVGTextContentElement(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTSpanElement":
        return new SVGTSpanElementWrappingImplementation._wrap(raw);
      case "SVGTextContentElement":
        return new SVGTextContentElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTextPathElement":
        return new SVGTextPathElementWrappingImplementation._wrap(raw);
      case "SVGTextPositioningElement":
        return new SVGTextPositioningElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGTextElement wrapSVGTextElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGTextElementWrappingImplementation._wrap(raw);
  }

  static SVGTextPathElement wrapSVGTextPathElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGTextPathElementWrappingImplementation._wrap(raw);
  }

  static SVGTextPositioningElement wrapSVGTextPositioningElement(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTSpanElement":
        return new SVGTSpanElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTextPositioningElement":
        return new SVGTextPositioningElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGTitleElement wrapSVGTitleElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGTitleElementWrappingImplementation._wrap(raw);
  }

  static SVGTransform wrapSVGTransform(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGTransformWrappingImplementation._wrap(raw);
  }

  static SVGTransformList wrapSVGTransformList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGTransformListWrappingImplementation._wrap(raw);
  }

  static SVGTransformable wrapSVGTransformable(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGCircleElement":
        return new SVGCircleElementWrappingImplementation._wrap(raw);
      case "SVGClipPathElement":
        return new SVGClipPathElementWrappingImplementation._wrap(raw);
      case "SVGDefsElement":
        return new SVGDefsElementWrappingImplementation._wrap(raw);
      case "SVGEllipseElement":
        return new SVGEllipseElementWrappingImplementation._wrap(raw);
      case "SVGForeignObjectElement":
        return new SVGForeignObjectElementWrappingImplementation._wrap(raw);
      case "SVGGElement":
        return new SVGGElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLineElement":
        return new SVGLineElementWrappingImplementation._wrap(raw);
      case "SVGPathElement":
        return new SVGPathElementWrappingImplementation._wrap(raw);
      case "SVGPolygonElement":
        return new SVGPolygonElementWrappingImplementation._wrap(raw);
      case "SVGPolylineElement":
        return new SVGPolylineElementWrappingImplementation._wrap(raw);
      case "SVGRectElement":
        return new SVGRectElementWrappingImplementation._wrap(raw);
      case "SVGSwitchElement":
        return new SVGSwitchElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTransformable":
        return new SVGTransformableWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGURIReference wrapSVGURIReference(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGCursorElement":
        return new SVGCursorElementWrappingImplementation._wrap(raw);
      case "SVGFEImageElement":
        return new SVGFEImageElementWrappingImplementation._wrap(raw);
      case "SVGFilterElement":
        return new SVGFilterElementWrappingImplementation._wrap(raw);
      case "SVGGlyphRefElement":
        return new SVGGlyphRefElementWrappingImplementation._wrap(raw);
      case "SVGGradientElement":
        return new SVGGradientElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLinearGradientElement":
        return new SVGLinearGradientElementWrappingImplementation._wrap(raw);
      case "SVGMPathElement":
        return new SVGMPathElementWrappingImplementation._wrap(raw);
      case "SVGPatternElement":
        return new SVGPatternElementWrappingImplementation._wrap(raw);
      case "SVGRadialGradientElement":
        return new SVGRadialGradientElementWrappingImplementation._wrap(raw);
      case "SVGScriptElement":
        return new SVGScriptElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTextPathElement":
        return new SVGTextPathElementWrappingImplementation._wrap(raw);
      case "SVGURIReference":
        return new SVGURIReferenceWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGUnitTypes wrapSVGUnitTypes(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGUnitTypesWrappingImplementation._wrap(raw);
  }

  static SVGUseElement wrapSVGUseElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGUseElementWrappingImplementation._wrap(raw);
  }

  static SVGVKernElement wrapSVGVKernElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGVKernElementWrappingImplementation._wrap(raw);
  }

  static SVGViewElement wrapSVGViewElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGViewElementWrappingImplementation._wrap(raw);
  }

  static SVGViewSpec wrapSVGViewSpec(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGViewSpecWrappingImplementation._wrap(raw);
  }

  static SVGZoomAndPan wrapSVGZoomAndPan(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGViewElement":
        return new SVGViewElementWrappingImplementation._wrap(raw);
      case "SVGViewSpec":
        return new SVGViewSpecWrappingImplementation._wrap(raw);
      case "SVGZoomAndPan":
        return new SVGZoomAndPanWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static SVGZoomEvent wrapSVGZoomEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SVGZoomEventWrappingImplementation._wrap(raw);
  }

  static Screen wrapScreen(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ScreenWrappingImplementation._wrap(raw);
  }

  static ScriptElement wrapScriptElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ScriptElementWrappingImplementation._wrap(raw);
  }

  static SelectElement wrapSelectElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SelectElementWrappingImplementation._wrap(raw);
  }

  static SharedWorker wrapSharedWorker(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SharedWorkerWrappingImplementation._wrap(raw);
  }

  static SourceElement wrapSourceElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SourceElementWrappingImplementation._wrap(raw);
  }

  static SpanElement wrapSpanElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SpanElementWrappingImplementation._wrap(raw);
  }

  static SpeechInputEvent wrapSpeechInputEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SpeechInputEventWrappingImplementation._wrap(raw);
  }

  static SpeechInputResult wrapSpeechInputResult(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SpeechInputResultWrappingImplementation._wrap(raw);
  }

  static SpeechInputResultList wrapSpeechInputResultList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new SpeechInputResultListWrappingImplementation._wrap(raw);
  }

  static Storage wrapStorage(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new StorageWrappingImplementation._wrap(raw);
  }

  static StorageEvent wrapStorageEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new StorageEventWrappingImplementation._wrap(raw);
  }

  static StorageInfo wrapStorageInfo(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new StorageInfoWrappingImplementation._wrap(raw);
  }

  // Skipped StorageInfoErrorCallback
  // Skipped StorageInfoQuotaCallback
  // Skipped StorageInfoUsageCallback
  // Skipped StringCallback
  static StyleElement wrapStyleElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new StyleElementWrappingImplementation._wrap(raw);
  }

  static StyleMedia wrapStyleMedia(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new StyleMediaWrappingImplementation._wrap(raw);
  }

  static StyleSheet wrapStyleSheet(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "CSSStyleSheet":
        return new CSSStyleSheetWrappingImplementation._wrap(raw);
      case "StyleSheet":
        return new StyleSheetWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static StyleSheetList wrapStyleSheetList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new StyleSheetListWrappingImplementation._wrap(raw);
  }

  static TableCaptionElement wrapTableCaptionElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TableCaptionElementWrappingImplementation._wrap(raw);
  }

  static TableCellElement wrapTableCellElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TableCellElementWrappingImplementation._wrap(raw);
  }

  static TableColElement wrapTableColElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TableColElementWrappingImplementation._wrap(raw);
  }

  static TableElement wrapTableElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TableElementWrappingImplementation._wrap(raw);
  }

  static TableRowElement wrapTableRowElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TableRowElementWrappingImplementation._wrap(raw);
  }

  static TableSectionElement wrapTableSectionElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TableSectionElementWrappingImplementation._wrap(raw);
  }

  static Text wrapText(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "CDATASection":
        return new CDATASectionWrappingImplementation._wrap(raw);
      case "Text":
        return new TextWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static TextAreaElement wrapTextAreaElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TextAreaElementWrappingImplementation._wrap(raw);
  }

  static TextEvent wrapTextEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TextEventWrappingImplementation._wrap(raw);
  }

  static TextMetrics wrapTextMetrics(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TextMetricsWrappingImplementation._wrap(raw);
  }

  static TextTrack wrapTextTrack(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TextTrackWrappingImplementation._wrap(raw);
  }

  static TextTrackCue wrapTextTrackCue(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TextTrackCueWrappingImplementation._wrap(raw);
  }

  static TextTrackCueList wrapTextTrackCueList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TextTrackCueListWrappingImplementation._wrap(raw);
  }

  static TimeRanges wrapTimeRanges(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TimeRangesWrappingImplementation._wrap(raw);
  }

  static TitleElement wrapTitleElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TitleElementWrappingImplementation._wrap(raw);
  }

  static Touch wrapTouch(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TouchWrappingImplementation._wrap(raw);
  }

  static TouchEvent wrapTouchEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TouchEventWrappingImplementation._wrap(raw);
  }

  static TouchList wrapTouchList(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TouchListWrappingImplementation._wrap(raw);
  }

  static TrackElement wrapTrackElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TrackElementWrappingImplementation._wrap(raw);
  }

  static TransitionEvent wrapTransitionEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new TransitionEventWrappingImplementation._wrap(raw);
  }

  static UIEvent wrapUIEvent(raw) {
    if (raw === null) { return null; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      case "CompositionEvent":
        return new CompositionEventWrappingImplementation._wrap(raw);
      case "KeyboardEvent":
        return new KeyboardEventWrappingImplementation._wrap(raw);
      case "MouseEvent":
        return new MouseEventWrappingImplementation._wrap(raw);
      case "SVGZoomEvent":
        return new SVGZoomEventWrappingImplementation._wrap(raw);
      case "TextEvent":
        return new TextEventWrappingImplementation._wrap(raw);
      case "TouchEvent":
        return new TouchEventWrappingImplementation._wrap(raw);
      case "UIEvent":
        return new UIEventWrappingImplementation._wrap(raw);
      case "WheelEvent":
        return new WheelEventWrappingImplementation._wrap(raw);
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static UListElement wrapUListElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new UListElementWrappingImplementation._wrap(raw);
  }

  static Uint16Array wrapUint16Array(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new Uint16ArrayWrappingImplementation._wrap(raw);
  }

  static Uint32Array wrapUint32Array(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new Uint32ArrayWrappingImplementation._wrap(raw);
  }

  static Uint8Array wrapUint8Array(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new Uint8ArrayWrappingImplementation._wrap(raw);
  }

  static UnknownElement wrapUnknownElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new UnknownElementWrappingImplementation._wrap(raw);
  }

  static ValidityState wrapValidityState(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new ValidityStateWrappingImplementation._wrap(raw);
  }

  static VideoElement wrapVideoElement(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new VideoElementWrappingImplementation._wrap(raw);
  }

  static VoidCallback wrapVoidCallback(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new VoidCallbackWrappingImplementation._wrap(raw);
  }

  static WaveShaperNode wrapWaveShaperNode(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WaveShaperNodeWrappingImplementation._wrap(raw);
  }

  static WebGLActiveInfo wrapWebGLActiveInfo(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLActiveInfoWrappingImplementation._wrap(raw);
  }

  static WebGLBuffer wrapWebGLBuffer(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLBufferWrappingImplementation._wrap(raw);
  }

  static WebGLContextAttributes wrapWebGLContextAttributes(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLContextAttributesWrappingImplementation._wrap(raw);
  }

  static WebGLContextEvent wrapWebGLContextEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLContextEventWrappingImplementation._wrap(raw);
  }

  static WebGLDebugRendererInfo wrapWebGLDebugRendererInfo(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLDebugRendererInfoWrappingImplementation._wrap(raw);
  }

  static WebGLDebugShaders wrapWebGLDebugShaders(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLDebugShadersWrappingImplementation._wrap(raw);
  }

  static WebGLFramebuffer wrapWebGLFramebuffer(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLFramebufferWrappingImplementation._wrap(raw);
  }

  static WebGLProgram wrapWebGLProgram(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLProgramWrappingImplementation._wrap(raw);
  }

  static WebGLRenderbuffer wrapWebGLRenderbuffer(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLRenderbufferWrappingImplementation._wrap(raw);
  }

  static WebGLRenderingContext wrapWebGLRenderingContext(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLRenderingContextWrappingImplementation._wrap(raw);
  }

  static WebGLShader wrapWebGLShader(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLShaderWrappingImplementation._wrap(raw);
  }

  static WebGLTexture wrapWebGLTexture(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLTextureWrappingImplementation._wrap(raw);
  }

  static WebGLUniformLocation wrapWebGLUniformLocation(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLUniformLocationWrappingImplementation._wrap(raw);
  }

  static WebGLVertexArrayObjectOES wrapWebGLVertexArrayObjectOES(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebGLVertexArrayObjectOESWrappingImplementation._wrap(raw);
  }

  static WebKitCSSFilterValue wrapWebKitCSSFilterValue(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebKitCSSFilterValueWrappingImplementation._wrap(raw);
  }

  static WebKitMutationObserver wrapWebKitMutationObserver(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebKitMutationObserverWrappingImplementation._wrap(raw);
  }

  static WebSocket wrapWebSocket(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WebSocketWrappingImplementation._wrap(raw);
  }

  static WheelEvent wrapWheelEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WheelEventWrappingImplementation._wrap(raw);
  }

  static Window wrapWindow(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WindowWrappingImplementation._wrap(raw);
  }

  static Worker wrapWorker(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new WorkerWrappingImplementation._wrap(raw);
  }

  static XMLHttpRequest wrapXMLHttpRequest(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new XMLHttpRequestWrappingImplementation._wrap(raw);
  }

  static XMLHttpRequestException wrapXMLHttpRequestException(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new XMLHttpRequestExceptionWrappingImplementation._wrap(raw);
  }

  static XMLHttpRequestProgressEvent wrapXMLHttpRequestProgressEvent(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new XMLHttpRequestProgressEventWrappingImplementation._wrap(raw);
  }

  static XMLHttpRequestUpload wrapXMLHttpRequestUpload(raw) {
    return raw === null ? null : raw.dartObjectLocalStorage !== null ? raw.dartObjectLocalStorage : new XMLHttpRequestUploadWrappingImplementation._wrap(raw);
  }

  static Object wrapObject(raw) {
    if (raw === null || raw is String || raw is num || raw is Date) { return raw; }
    if (raw.dartObjectLocalStorage !== null) {
      return raw.dartObjectLocalStorage;
    }
    switch (raw.typeName) {
      /* Skipping AbstractWorker*/
      case "HTMLAnchorElement":
        return new AnchorElementWrappingImplementation._wrap(raw);
      case "WebKitAnimation":
        return new AnimationWrappingImplementation._wrap(raw);
      case "WebKitAnimationEvent":
        return new AnimationEventWrappingImplementation._wrap(raw);
      case "WebKitAnimationList":
        return new AnimationListWrappingImplementation._wrap(raw);
      /* Skipping HTMLAppletElement*/
      case "HTMLAreaElement":
        return new AreaElementWrappingImplementation._wrap(raw);
      case "ArrayBuffer":
        return new ArrayBufferWrappingImplementation._wrap(raw);
      case "ArrayBufferView":
        return new ArrayBufferViewWrappingImplementation._wrap(raw);
      /* Skipping Attr*/
      case "AudioBuffer":
        return new AudioBufferWrappingImplementation._wrap(raw);
      /* Skipping AudioBufferCallback*/
      case "AudioBufferSourceNode":
        return new AudioBufferSourceNodeWrappingImplementation._wrap(raw);
      case "AudioChannelMerger":
        return new AudioChannelMergerWrappingImplementation._wrap(raw);
      case "AudioChannelSplitter":
        return new AudioChannelSplitterWrappingImplementation._wrap(raw);
      case "AudioContext":
        return new AudioContextWrappingImplementation._wrap(raw);
      case "AudioDestinationNode":
        return new AudioDestinationNodeWrappingImplementation._wrap(raw);
      case "HTMLAudioElement":
        return new AudioElementWrappingImplementation._wrap(raw);
      case "AudioGain":
        return new AudioGainWrappingImplementation._wrap(raw);
      case "AudioGainNode":
        return new AudioGainNodeWrappingImplementation._wrap(raw);
      case "AudioListener":
        return new AudioListenerWrappingImplementation._wrap(raw);
      case "AudioNode":
        return new AudioNodeWrappingImplementation._wrap(raw);
      case "AudioPannerNode":
        return new AudioPannerNodeWrappingImplementation._wrap(raw);
      case "AudioParam":
        return new AudioParamWrappingImplementation._wrap(raw);
      case "AudioProcessingEvent":
        return new AudioProcessingEventWrappingImplementation._wrap(raw);
      case "AudioSourceNode":
        return new AudioSourceNodeWrappingImplementation._wrap(raw);
      case "HTMLBRElement":
        return new BRElementWrappingImplementation._wrap(raw);
      case "BarInfo":
        return new BarInfoWrappingImplementation._wrap(raw);
      case "HTMLBaseElement":
        return new BaseElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLBaseFontElement*/
      case "BeforeLoadEvent":
        return new BeforeLoadEventWrappingImplementation._wrap(raw);
      case "BiquadFilterNode":
        return new BiquadFilterNodeWrappingImplementation._wrap(raw);
      case "Blob":
        return new BlobWrappingImplementation._wrap(raw);
      case "WebKitBlobBuilder":
        return new BlobBuilderWrappingImplementation._wrap(raw);
      case "HTMLBodyElement":
        return new BodyElementWrappingImplementation._wrap(raw);
      case "HTMLButtonElement":
        return new ButtonElementWrappingImplementation._wrap(raw);
      case "CDATASection":
        return new CDATASectionWrappingImplementation._wrap(raw);
      case "CSSCharsetRule":
        return new CSSCharsetRuleWrappingImplementation._wrap(raw);
      case "CSSFontFaceRule":
        return new CSSFontFaceRuleWrappingImplementation._wrap(raw);
      case "CSSImportRule":
        return new CSSImportRuleWrappingImplementation._wrap(raw);
      case "WebKitCSSKeyframeRule":
        return new CSSKeyframeRuleWrappingImplementation._wrap(raw);
      case "WebKitCSSKeyframesRule":
        return new CSSKeyframesRuleWrappingImplementation._wrap(raw);
      case "WebKitCSSMatrix":
        return new CSSMatrixWrappingImplementation._wrap(raw);
      case "CSSMediaRule":
        return new CSSMediaRuleWrappingImplementation._wrap(raw);
      case "CSSPageRule":
        return new CSSPageRuleWrappingImplementation._wrap(raw);
      case "CSSPrimitiveValue":
        return new CSSPrimitiveValueWrappingImplementation._wrap(raw);
      case "CSSRule":
        return new CSSRuleWrappingImplementation._wrap(raw);
      case "CSSRuleList":
        return new CSSRuleListWrappingImplementation._wrap(raw);
      case "CSSStyleDeclaration":
        return new CSSStyleDeclarationWrappingImplementation._wrap(raw);
      case "CSSStyleRule":
        return new CSSStyleRuleWrappingImplementation._wrap(raw);
      case "CSSStyleSheet":
        return new CSSStyleSheetWrappingImplementation._wrap(raw);
      case "WebKitCSSTransformValue":
        return new CSSTransformValueWrappingImplementation._wrap(raw);
      case "CSSUnknownRule":
        return new CSSUnknownRuleWrappingImplementation._wrap(raw);
      case "CSSValue":
        return new CSSValueWrappingImplementation._wrap(raw);
      case "CSSValueList":
        return new CSSValueListWrappingImplementation._wrap(raw);
      case "HTMLCanvasElement":
        return new CanvasElementWrappingImplementation._wrap(raw);
      case "CanvasGradient":
        return new CanvasGradientWrappingImplementation._wrap(raw);
      case "CanvasPattern":
        return new CanvasPatternWrappingImplementation._wrap(raw);
      case "CanvasPixelArray":
        return new CanvasPixelArrayWrappingImplementation._wrap(raw);
      case "CanvasRenderingContext":
        return new CanvasRenderingContextWrappingImplementation._wrap(raw);
      case "CanvasRenderingContext2D":
        return new CanvasRenderingContext2DWrappingImplementation._wrap(raw);
      case "CharacterData":
        return new CharacterDataWrappingImplementation._wrap(raw);
      case "ClientRect":
        return new ClientRectWrappingImplementation._wrap(raw);
      case "ClientRectList":
        return new ClientRectListWrappingImplementation._wrap(raw);
      case "Clipboard":
        return new ClipboardWrappingImplementation._wrap(raw);
      case "CloseEvent":
        return new CloseEventWrappingImplementation._wrap(raw);
      case "Comment":
        return new CommentWrappingImplementation._wrap(raw);
      case "CompositionEvent":
        return new CompositionEventWrappingImplementation._wrap(raw);
      case "Console":
        return new ConsoleWrappingImplementation._wrap(raw);
      case "ConvolverNode":
        return new ConvolverNodeWrappingImplementation._wrap(raw);
      case "Coordinates":
        return new CoordinatesWrappingImplementation._wrap(raw);
      case "Counter":
        return new CounterWrappingImplementation._wrap(raw);
      case "Crypto":
        return new CryptoWrappingImplementation._wrap(raw);
      case "CustomEvent":
        return new CustomEventWrappingImplementation._wrap(raw);
      case "HTMLDListElement":
        return new DListElementWrappingImplementation._wrap(raw);
      case "DOMApplicationCache":
        return new DOMApplicationCacheWrappingImplementation._wrap(raw);
      case "DOMException":
        return new DOMExceptionWrappingImplementation._wrap(raw);
      case "DOMFileSystem":
        return new DOMFileSystemWrappingImplementation._wrap(raw);
      case "DOMFileSystemSync":
        return new DOMFileSystemSyncWrappingImplementation._wrap(raw);
      case "DOMFormData":
        return new DOMFormDataWrappingImplementation._wrap(raw);
      /* Skipping DOMImplementation*/
      case "DOMMimeType":
        return new DOMMimeTypeWrappingImplementation._wrap(raw);
      case "DOMMimeTypeArray":
        return new DOMMimeTypeArrayWrappingImplementation._wrap(raw);
      case "DOMParser":
        return new DOMParserWrappingImplementation._wrap(raw);
      case "DOMPlugin":
        return new DOMPluginWrappingImplementation._wrap(raw);
      case "DOMPluginArray":
        return new DOMPluginArrayWrappingImplementation._wrap(raw);
      case "DOMSelection":
        return new DOMSelectionWrappingImplementation._wrap(raw);
      case "DOMSettableTokenList":
        return new DOMSettableTokenListWrappingImplementation._wrap(raw);
      case "DOMTokenList":
        return new DOMTokenListWrappingImplementation._wrap(raw);
      case "DOMURL":
        return new DOMURLWrappingImplementation._wrap(raw);
      case "HTMLDataListElement":
        return new DataListElementWrappingImplementation._wrap(raw);
      case "DataTransferItem":
        return new DataTransferItemWrappingImplementation._wrap(raw);
      case "DataTransferItemList":
        return new DataTransferItemListWrappingImplementation._wrap(raw);
      case "DataView":
        return new DataViewWrappingImplementation._wrap(raw);
      /* Skipping Database*/
      /* Skipping DatabaseCallback*/
      /* Skipping DatabaseSync*/
      /* Skipping DedicatedWorkerContext*/
      case "DelayNode":
        return new DelayNodeWrappingImplementation._wrap(raw);
      case "HTMLDetailsElement":
        return new DetailsElementWrappingImplementation._wrap(raw);
      case "DeviceMotionEvent":
        return new DeviceMotionEventWrappingImplementation._wrap(raw);
      case "DeviceOrientationEvent":
        return new DeviceOrientationEventWrappingImplementation._wrap(raw);
      /* Skipping HTMLDirectoryElement*/
      case "DirectoryEntry":
        return new DirectoryEntryWrappingImplementation._wrap(raw);
      case "DirectoryEntrySync":
        return new DirectoryEntrySyncWrappingImplementation._wrap(raw);
      case "DirectoryReader":
        return new DirectoryReaderWrappingImplementation._wrap(raw);
      case "DirectoryReaderSync":
        return new DirectoryReaderSyncWrappingImplementation._wrap(raw);
      case "HTMLDivElement":
        return new DivElementWrappingImplementation._wrap(raw);
      case "HTMLDocument":
        return new DocumentWrappingImplementation._wrap(raw, raw.documentElement);
      case "DocumentFragment":
        return new DocumentFragmentWrappingImplementation._wrap(raw);
      /* Skipping DocumentType*/
      case "DynamicsCompressorNode":
        return new DynamicsCompressorNodeWrappingImplementation._wrap(raw);
      case "HTMLElement":
        return new ElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLOptionsCollection*/
      case "ElementTimeControl":
        return new ElementTimeControlWrappingImplementation._wrap(raw);
      /* Skipping ElementTraversal*/
      case "HTMLEmbedElement":
        return new EmbedElementWrappingImplementation._wrap(raw);
      case "Entity":
        return new EntityWrappingImplementation._wrap(raw);
      case "EntityReference":
        return new EntityReferenceWrappingImplementation._wrap(raw);
      /* Skipping EntriesCallback*/
      case "Entry":
        return new EntryWrappingImplementation._wrap(raw);
      case "EntryArray":
        return new EntryArrayWrappingImplementation._wrap(raw);
      case "EntryArraySync":
        return new EntryArraySyncWrappingImplementation._wrap(raw);
      /* Skipping EntryCallback*/
      case "EntrySync":
        return new EntrySyncWrappingImplementation._wrap(raw);
      /* Skipping ErrorCallback*/
      case "ErrorEvent":
        return new ErrorEventWrappingImplementation._wrap(raw);
      case "Event":
        return new EventWrappingImplementation._wrap(raw);
      case "EventException":
        return new EventExceptionWrappingImplementation._wrap(raw);
      /* Skipping EventListener*/
      case "EventSource":
        return new EventSourceWrappingImplementation._wrap(raw);
      case "EventTarget":
        return new EventTargetWrappingImplementation._wrap(raw);
      case "HTMLFieldSetElement":
        return new FieldSetElementWrappingImplementation._wrap(raw);
      case "File":
        return new FileWrappingImplementation._wrap(raw);
      /* Skipping FileCallback*/
      case "FileEntry":
        return new FileEntryWrappingImplementation._wrap(raw);
      case "FileEntrySync":
        return new FileEntrySyncWrappingImplementation._wrap(raw);
      case "FileError":
        return new FileErrorWrappingImplementation._wrap(raw);
      case "FileException":
        return new FileExceptionWrappingImplementation._wrap(raw);
      case "FileList":
        return new FileListWrappingImplementation._wrap(raw);
      case "FileReader":
        return new FileReaderWrappingImplementation._wrap(raw);
      case "FileReaderSync":
        return new FileReaderSyncWrappingImplementation._wrap(raw);
      /* Skipping FileSystemCallback*/
      case "FileWriter":
        return new FileWriterWrappingImplementation._wrap(raw);
      /* Skipping FileWriterCallback*/
      case "FileWriterSync":
        return new FileWriterSyncWrappingImplementation._wrap(raw);
      case "WebKitFlags":
        return new FlagsWrappingImplementation._wrap(raw);
      case "Float32Array":
        return new Float32ArrayWrappingImplementation._wrap(raw);
      case "Float64Array":
        return new Float64ArrayWrappingImplementation._wrap(raw);
      case "HTMLFontElement":
        return new FontElementWrappingImplementation._wrap(raw);
      case "HTMLFormElement":
        return new FormElementWrappingImplementation._wrap(raw);
      /* Skipping HTMLFrameElement*/
      /* Skipping HTMLFrameSetElement*/
      case "Geolocation":
        return new GeolocationWrappingImplementation._wrap(raw);
      case "Geoposition":
        return new GeopositionWrappingImplementation._wrap(raw);
      case "HTMLHRElement":
        return new HRElementWrappingImplementation._wrap(raw);
      case "HTMLAllCollection":
        return new HTMLAllCollectionWrappingImplementation._wrap(raw);
      case "HashChangeEvent":
        return new HashChangeEventWrappingImplementation._wrap(raw);
      case "HTMLHeadElement":
        return new HeadElementWrappingImplementation._wrap(raw);
      case "HTMLHeadingElement":
        return new HeadingElementWrappingImplementation._wrap(raw);
      case "HighPass2FilterNode":
        return new HighPass2FilterNodeWrappingImplementation._wrap(raw);
      case "History":
        return new HistoryWrappingImplementation._wrap(raw);
      case "HTMLHtmlElement":
        return new DocumentWrappingImplementation._wrap(raw.parentNode, raw);
      case "IDBAny":
        return new IDBAnyWrappingImplementation._wrap(raw);
      case "IDBCursor":
        return new IDBCursorWrappingImplementation._wrap(raw);
      case "IDBCursorWithValue":
        return new IDBCursorWithValueWrappingImplementation._wrap(raw);
      case "IDBDatabase":
        return new IDBDatabaseWrappingImplementation._wrap(raw);
      case "IDBDatabaseError":
        return new IDBDatabaseErrorWrappingImplementation._wrap(raw);
      case "IDBDatabaseException":
        return new IDBDatabaseExceptionWrappingImplementation._wrap(raw);
      case "IDBFactory":
        return new IDBFactoryWrappingImplementation._wrap(raw);
      case "IDBIndex":
        return new IDBIndexWrappingImplementation._wrap(raw);
      case "IDBKey":
        return new IDBKeyWrappingImplementation._wrap(raw);
      case "IDBKeyRange":
        return new IDBKeyRangeWrappingImplementation._wrap(raw);
      case "IDBObjectStore":
        return new IDBObjectStoreWrappingImplementation._wrap(raw);
      case "IDBRequest":
        return new IDBRequestWrappingImplementation._wrap(raw);
      case "IDBTransaction":
        return new IDBTransactionWrappingImplementation._wrap(raw);
      case "IDBVersionChangeEvent":
        return new IDBVersionChangeEventWrappingImplementation._wrap(raw);
      case "IDBVersionChangeRequest":
        return new IDBVersionChangeRequestWrappingImplementation._wrap(raw);
      case "HTMLIFrameElement":
        return new IFrameElementWrappingImplementation._wrap(raw);
      case "ImageData":
        return new ImageDataWrappingImplementation._wrap(raw);
      case "HTMLImageElement":
        return new ImageElementWrappingImplementation._wrap(raw);
      /* Skipping InjectedScriptHost*/
      case "HTMLInputElement":
        return new InputElementWrappingImplementation._wrap(raw);
      /* Skipping InspectorFrontendHost*/
      case "Int16Array":
        return new Int16ArrayWrappingImplementation._wrap(raw);
      case "Int32Array":
        return new Int32ArrayWrappingImplementation._wrap(raw);
      case "Int8Array":
        return new Int8ArrayWrappingImplementation._wrap(raw);
      /* Skipping HTMLIsIndexElement*/
      case "JavaScriptAudioNode":
        return new JavaScriptAudioNodeWrappingImplementation._wrap(raw);
      /* Skipping JavaScriptCallFrame*/
      case "KeyboardEvent":
        return new KeyboardEventWrappingImplementation._wrap(raw);
      case "HTMLKeygenElement":
        return new KeygenElementWrappingImplementation._wrap(raw);
      case "HTMLLIElement":
        return new LIElementWrappingImplementation._wrap(raw);
      case "HTMLLabelElement":
        return new LabelElementWrappingImplementation._wrap(raw);
      case "HTMLLegendElement":
        return new LegendElementWrappingImplementation._wrap(raw);
      case "HTMLLinkElement":
        return new LinkElementWrappingImplementation._wrap(raw);
      case "Location":
        return new LocationWrappingImplementation._wrap(raw);
      case "WebKitLoseContext":
        return new LoseContextWrappingImplementation._wrap(raw);
      case "LowPass2FilterNode":
        return new LowPass2FilterNodeWrappingImplementation._wrap(raw);
      case "HTMLMapElement":
        return new MapElementWrappingImplementation._wrap(raw);
      case "HTMLMarqueeElement":
        return new MarqueeElementWrappingImplementation._wrap(raw);
      case "HTMLMediaElement":
        return new MediaElementWrappingImplementation._wrap(raw);
      case "MediaElementAudioSourceNode":
        return new MediaElementAudioSourceNodeWrappingImplementation._wrap(raw);
      case "MediaError":
        return new MediaErrorWrappingImplementation._wrap(raw);
      case "MediaList":
        return new MediaListWrappingImplementation._wrap(raw);
      case "MediaQueryList":
        return new MediaQueryListWrappingImplementation._wrap(raw);
      case "MediaQueryListListener":
        return new MediaQueryListListenerWrappingImplementation._wrap(raw);
      /* Skipping MemoryInfo*/
      case "HTMLMenuElement":
        return new MenuElementWrappingImplementation._wrap(raw);
      case "MessageChannel":
        return new MessageChannelWrappingImplementation._wrap(raw);
      case "MessageEvent":
        return new MessageEventWrappingImplementation._wrap(raw);
      case "MessagePort":
        return new MessagePortWrappingImplementation._wrap(raw);
      case "HTMLMetaElement":
        return new MetaElementWrappingImplementation._wrap(raw);
      case "Metadata":
        return new MetadataWrappingImplementation._wrap(raw);
      /* Skipping MetadataCallback*/
      case "HTMLMeterElement":
        return new MeterElementWrappingImplementation._wrap(raw);
      case "HTMLModElement":
        return new ModElementWrappingImplementation._wrap(raw);
      case "MouseEvent":
        return new MouseEventWrappingImplementation._wrap(raw);
      case "MutationCallback":
        return new MutationCallbackWrappingImplementation._wrap(raw);
      case "MutationEvent":
        return new MutationEventWrappingImplementation._wrap(raw);
      case "MutationRecord":
        return new MutationRecordWrappingImplementation._wrap(raw);
      /* Skipping NamedNodeMap*/
      case "Navigator":
        return new NavigatorWrappingImplementation._wrap(raw);
      case "NavigatorUserMediaError":
        return new NavigatorUserMediaErrorWrappingImplementation._wrap(raw);
      /* Skipping NavigatorUserMediaErrorCallback*/
      case "NavigatorUserMediaSuccessCallback":
        return new NavigatorUserMediaSuccessCallbackWrappingImplementation._wrap(raw);
      case "Node":
        return new NodeWrappingImplementation._wrap(raw);
      /* Skipping NodeFilter*/
      /* Skipping NodeIterator*/
      /* Skipping NodeSelector*/
      case "Notation":
        return new NotationWrappingImplementation._wrap(raw);
      case "Notification":
        return new NotificationWrappingImplementation._wrap(raw);
      case "NotificationCenter":
        return new NotificationCenterWrappingImplementation._wrap(raw);
      case "OESStandardDerivatives":
        return new OESStandardDerivativesWrappingImplementation._wrap(raw);
      case "OESTextureFloat":
        return new OESTextureFloatWrappingImplementation._wrap(raw);
      case "OESVertexArrayObject":
        return new OESVertexArrayObjectWrappingImplementation._wrap(raw);
      case "HTMLOListElement":
        return new OListElementWrappingImplementation._wrap(raw);
      case "HTMLObjectElement":
        return new ObjectElementWrappingImplementation._wrap(raw);
      case "OfflineAudioCompletionEvent":
        return new OfflineAudioCompletionEventWrappingImplementation._wrap(raw);
      case "OperationNotAllowedException":
        return new OperationNotAllowedExceptionWrappingImplementation._wrap(raw);
      case "HTMLOptGroupElement":
        return new OptGroupElementWrappingImplementation._wrap(raw);
      case "HTMLOptionElement":
        return new OptionElementWrappingImplementation._wrap(raw);
      case "HTMLOutputElement":
        return new OutputElementWrappingImplementation._wrap(raw);
      case "OverflowEvent":
        return new OverflowEventWrappingImplementation._wrap(raw);
      case "PageTransitionEvent":
        return new PageTransitionEventWrappingImplementation._wrap(raw);
      case "HTMLParagraphElement":
        return new ParagraphElementWrappingImplementation._wrap(raw);
      case "HTMLParamElement":
        return new ParamElementWrappingImplementation._wrap(raw);
      /* Skipping Performance*/
      /* Skipping PerformanceNavigation*/
      /* Skipping PerformanceTiming*/
      case "WebKitPoint":
        return new PointWrappingImplementation._wrap(raw);
      case "PopStateEvent":
        return new PopStateEventWrappingImplementation._wrap(raw);
      /* Skipping PositionCallback*/
      case "PositionError":
        return new PositionErrorWrappingImplementation._wrap(raw);
      /* Skipping PositionErrorCallback*/
      case "HTMLPreElement":
        return new PreElementWrappingImplementation._wrap(raw);
      case "ProcessingInstruction":
        return new ProcessingInstructionWrappingImplementation._wrap(raw);
      case "HTMLProgressElement":
        return new ProgressElementWrappingImplementation._wrap(raw);
      case "ProgressEvent":
        return new ProgressEventWrappingImplementation._wrap(raw);
      case "HTMLQuoteElement":
        return new QuoteElementWrappingImplementation._wrap(raw);
      case "RGBColor":
        return new RGBColorWrappingImplementation._wrap(raw);
      case "Range":
        return new RangeWrappingImplementation._wrap(raw);
      case "RangeException":
        return new RangeExceptionWrappingImplementation._wrap(raw);
      case "RealtimeAnalyserNode":
        return new RealtimeAnalyserNodeWrappingImplementation._wrap(raw);
      case "Rect":
        return new RectWrappingImplementation._wrap(raw);
      /* Skipping RequestAnimationFrameCallback*/
      /* Skipping SQLError*/
      /* Skipping SQLException*/
      /* Skipping SQLResultSet*/
      /* Skipping SQLResultSetRowList*/
      /* Skipping SQLStatementCallback*/
      /* Skipping SQLStatementErrorCallback*/
      /* Skipping SQLTransaction*/
      /* Skipping SQLTransactionCallback*/
      /* Skipping SQLTransactionErrorCallback*/
      /* Skipping SQLTransactionSync*/
      /* Skipping SQLTransactionSyncCallback*/
      case "SVGAElement":
        return new SVGAElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphDefElement":
        return new SVGAltGlyphDefElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphElement":
        return new SVGAltGlyphElementWrappingImplementation._wrap(raw);
      case "SVGAltGlyphItemElement":
        return new SVGAltGlyphItemElementWrappingImplementation._wrap(raw);
      case "SVGAngle":
        return new SVGAngleWrappingImplementation._wrap(raw);
      case "SVGAnimateColorElement":
        return new SVGAnimateColorElementWrappingImplementation._wrap(raw);
      case "SVGAnimateElement":
        return new SVGAnimateElementWrappingImplementation._wrap(raw);
      case "SVGAnimateMotionElement":
        return new SVGAnimateMotionElementWrappingImplementation._wrap(raw);
      case "SVGAnimateTransformElement":
        return new SVGAnimateTransformElementWrappingImplementation._wrap(raw);
      case "SVGAnimatedAngle":
        return new SVGAnimatedAngleWrappingImplementation._wrap(raw);
      case "SVGAnimatedBoolean":
        return new SVGAnimatedBooleanWrappingImplementation._wrap(raw);
      case "SVGAnimatedEnumeration":
        return new SVGAnimatedEnumerationWrappingImplementation._wrap(raw);
      case "SVGAnimatedInteger":
        return new SVGAnimatedIntegerWrappingImplementation._wrap(raw);
      case "SVGAnimatedLength":
        return new SVGAnimatedLengthWrappingImplementation._wrap(raw);
      case "SVGAnimatedLengthList":
        return new SVGAnimatedLengthListWrappingImplementation._wrap(raw);
      case "SVGAnimatedNumber":
        return new SVGAnimatedNumberWrappingImplementation._wrap(raw);
      case "SVGAnimatedNumberList":
        return new SVGAnimatedNumberListWrappingImplementation._wrap(raw);
      case "SVGAnimatedPreserveAspectRatio":
        return new SVGAnimatedPreserveAspectRatioWrappingImplementation._wrap(raw);
      case "SVGAnimatedRect":
        return new SVGAnimatedRectWrappingImplementation._wrap(raw);
      case "SVGAnimatedString":
        return new SVGAnimatedStringWrappingImplementation._wrap(raw);
      case "SVGAnimatedTransformList":
        return new SVGAnimatedTransformListWrappingImplementation._wrap(raw);
      case "SVGAnimationElement":
        return new SVGAnimationElementWrappingImplementation._wrap(raw);
      case "SVGCircleElement":
        return new SVGCircleElementWrappingImplementation._wrap(raw);
      case "SVGClipPathElement":
        return new SVGClipPathElementWrappingImplementation._wrap(raw);
      case "SVGColor":
        return new SVGColorWrappingImplementation._wrap(raw);
      case "SVGComponentTransferFunctionElement":
        return new SVGComponentTransferFunctionElementWrappingImplementation._wrap(raw);
      case "SVGCursorElement":
        return new SVGCursorElementWrappingImplementation._wrap(raw);
      case "SVGDefsElement":
        return new SVGDefsElementWrappingImplementation._wrap(raw);
      case "SVGDescElement":
        return new SVGDescElementWrappingImplementation._wrap(raw);
      case "SVGDocument":
        return new SVGDocumentWrappingImplementation._wrap(raw);
      case "SVGElement":
        return new SVGElementWrappingImplementation._wrap(raw);
      case "SVGElementInstance":
        return new SVGElementInstanceWrappingImplementation._wrap(raw);
      case "SVGElementInstanceList":
        return new SVGElementInstanceListWrappingImplementation._wrap(raw);
      case "SVGEllipseElement":
        return new SVGEllipseElementWrappingImplementation._wrap(raw);
      case "SVGException":
        return new SVGExceptionWrappingImplementation._wrap(raw);
      case "SVGExternalResourcesRequired":
        return new SVGExternalResourcesRequiredWrappingImplementation._wrap(raw);
      case "SVGFEBlendElement":
        return new SVGFEBlendElementWrappingImplementation._wrap(raw);
      case "SVGFEColorMatrixElement":
        return new SVGFEColorMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEComponentTransferElement":
        return new SVGFEComponentTransferElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFECompositeElement*/
      case "SVGFEConvolveMatrixElement":
        return new SVGFEConvolveMatrixElementWrappingImplementation._wrap(raw);
      case "SVGFEDiffuseLightingElement":
        return new SVGFEDiffuseLightingElementWrappingImplementation._wrap(raw);
      case "SVGFEDisplacementMapElement":
        return new SVGFEDisplacementMapElementWrappingImplementation._wrap(raw);
      case "SVGFEDistantLightElement":
        return new SVGFEDistantLightElementWrappingImplementation._wrap(raw);
      case "SVGFEDropShadowElement":
        return new SVGFEDropShadowElementWrappingImplementation._wrap(raw);
      case "SVGFEFloodElement":
        return new SVGFEFloodElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncAElement":
        return new SVGFEFuncAElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncBElement":
        return new SVGFEFuncBElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncGElement":
        return new SVGFEFuncGElementWrappingImplementation._wrap(raw);
      case "SVGFEFuncRElement":
        return new SVGFEFuncRElementWrappingImplementation._wrap(raw);
      case "SVGFEGaussianBlurElement":
        return new SVGFEGaussianBlurElementWrappingImplementation._wrap(raw);
      case "SVGFEImageElement":
        return new SVGFEImageElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeElement":
        return new SVGFEMergeElementWrappingImplementation._wrap(raw);
      case "SVGFEMergeNodeElement":
        return new SVGFEMergeNodeElementWrappingImplementation._wrap(raw);
      /* Skipping SVGFEMorphologyElement*/
      case "SVGFEOffsetElement":
        return new SVGFEOffsetElementWrappingImplementation._wrap(raw);
      case "SVGFEPointLightElement":
        return new SVGFEPointLightElementWrappingImplementation._wrap(raw);
      case "SVGFESpecularLightingElement":
        return new SVGFESpecularLightingElementWrappingImplementation._wrap(raw);
      case "SVGFESpotLightElement":
        return new SVGFESpotLightElementWrappingImplementation._wrap(raw);
      case "SVGFETileElement":
        return new SVGFETileElementWrappingImplementation._wrap(raw);
      case "SVGFETurbulenceElement":
        return new SVGFETurbulenceElementWrappingImplementation._wrap(raw);
      case "SVGFilterElement":
        return new SVGFilterElementWrappingImplementation._wrap(raw);
      case "SVGFilterPrimitiveStandardAttributes":
        return new SVGFilterPrimitiveStandardAttributesWrappingImplementation._wrap(raw);
      case "SVGFitToViewBox":
        return new SVGFitToViewBoxWrappingImplementation._wrap(raw);
      case "SVGFontElement":
        return new SVGFontElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceElement":
        return new SVGFontFaceElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceFormatElement":
        return new SVGFontFaceFormatElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceNameElement":
        return new SVGFontFaceNameElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceSrcElement":
        return new SVGFontFaceSrcElementWrappingImplementation._wrap(raw);
      case "SVGFontFaceUriElement":
        return new SVGFontFaceUriElementWrappingImplementation._wrap(raw);
      case "SVGForeignObjectElement":
        return new SVGForeignObjectElementWrappingImplementation._wrap(raw);
      case "SVGGElement":
        return new SVGGElementWrappingImplementation._wrap(raw);
      case "SVGGlyphElement":
        return new SVGGlyphElementWrappingImplementation._wrap(raw);
      case "SVGGlyphRefElement":
        return new SVGGlyphRefElementWrappingImplementation._wrap(raw);
      case "SVGGradientElement":
        return new SVGGradientElementWrappingImplementation._wrap(raw);
      case "SVGHKernElement":
        return new SVGHKernElementWrappingImplementation._wrap(raw);
      case "SVGImageElement":
        return new SVGImageElementWrappingImplementation._wrap(raw);
      case "SVGLangSpace":
        return new SVGLangSpaceWrappingImplementation._wrap(raw);
      case "SVGLength":
        return new SVGLengthWrappingImplementation._wrap(raw);
      case "SVGLengthList":
        return new SVGLengthListWrappingImplementation._wrap(raw);
      case "SVGLineElement":
        return new SVGLineElementWrappingImplementation._wrap(raw);
      case "SVGLinearGradientElement":
        return new SVGLinearGradientElementWrappingImplementation._wrap(raw);
      case "SVGLocatable":
        return new SVGLocatableWrappingImplementation._wrap(raw);
      case "SVGMPathElement":
        return new SVGMPathElementWrappingImplementation._wrap(raw);
      case "SVGMarkerElement":
        return new SVGMarkerElementWrappingImplementation._wrap(raw);
      case "SVGMaskElement":
        return new SVGMaskElementWrappingImplementation._wrap(raw);
      case "SVGMatrix":
        return new SVGMatrixWrappingImplementation._wrap(raw);
      case "SVGMetadataElement":
        return new SVGMetadataElementWrappingImplementation._wrap(raw);
      case "SVGMissingGlyphElement":
        return new SVGMissingGlyphElementWrappingImplementation._wrap(raw);
      case "SVGNumber":
        return new SVGNumberWrappingImplementation._wrap(raw);
      case "SVGNumberList":
        return new SVGNumberListWrappingImplementation._wrap(raw);
      case "SVGPaint":
        return new SVGPaintWrappingImplementation._wrap(raw);
      case "SVGPathElement":
        return new SVGPathElementWrappingImplementation._wrap(raw);
      case "SVGPathSeg":
        return new SVGPathSegWrappingImplementation._wrap(raw);
      case "SVGPathSegArcAbs":
        return new SVGPathSegArcAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegArcRel":
        return new SVGPathSegArcRelWrappingImplementation._wrap(raw);
      case "SVGPathSegClosePath":
        return new SVGPathSegClosePathWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoCubicAbs":
        return new SVGPathSegCurvetoCubicAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoCubicRel":
        return new SVGPathSegCurvetoCubicRelWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoCubicSmoothAbs":
        return new SVGPathSegCurvetoCubicSmoothAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoCubicSmoothRel":
        return new SVGPathSegCurvetoCubicSmoothRelWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoQuadraticAbs":
        return new SVGPathSegCurvetoQuadraticAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoQuadraticRel":
        return new SVGPathSegCurvetoQuadraticRelWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoQuadraticSmoothAbs":
        return new SVGPathSegCurvetoQuadraticSmoothAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegCurvetoQuadraticSmoothRel":
        return new SVGPathSegCurvetoQuadraticSmoothRelWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoAbs":
        return new SVGPathSegLinetoAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoHorizontalAbs":
        return new SVGPathSegLinetoHorizontalAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoHorizontalRel":
        return new SVGPathSegLinetoHorizontalRelWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoRel":
        return new SVGPathSegLinetoRelWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoVerticalAbs":
        return new SVGPathSegLinetoVerticalAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegLinetoVerticalRel":
        return new SVGPathSegLinetoVerticalRelWrappingImplementation._wrap(raw);
      case "SVGPathSegList":
        return new SVGPathSegListWrappingImplementation._wrap(raw);
      case "SVGPathSegMovetoAbs":
        return new SVGPathSegMovetoAbsWrappingImplementation._wrap(raw);
      case "SVGPathSegMovetoRel":
        return new SVGPathSegMovetoRelWrappingImplementation._wrap(raw);
      case "SVGPatternElement":
        return new SVGPatternElementWrappingImplementation._wrap(raw);
      case "SVGPoint":
        return new SVGPointWrappingImplementation._wrap(raw);
      case "SVGPointList":
        return new SVGPointListWrappingImplementation._wrap(raw);
      case "SVGPolygonElement":
        return new SVGPolygonElementWrappingImplementation._wrap(raw);
      case "SVGPolylineElement":
        return new SVGPolylineElementWrappingImplementation._wrap(raw);
      case "SVGPreserveAspectRatio":
        return new SVGPreserveAspectRatioWrappingImplementation._wrap(raw);
      case "SVGRadialGradientElement":
        return new SVGRadialGradientElementWrappingImplementation._wrap(raw);
      case "SVGRect":
        return new SVGRectWrappingImplementation._wrap(raw);
      case "SVGRectElement":
        return new SVGRectElementWrappingImplementation._wrap(raw);
      case "SVGRenderingIntent":
        return new SVGRenderingIntentWrappingImplementation._wrap(raw);
      case "SVGSVGElement":
        return new SVGSVGElementWrappingImplementation._wrap(raw);
      case "SVGScriptElement":
        return new SVGScriptElementWrappingImplementation._wrap(raw);
      case "SVGSetElement":
        return new SVGSetElementWrappingImplementation._wrap(raw);
      case "SVGStopElement":
        return new SVGStopElementWrappingImplementation._wrap(raw);
      case "SVGStringList":
        return new SVGStringListWrappingImplementation._wrap(raw);
      case "SVGStylable":
        return new SVGStylableWrappingImplementation._wrap(raw);
      case "SVGStyleElement":
        return new SVGStyleElementWrappingImplementation._wrap(raw);
      case "SVGSwitchElement":
        return new SVGSwitchElementWrappingImplementation._wrap(raw);
      case "SVGSymbolElement":
        return new SVGSymbolElementWrappingImplementation._wrap(raw);
      case "SVGTRefElement":
        return new SVGTRefElementWrappingImplementation._wrap(raw);
      case "SVGTSpanElement":
        return new SVGTSpanElementWrappingImplementation._wrap(raw);
      case "SVGTests":
        return new SVGTestsWrappingImplementation._wrap(raw);
      case "SVGTextContentElement":
        return new SVGTextContentElementWrappingImplementation._wrap(raw);
      case "SVGTextElement":
        return new SVGTextElementWrappingImplementation._wrap(raw);
      case "SVGTextPathElement":
        return new SVGTextPathElementWrappingImplementation._wrap(raw);
      case "SVGTextPositioningElement":
        return new SVGTextPositioningElementWrappingImplementation._wrap(raw);
      case "SVGTitleElement":
        return new SVGTitleElementWrappingImplementation._wrap(raw);
      case "SVGTransform":
        return new SVGTransformWrappingImplementation._wrap(raw);
      case "SVGTransformList":
        return new SVGTransformListWrappingImplementation._wrap(raw);
      case "SVGTransformable":
        return new SVGTransformableWrappingImplementation._wrap(raw);
      case "SVGURIReference":
        return new SVGURIReferenceWrappingImplementation._wrap(raw);
      case "SVGUnitTypes":
        return new SVGUnitTypesWrappingImplementation._wrap(raw);
      case "SVGUseElement":
        return new SVGUseElementWrappingImplementation._wrap(raw);
      case "SVGVKernElement":
        return new SVGVKernElementWrappingImplementation._wrap(raw);
      case "SVGViewElement":
        return new SVGViewElementWrappingImplementation._wrap(raw);
      case "SVGViewSpec":
        return new SVGViewSpecWrappingImplementation._wrap(raw);
      case "SVGZoomAndPan":
        return new SVGZoomAndPanWrappingImplementation._wrap(raw);
      case "SVGZoomEvent":
        return new SVGZoomEventWrappingImplementation._wrap(raw);
      case "Screen":
        return new ScreenWrappingImplementation._wrap(raw);
      case "HTMLScriptElement":
        return new ScriptElementWrappingImplementation._wrap(raw);
      /* Skipping ScriptProfile*/
      /* Skipping ScriptProfileNode*/
      case "HTMLSelectElement":
        return new SelectElementWrappingImplementation._wrap(raw);
      case "SharedWorker":
        return new SharedWorkerWrappingImplementation._wrap(raw);
      /* Skipping SharedWorkercontext*/
      case "HTMLSourceElement":
        return new SourceElementWrappingImplementation._wrap(raw);
      case "HTMLSpanElement":
        return new SpanElementWrappingImplementation._wrap(raw);
      case "SpeechInputEvent":
        return new SpeechInputEventWrappingImplementation._wrap(raw);
      case "SpeechInputResult":
        return new SpeechInputResultWrappingImplementation._wrap(raw);
      case "SpeechInputResultList":
        return new SpeechInputResultListWrappingImplementation._wrap(raw);
      case "Storage":
        return new StorageWrappingImplementation._wrap(raw);
      case "StorageEvent":
        return new StorageEventWrappingImplementation._wrap(raw);
      case "StorageInfo":
        return new StorageInfoWrappingImplementation._wrap(raw);
      /* Skipping StorageInfoErrorCallback*/
      /* Skipping StorageInfoQuotaCallback*/
      /* Skipping StorageInfoUsageCallback*/
      /* Skipping StringCallback*/
      case "HTMLStyleElement":
        return new StyleElementWrappingImplementation._wrap(raw);
      case "StyleMedia":
        return new StyleMediaWrappingImplementation._wrap(raw);
      case "StyleSheet":
        return new StyleSheetWrappingImplementation._wrap(raw);
      case "StyleSheetList":
        return new StyleSheetListWrappingImplementation._wrap(raw);
      case "HTMLTableCaptionElement":
        return new TableCaptionElementWrappingImplementation._wrap(raw);
      case "HTMLTableCellElement":
        return new TableCellElementWrappingImplementation._wrap(raw);
      case "HTMLTableColElement":
        return new TableColElementWrappingImplementation._wrap(raw);
      case "HTMLTableElement":
        return new TableElementWrappingImplementation._wrap(raw);
      case "HTMLTableRowElement":
        return new TableRowElementWrappingImplementation._wrap(raw);
      case "HTMLTableSectionElement":
        return new TableSectionElementWrappingImplementation._wrap(raw);
      case "Text":
        return new TextWrappingImplementation._wrap(raw);
      case "HTMLTextAreaElement":
        return new TextAreaElementWrappingImplementation._wrap(raw);
      case "TextEvent":
        return new TextEventWrappingImplementation._wrap(raw);
      case "TextMetrics":
        return new TextMetricsWrappingImplementation._wrap(raw);
      case "TextTrack":
        return new TextTrackWrappingImplementation._wrap(raw);
      case "TextTrackCue":
        return new TextTrackCueWrappingImplementation._wrap(raw);
      case "TextTrackCueList":
        return new TextTrackCueListWrappingImplementation._wrap(raw);
      case "TimeRanges":
        return new TimeRangesWrappingImplementation._wrap(raw);
      case "HTMLTitleElement":
        return new TitleElementWrappingImplementation._wrap(raw);
      case "Touch":
        return new TouchWrappingImplementation._wrap(raw);
      case "TouchEvent":
        return new TouchEventWrappingImplementation._wrap(raw);
      case "TouchList":
        return new TouchListWrappingImplementation._wrap(raw);
      case "HTMLTrackElement":
        return new TrackElementWrappingImplementation._wrap(raw);
      case "WebKitTransitionEvent":
        return new TransitionEventWrappingImplementation._wrap(raw);
      /* Skipping TreeWalker*/
      case "UIEvent":
        return new UIEventWrappingImplementation._wrap(raw);
      case "HTMLUListElement":
        return new UListElementWrappingImplementation._wrap(raw);
      case "Uint16Array":
        return new Uint16ArrayWrappingImplementation._wrap(raw);
      case "Uint32Array":
        return new Uint32ArrayWrappingImplementation._wrap(raw);
      case "Uint8Array":
        return new Uint8ArrayWrappingImplementation._wrap(raw);
      case "HTMLUnknownElement":
        return new UnknownElementWrappingImplementation._wrap(raw);
      case "ValidityState":
        return new ValidityStateWrappingImplementation._wrap(raw);
      case "HTMLVideoElement":
        return new VideoElementWrappingImplementation._wrap(raw);
      case "VoidCallback":
        return new VoidCallbackWrappingImplementation._wrap(raw);
      case "WaveShaperNode":
        return new WaveShaperNodeWrappingImplementation._wrap(raw);
      case "WebGLActiveInfo":
        return new WebGLActiveInfoWrappingImplementation._wrap(raw);
      case "WebGLBuffer":
        return new WebGLBufferWrappingImplementation._wrap(raw);
      case "WebGLContextAttributes":
        return new WebGLContextAttributesWrappingImplementation._wrap(raw);
      case "WebGLContextEvent":
        return new WebGLContextEventWrappingImplementation._wrap(raw);
      case "WebGLDebugRendererInfo":
        return new WebGLDebugRendererInfoWrappingImplementation._wrap(raw);
      case "WebGLDebugShaders":
        return new WebGLDebugShadersWrappingImplementation._wrap(raw);
      case "WebGLFramebuffer":
        return new WebGLFramebufferWrappingImplementation._wrap(raw);
      case "WebGLProgram":
        return new WebGLProgramWrappingImplementation._wrap(raw);
      case "WebGLRenderbuffer":
        return new WebGLRenderbufferWrappingImplementation._wrap(raw);
      case "WebGLRenderingContext":
        return new WebGLRenderingContextWrappingImplementation._wrap(raw);
      case "WebGLShader":
        return new WebGLShaderWrappingImplementation._wrap(raw);
      case "WebGLTexture":
        return new WebGLTextureWrappingImplementation._wrap(raw);
      case "WebGLUniformLocation":
        return new WebGLUniformLocationWrappingImplementation._wrap(raw);
      case "WebGLVertexArrayObjectOES":
        return new WebGLVertexArrayObjectOESWrappingImplementation._wrap(raw);
      case "WebKitCSSFilterValue":
        return new WebKitCSSFilterValueWrappingImplementation._wrap(raw);
      case "WebKitMutationObserver":
        return new WebKitMutationObserverWrappingImplementation._wrap(raw);
      case "WebSocket":
        return new WebSocketWrappingImplementation._wrap(raw);
      case "WheelEvent":
        return new WheelEventWrappingImplementation._wrap(raw);
      case "Window":
        return new WindowWrappingImplementation._wrap(raw);
      case "Worker":
        return new WorkerWrappingImplementation._wrap(raw);
      /* Skipping WorkerContext*/
      /* Skipping WorkerLocation*/
      /* Skipping WorkerNavigator*/
      case "XMLHttpRequest":
        return new XMLHttpRequestWrappingImplementation._wrap(raw);
      case "XMLHttpRequestException":
        return new XMLHttpRequestExceptionWrappingImplementation._wrap(raw);
      case "XMLHttpRequestProgressEvent":
        return new XMLHttpRequestProgressEventWrappingImplementation._wrap(raw);
      case "XMLHttpRequestUpload":
        return new XMLHttpRequestUploadWrappingImplementation._wrap(raw);
      /* Skipping XMLSerializer*/
      /* Skipping XPathEvaluator*/
      /* Skipping XPathException*/
      /* Skipping XPathExpression*/
      /* Skipping XPathNSResolver*/
      /* Skipping XPathResult*/
      /* Skipping XSLTProcessor*/
      default:
        throw new UnsupportedOperationException("Unknown type:" + raw.toString());
    }
  }

  static unwrapMaybePrimitive(raw) {
    return (raw === null || raw is String || raw is num || raw is bool) ? raw : raw._ptr;
  }

  static unwrap(raw) {
    return raw === null ? null : raw._ptr;
  }


  static void initialize() {
    secretWindow = wrapWindow(dom.window);
    secretDocument = wrapDocument(dom.document);
  }

}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The [Collections] class implements static methods useful when
 * writing a class that implements [Collection] and the [iterator]
 * method.
 */
class _Collections {
  static void forEach(Iterable<Object> iterable, void f(Object o)) {
    for (final e in iterable) {
      f(e);
    }
  }

  static bool some(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (f(e)) return true;
    }
    return false;
  }

  static bool every(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (!f(e)) return false;
    }
    return true;
  }

  static List filter(Iterable<Object> source,
                     List<Object> destination,
                     bool f(o)) {
    for (final e in source) {
      if (f(e)) destination.add(e);
    }
    return destination;
  }

  static bool isEmpty(Iterable<Object> iterable) {
    return !iterable.iterator().hasNext();
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


// These factory methods could all live in one factory provider class but dartc
// has a bug (5399939) preventing that.

class FileReaderFactoryProvider {

  factory FileReader() {
    return new dom.FileReader();
  }
}

class CSSMatrixFactoryProvider {

  factory CSSMatrix([String spec = '']) {
    return new CSSMatrixWrappingImplementation._wrap(
        new dom.WebKitCSSMatrix(spec));
  }
}

class PointFactoryProvider {

  factory Point(num x, num y) {
    return new PointWrappingImplementation._wrap(new dom.WebKitPoint(x, y));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Iterator for lists with fixed size.
class _FixedSizeListIterator<T> extends _VariableSizeListIterator<T> {
  _FixedSizeListIterator(List<T> list)
      : super(list),
        _length = list.length;

  bool hasNext() => _length > _pos;

  final int _length;  // Cache list length for faster access.
}

// Iterator for lists with variable size.
class _VariableSizeListIterator<T> implements Iterator<T> {
  _VariableSizeListIterator(List<T> list)
      : _list = list,
        _pos = 0;

  bool hasNext() => _list.length > _pos;

  T next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }
    return _list[_pos++];
  }

  final List<T> _list;
  int _pos;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jacobr): move into a core library or at least merge with the copy
// in client/dom/src
class _Lists {

  /**
   * Returns the index in the array [a] of the given [element], starting
   * the search at index [startIndex] to [endIndex] (exclusive).
   * Returns -1 if [element] is not found.
   */
  static int indexOf(List a,
                     Object element,
                     int startIndex,
                     int endIndex) {
    if (startIndex >= a.length) {
      return -1;
    }
    if (startIndex < 0) {
      startIndex = 0;
    }
    for (int i = startIndex; i < endIndex; i++) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns the last index in the array [a] of the given [element], starting
   * the search at index [startIndex] to 0.
   * Returns -1 if [element] is not found.
   */
  static int lastIndexOf(List a, Object element, int startIndex) {
    if (startIndex < 0) {
      return -1;
    }
    if (startIndex >= a.length) {
      startIndex = a.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class AbstractWorkerEventsImplementation extends EventsImplementation implements AbstractWorkerEvents {
  AbstractWorkerEventsImplementation._wrap(_ptr) : super._wrap(_ptr);

  EventListenerList get error() => _get('error');
}

class AbstractWorkerWrappingImplementation extends EventTargetWrappingImplementation implements AbstractWorker {
  AbstractWorkerWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  AbstractWorkerEvents get on() {
    if (_on === null) {	
      _on = new AbstractWorkerEventsImplementation._wrap(_ptr);
    }
    return _on;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class AnimationEventWrappingImplementation extends EventWrappingImplementation implements AnimationEvent {
  static String _name;

  AnimationEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  static String get _eventName() {
    if (_name != null) return _name;

    try {
      dom.document.createEvent("WebKitAnimationEvent");
      _name = "WebKitAnimationEvent";
    } catch (var e) {
      _name = "AnimationEvent";
    }
    return _name;
  }

  factory AnimationEventWrappingImplementation(String type, String propertyName,
      double elapsedTime, [bool canBubble = true, bool cancelable = true]) {
    final e = dom.document.createEvent(_eventName);
    e.initWebKitAnimationEvent(
        type, canBubble, cancelable, propertyName, elapsedTime);
    return LevelDom.wrapAnimationEvent(e);
  }

  String get animationName() => _ptr.animationName;

  num get elapsedTime() => _ptr.elapsedTime;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class BeforeLoadEventWrappingImplementation extends EventWrappingImplementation implements BeforeLoadEvent {
  BeforeLoadEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory BeforeLoadEventWrappingImplementation(String type, String url,
      [bool canBubble = true, bool cancelable = true]) {
    final e = dom.document.createEvent("BeforeLoadEvent");
    e.initBeforeLoadEvent(type, canBubble, cancelable, url);
    return LevelDom.wrapBeforeLoadEvent(e);
  }

  String get url() => _ptr.url;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class BodyElementEventsImplementation
    extends ElementEventsImplementation implements BodyElementEvents {

  BodyElementEventsImplementation._wrap(_ptr) : super._wrap(_ptr);

  EventListenerList get beforeUnload() => _get('beforeunload');
  EventListenerList get hashChange() => _get('hashchange');
  EventListenerList get message() => _get('message');
  EventListenerList get offline() => _get('offline');
  EventListenerList get online() => _get('online');
  EventListenerList get orientationChange() => _get('orientationchange');
  EventListenerList get popState() => _get('popstate');
  EventListenerList get resize() => _get('resize');
  EventListenerList get storage() => _get('storage');
  EventListenerList get unLoad() => _get('unload');
}

class BodyElementWrappingImplementation
    extends ElementWrappingImplementation implements BodyElement {

  BodyElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  BodyElementEvents get on() {
    if (_on === null) {
      _on = new BodyElementEventsImplementation._wrap(_ptr);
    }
    return _on;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class CloseEventWrappingImplementation extends EventWrappingImplementation implements CloseEvent {
  CloseEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory CloseEventWrappingImplementation(String type, int code, String reason,
      [bool canBubble = true, bool cancelable = true, bool wasClean = true]) {
    final e = dom.document.createEvent("CloseEvent");
    e.initCloseEvent(type, canBubble, cancelable, wasClean, code, reason);
    return LevelDom.wrapCloseEvent(e);
  }

  int get code() => _ptr.code;

  String get reason() => _ptr.reason;

  bool get wasClean() => _ptr.wasClean;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class CompositionEventWrappingImplementation extends UIEventWrappingImplementation implements CompositionEvent {
  CompositionEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory CompositionEventWrappingImplementation(String type, Window view,
      String data, [bool canBubble = true, bool cancelable = true]) {
    final e = dom.document.createEvent("CompositionEvent");
    e.initCompositionEvent(type, canBubble, cancelable, LevelDom.unwrap(view),
        data);
    return LevelDom.wrapCompositionEvent(e);
  }

  String get data() => _ptr.data;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO - figure out whether classList exists, and if so use that
// rather than the className property that is being used here.

class _CssClassSet implements Set<String> {

  final _element;

  _CssClassSet(this._element);

  String toString() {
    return _formatSet(_read());
  }

  // interface Iterable - BEGIN
  Iterator<String> iterator() {
    return _read().iterator();
  }
  // interface Iterable - END

  // interface Collection - BEGIN
  void forEach(void f(String element)) {
    _read().forEach(f);
  }

  Collection<String> filter(bool f(String element)) {
    return _read().filter(f);
  }

  bool every(bool f(String element)) {
    return _read().every(f);
  }

  bool some(bool f(String element)) {
    return _read().some(f);
  }

  bool isEmpty() {
    return _read().isEmpty();
  }

  int get length() {
    return _read().length;
  }
  // interface Collection - END

  // interface Set - BEGIN
  bool contains(String value) {
    return _read().contains(value);
  }

  void add(String value) {
    // TODO - figure out if we need to do any validation here
    // or if the browser natively does enough
    _modify((s) => s.add(value));
  }

  bool remove(String value) {
    Set<String> s = _read();
    bool result = s.remove(value);
    _write(s);
    return result;
  }

  void addAll(Collection<String> collection) {
    // TODO - see comment above about validation
    _modify((s) => s.addAll(collection));
  }

  void removeAll(Collection<String> collection) {
    _modify((s) => s.removeAll(collection));
  }

  bool isSubsetOf(Collection<String> collection) {
    return _read().isSubsetOf(collection);
  }

  bool containsAll(Collection<String> collection) {
    return _read().containsAll(collection);
  }

  Set<String> intersection(Collection<String> other) {
    return _read().intersection(other);
  }

  void clear() {
    _modify((s) => s.clear());
  }
  // interface Set - END

  /**
   * Helper method used to modify the set of css classes on this element.
   *
   *   f - callback with:
   *      s - a Set of all the css class name currently on this element.
   *
   *   After f returns, the modified set is written to the
   *       className property of this element.
   */
  void _modify( f(Set<String> s)) {
    Set<String> s = _read();
    f(s);
    _write(s);
  }

  /**
   * Read the class names from the HTMLElement class property,
   * and put them into a set (duplicates are discarded).
   */
  Set<String> _read() {
    // TODO(mattsh) simplify this once split can take regex.
    Set<String> s = new Set<String>();
    for (String name in _element.className.split(' ')) {
      String trimmed = name.trim();
      if (!trimmed.isEmpty()) {
        s.add(trimmed);
      }
    }
    return s;
  }

  /**
   * Join all the elements of a set into one string and write
   * back to the element.
   */
  void _write(Set s) {
    _element.className = _formatSet(s);
  }

  String _formatSet(Set<String> s) {
    // TODO(mattsh) should be able to pass Set to String.joins http:/b/5398605
    List list = new List.from(s);
    return Strings.join(list, ' ');
  }

}

// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit.
// This file was generated by html/scripts/css_code_generator.py

// Source of CSS properties:
//   Source/WebCore/css/CSSPropertyNames.in

// TODO(jacobr): add versions that take numeric values in px, miliseconds, etc.

class CSSStyleDeclarationWrappingImplementation extends DOMWrapperBase implements CSSStyleDeclaration {
  static String _cachedBrowserPrefix;

  CSSStyleDeclarationWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  factory CSSStyleDeclarationWrappingImplementation.css(String css) {
    var style = new Element.tag('div').style;
    style.cssText = css;
    return style;
  }

  factory CSSStyleDeclarationWrappingImplementation() {
    return new CSSStyleDeclarationWrappingImplementation.css('');
  }

  static String get _browserPrefix() {
    if (_cachedBrowserPrefix === null) {
      if (_Device.isFirefox) {
        _cachedBrowserPrefix = '-moz-';
      } else {
        _cachedBrowserPrefix = '-webkit-';
      }
      // TODO(jacobr): support IE 9.0 and Opera as well.
    }
    return _cachedBrowserPrefix;
  }

  String get cssText() { return _ptr.cssText; }

  void set cssText(String value) { _ptr.cssText = value; }

  int get length() { return _ptr.length; }

  CSSRule get parentRule() { return LevelDom.wrapCSSRule(_ptr.parentRule); }

  CSSValue getPropertyCSSValue(String propertyName) {
    return LevelDom.wrapCSSValue(_ptr.getPropertyCSSValue(propertyName));
  }

  String getPropertyPriority(String propertyName) {
    return _ptr.getPropertyPriority(propertyName);
  }

  String getPropertyShorthand(String propertyName) {
    return _ptr.getPropertyShorthand(propertyName);
  }

  String getPropertyValue(String propertyName) {
    return _ptr.getPropertyValue(propertyName);
  }

  bool isPropertyImplicit(String propertyName) {
    return _ptr.isPropertyImplicit(propertyName);
  }

  String item(int index) {
    return _ptr.item(index);
  }

  String removeProperty(String propertyName) {
    return _ptr.removeProperty(propertyName);
  }

  void setProperty(String propertyName, String value, [String priority = '']) {
    _ptr.setProperty(propertyName, value, priority);
  }

  String get typeName() { return "CSSStyleDeclaration"; }


  /** Gets the value of "animation" */
  String get animation() =>
    getPropertyValue('${_browserPrefix}animation');

  /** Sets the value of "animation" */
  void set animation(String value) {
    setProperty('${_browserPrefix}animation', value, '');
  }

  /** Gets the value of "animation-delay" */
  String get animationDelay() =>
    getPropertyValue('${_browserPrefix}animation-delay');

  /** Sets the value of "animation-delay" */
  void set animationDelay(String value) {
    setProperty('${_browserPrefix}animation-delay', value, '');
  }

  /** Gets the value of "animation-direction" */
  String get animationDirection() =>
    getPropertyValue('${_browserPrefix}animation-direction');

  /** Sets the value of "animation-direction" */
  void set animationDirection(String value) {
    setProperty('${_browserPrefix}animation-direction', value, '');
  }

  /** Gets the value of "animation-duration" */
  String get animationDuration() =>
    getPropertyValue('${_browserPrefix}animation-duration');

  /** Sets the value of "animation-duration" */
  void set animationDuration(String value) {
    setProperty('${_browserPrefix}animation-duration', value, '');
  }

  /** Gets the value of "animation-fill-mode" */
  String get animationFillMode() =>
    getPropertyValue('${_browserPrefix}animation-fill-mode');

  /** Sets the value of "animation-fill-mode" */
  void set animationFillMode(String value) {
    setProperty('${_browserPrefix}animation-fill-mode', value, '');
  }

  /** Gets the value of "animation-iteration-count" */
  String get animationIterationCount() =>
    getPropertyValue('${_browserPrefix}animation-iteration-count');

  /** Sets the value of "animation-iteration-count" */
  void set animationIterationCount(String value) {
    setProperty('${_browserPrefix}animation-iteration-count', value, '');
  }

  /** Gets the value of "animation-name" */
  String get animationName() =>
    getPropertyValue('${_browserPrefix}animation-name');

  /** Sets the value of "animation-name" */
  void set animationName(String value) {
    setProperty('${_browserPrefix}animation-name', value, '');
  }

  /** Gets the value of "animation-play-state" */
  String get animationPlayState() =>
    getPropertyValue('${_browserPrefix}animation-play-state');

  /** Sets the value of "animation-play-state" */
  void set animationPlayState(String value) {
    setProperty('${_browserPrefix}animation-play-state', value, '');
  }

  /** Gets the value of "animation-timing-function" */
  String get animationTimingFunction() =>
    getPropertyValue('${_browserPrefix}animation-timing-function');

  /** Sets the value of "animation-timing-function" */
  void set animationTimingFunction(String value) {
    setProperty('${_browserPrefix}animation-timing-function', value, '');
  }

  /** Gets the value of "appearance" */
  String get appearance() =>
    getPropertyValue('${_browserPrefix}appearance');

  /** Sets the value of "appearance" */
  void set appearance(String value) {
    setProperty('${_browserPrefix}appearance', value, '');
  }

  /** Gets the value of "backface-visibility" */
  String get backfaceVisibility() =>
    getPropertyValue('${_browserPrefix}backface-visibility');

  /** Sets the value of "backface-visibility" */
  void set backfaceVisibility(String value) {
    setProperty('${_browserPrefix}backface-visibility', value, '');
  }

  /** Gets the value of "background" */
  String get background() =>
    getPropertyValue('background');

  /** Sets the value of "background" */
  void set background(String value) {
    setProperty('background', value, '');
  }

  /** Gets the value of "background-attachment" */
  String get backgroundAttachment() =>
    getPropertyValue('background-attachment');

  /** Sets the value of "background-attachment" */
  void set backgroundAttachment(String value) {
    setProperty('background-attachment', value, '');
  }

  /** Gets the value of "background-clip" */
  String get backgroundClip() =>
    getPropertyValue('background-clip');

  /** Sets the value of "background-clip" */
  void set backgroundClip(String value) {
    setProperty('background-clip', value, '');
  }

  /** Gets the value of "background-color" */
  String get backgroundColor() =>
    getPropertyValue('background-color');

  /** Sets the value of "background-color" */
  void set backgroundColor(String value) {
    setProperty('background-color', value, '');
  }

  /** Gets the value of "background-composite" */
  String get backgroundComposite() =>
    getPropertyValue('${_browserPrefix}background-composite');

  /** Sets the value of "background-composite" */
  void set backgroundComposite(String value) {
    setProperty('${_browserPrefix}background-composite', value, '');
  }

  /** Gets the value of "background-image" */
  String get backgroundImage() =>
    getPropertyValue('background-image');

  /** Sets the value of "background-image" */
  void set backgroundImage(String value) {
    setProperty('background-image', value, '');
  }

  /** Gets the value of "background-origin" */
  String get backgroundOrigin() =>
    getPropertyValue('background-origin');

  /** Sets the value of "background-origin" */
  void set backgroundOrigin(String value) {
    setProperty('background-origin', value, '');
  }

  /** Gets the value of "background-position" */
  String get backgroundPosition() =>
    getPropertyValue('background-position');

  /** Sets the value of "background-position" */
  void set backgroundPosition(String value) {
    setProperty('background-position', value, '');
  }

  /** Gets the value of "background-position-x" */
  String get backgroundPositionX() =>
    getPropertyValue('background-position-x');

  /** Sets the value of "background-position-x" */
  void set backgroundPositionX(String value) {
    setProperty('background-position-x', value, '');
  }

  /** Gets the value of "background-position-y" */
  String get backgroundPositionY() =>
    getPropertyValue('background-position-y');

  /** Sets the value of "background-position-y" */
  void set backgroundPositionY(String value) {
    setProperty('background-position-y', value, '');
  }

  /** Gets the value of "background-repeat" */
  String get backgroundRepeat() =>
    getPropertyValue('background-repeat');

  /** Sets the value of "background-repeat" */
  void set backgroundRepeat(String value) {
    setProperty('background-repeat', value, '');
  }

  /** Gets the value of "background-repeat-x" */
  String get backgroundRepeatX() =>
    getPropertyValue('background-repeat-x');

  /** Sets the value of "background-repeat-x" */
  void set backgroundRepeatX(String value) {
    setProperty('background-repeat-x', value, '');
  }

  /** Gets the value of "background-repeat-y" */
  String get backgroundRepeatY() =>
    getPropertyValue('background-repeat-y');

  /** Sets the value of "background-repeat-y" */
  void set backgroundRepeatY(String value) {
    setProperty('background-repeat-y', value, '');
  }

  /** Gets the value of "background-size" */
  String get backgroundSize() =>
    getPropertyValue('background-size');

  /** Sets the value of "background-size" */
  void set backgroundSize(String value) {
    setProperty('background-size', value, '');
  }

  /** Gets the value of "border" */
  String get border() =>
    getPropertyValue('border');

  /** Sets the value of "border" */
  void set border(String value) {
    setProperty('border', value, '');
  }

  /** Gets the value of "border-after" */
  String get borderAfter() =>
    getPropertyValue('${_browserPrefix}border-after');

  /** Sets the value of "border-after" */
  void set borderAfter(String value) {
    setProperty('${_browserPrefix}border-after', value, '');
  }

  /** Gets the value of "border-after-color" */
  String get borderAfterColor() =>
    getPropertyValue('${_browserPrefix}border-after-color');

  /** Sets the value of "border-after-color" */
  void set borderAfterColor(String value) {
    setProperty('${_browserPrefix}border-after-color', value, '');
  }

  /** Gets the value of "border-after-style" */
  String get borderAfterStyle() =>
    getPropertyValue('${_browserPrefix}border-after-style');

  /** Sets the value of "border-after-style" */
  void set borderAfterStyle(String value) {
    setProperty('${_browserPrefix}border-after-style', value, '');
  }

  /** Gets the value of "border-after-width" */
  String get borderAfterWidth() =>
    getPropertyValue('${_browserPrefix}border-after-width');

  /** Sets the value of "border-after-width" */
  void set borderAfterWidth(String value) {
    setProperty('${_browserPrefix}border-after-width', value, '');
  }

  /** Gets the value of "border-before" */
  String get borderBefore() =>
    getPropertyValue('${_browserPrefix}border-before');

  /** Sets the value of "border-before" */
  void set borderBefore(String value) {
    setProperty('${_browserPrefix}border-before', value, '');
  }

  /** Gets the value of "border-before-color" */
  String get borderBeforeColor() =>
    getPropertyValue('${_browserPrefix}border-before-color');

  /** Sets the value of "border-before-color" */
  void set borderBeforeColor(String value) {
    setProperty('${_browserPrefix}border-before-color', value, '');
  }

  /** Gets the value of "border-before-style" */
  String get borderBeforeStyle() =>
    getPropertyValue('${_browserPrefix}border-before-style');

  /** Sets the value of "border-before-style" */
  void set borderBeforeStyle(String value) {
    setProperty('${_browserPrefix}border-before-style', value, '');
  }

  /** Gets the value of "border-before-width" */
  String get borderBeforeWidth() =>
    getPropertyValue('${_browserPrefix}border-before-width');

  /** Sets the value of "border-before-width" */
  void set borderBeforeWidth(String value) {
    setProperty('${_browserPrefix}border-before-width', value, '');
  }

  /** Gets the value of "border-bottom" */
  String get borderBottom() =>
    getPropertyValue('border-bottom');

  /** Sets the value of "border-bottom" */
  void set borderBottom(String value) {
    setProperty('border-bottom', value, '');
  }

  /** Gets the value of "border-bottom-color" */
  String get borderBottomColor() =>
    getPropertyValue('border-bottom-color');

  /** Sets the value of "border-bottom-color" */
  void set borderBottomColor(String value) {
    setProperty('border-bottom-color', value, '');
  }

  /** Gets the value of "border-bottom-left-radius" */
  String get borderBottomLeftRadius() =>
    getPropertyValue('border-bottom-left-radius');

  /** Sets the value of "border-bottom-left-radius" */
  void set borderBottomLeftRadius(String value) {
    setProperty('border-bottom-left-radius', value, '');
  }

  /** Gets the value of "border-bottom-right-radius" */
  String get borderBottomRightRadius() =>
    getPropertyValue('border-bottom-right-radius');

  /** Sets the value of "border-bottom-right-radius" */
  void set borderBottomRightRadius(String value) {
    setProperty('border-bottom-right-radius', value, '');
  }

  /** Gets the value of "border-bottom-style" */
  String get borderBottomStyle() =>
    getPropertyValue('border-bottom-style');

  /** Sets the value of "border-bottom-style" */
  void set borderBottomStyle(String value) {
    setProperty('border-bottom-style', value, '');
  }

  /** Gets the value of "border-bottom-width" */
  String get borderBottomWidth() =>
    getPropertyValue('border-bottom-width');

  /** Sets the value of "border-bottom-width" */
  void set borderBottomWidth(String value) {
    setProperty('border-bottom-width', value, '');
  }

  /** Gets the value of "border-collapse" */
  String get borderCollapse() =>
    getPropertyValue('border-collapse');

  /** Sets the value of "border-collapse" */
  void set borderCollapse(String value) {
    setProperty('border-collapse', value, '');
  }

  /** Gets the value of "border-color" */
  String get borderColor() =>
    getPropertyValue('border-color');

  /** Sets the value of "border-color" */
  void set borderColor(String value) {
    setProperty('border-color', value, '');
  }

  /** Gets the value of "border-end" */
  String get borderEnd() =>
    getPropertyValue('${_browserPrefix}border-end');

  /** Sets the value of "border-end" */
  void set borderEnd(String value) {
    setProperty('${_browserPrefix}border-end', value, '');
  }

  /** Gets the value of "border-end-color" */
  String get borderEndColor() =>
    getPropertyValue('${_browserPrefix}border-end-color');

  /** Sets the value of "border-end-color" */
  void set borderEndColor(String value) {
    setProperty('${_browserPrefix}border-end-color', value, '');
  }

  /** Gets the value of "border-end-style" */
  String get borderEndStyle() =>
    getPropertyValue('${_browserPrefix}border-end-style');

  /** Sets the value of "border-end-style" */
  void set borderEndStyle(String value) {
    setProperty('${_browserPrefix}border-end-style', value, '');
  }

  /** Gets the value of "border-end-width" */
  String get borderEndWidth() =>
    getPropertyValue('${_browserPrefix}border-end-width');

  /** Sets the value of "border-end-width" */
  void set borderEndWidth(String value) {
    setProperty('${_browserPrefix}border-end-width', value, '');
  }

  /** Gets the value of "border-fit" */
  String get borderFit() =>
    getPropertyValue('${_browserPrefix}border-fit');

  /** Sets the value of "border-fit" */
  void set borderFit(String value) {
    setProperty('${_browserPrefix}border-fit', value, '');
  }

  /** Gets the value of "border-horizontal-spacing" */
  String get borderHorizontalSpacing() =>
    getPropertyValue('${_browserPrefix}border-horizontal-spacing');

  /** Sets the value of "border-horizontal-spacing" */
  void set borderHorizontalSpacing(String value) {
    setProperty('${_browserPrefix}border-horizontal-spacing', value, '');
  }

  /** Gets the value of "border-image" */
  String get borderImage() =>
    getPropertyValue('border-image');

  /** Sets the value of "border-image" */
  void set borderImage(String value) {
    setProperty('border-image', value, '');
  }

  /** Gets the value of "border-image-outset" */
  String get borderImageOutset() =>
    getPropertyValue('border-image-outset');

  /** Sets the value of "border-image-outset" */
  void set borderImageOutset(String value) {
    setProperty('border-image-outset', value, '');
  }

  /** Gets the value of "border-image-repeat" */
  String get borderImageRepeat() =>
    getPropertyValue('border-image-repeat');

  /** Sets the value of "border-image-repeat" */
  void set borderImageRepeat(String value) {
    setProperty('border-image-repeat', value, '');
  }

  /** Gets the value of "border-image-slice" */
  String get borderImageSlice() =>
    getPropertyValue('border-image-slice');

  /** Sets the value of "border-image-slice" */
  void set borderImageSlice(String value) {
    setProperty('border-image-slice', value, '');
  }

  /** Gets the value of "border-image-source" */
  String get borderImageSource() =>
    getPropertyValue('border-image-source');

  /** Sets the value of "border-image-source" */
  void set borderImageSource(String value) {
    setProperty('border-image-source', value, '');
  }

  /** Gets the value of "border-image-width" */
  String get borderImageWidth() =>
    getPropertyValue('border-image-width');

  /** Sets the value of "border-image-width" */
  void set borderImageWidth(String value) {
    setProperty('border-image-width', value, '');
  }

  /** Gets the value of "border-left" */
  String get borderLeft() =>
    getPropertyValue('border-left');

  /** Sets the value of "border-left" */
  void set borderLeft(String value) {
    setProperty('border-left', value, '');
  }

  /** Gets the value of "border-left-color" */
  String get borderLeftColor() =>
    getPropertyValue('border-left-color');

  /** Sets the value of "border-left-color" */
  void set borderLeftColor(String value) {
    setProperty('border-left-color', value, '');
  }

  /** Gets the value of "border-left-style" */
  String get borderLeftStyle() =>
    getPropertyValue('border-left-style');

  /** Sets the value of "border-left-style" */
  void set borderLeftStyle(String value) {
    setProperty('border-left-style', value, '');
  }

  /** Gets the value of "border-left-width" */
  String get borderLeftWidth() =>
    getPropertyValue('border-left-width');

  /** Sets the value of "border-left-width" */
  void set borderLeftWidth(String value) {
    setProperty('border-left-width', value, '');
  }

  /** Gets the value of "border-radius" */
  String get borderRadius() =>
    getPropertyValue('border-radius');

  /** Sets the value of "border-radius" */
  void set borderRadius(String value) {
    setProperty('border-radius', value, '');
  }

  /** Gets the value of "border-right" */
  String get borderRight() =>
    getPropertyValue('border-right');

  /** Sets the value of "border-right" */
  void set borderRight(String value) {
    setProperty('border-right', value, '');
  }

  /** Gets the value of "border-right-color" */
  String get borderRightColor() =>
    getPropertyValue('border-right-color');

  /** Sets the value of "border-right-color" */
  void set borderRightColor(String value) {
    setProperty('border-right-color', value, '');
  }

  /** Gets the value of "border-right-style" */
  String get borderRightStyle() =>
    getPropertyValue('border-right-style');

  /** Sets the value of "border-right-style" */
  void set borderRightStyle(String value) {
    setProperty('border-right-style', value, '');
  }

  /** Gets the value of "border-right-width" */
  String get borderRightWidth() =>
    getPropertyValue('border-right-width');

  /** Sets the value of "border-right-width" */
  void set borderRightWidth(String value) {
    setProperty('border-right-width', value, '');
  }

  /** Gets the value of "border-spacing" */
  String get borderSpacing() =>
    getPropertyValue('border-spacing');

  /** Sets the value of "border-spacing" */
  void set borderSpacing(String value) {
    setProperty('border-spacing', value, '');
  }

  /** Gets the value of "border-start" */
  String get borderStart() =>
    getPropertyValue('${_browserPrefix}border-start');

  /** Sets the value of "border-start" */
  void set borderStart(String value) {
    setProperty('${_browserPrefix}border-start', value, '');
  }

  /** Gets the value of "border-start-color" */
  String get borderStartColor() =>
    getPropertyValue('${_browserPrefix}border-start-color');

  /** Sets the value of "border-start-color" */
  void set borderStartColor(String value) {
    setProperty('${_browserPrefix}border-start-color', value, '');
  }

  /** Gets the value of "border-start-style" */
  String get borderStartStyle() =>
    getPropertyValue('${_browserPrefix}border-start-style');

  /** Sets the value of "border-start-style" */
  void set borderStartStyle(String value) {
    setProperty('${_browserPrefix}border-start-style', value, '');
  }

  /** Gets the value of "border-start-width" */
  String get borderStartWidth() =>
    getPropertyValue('${_browserPrefix}border-start-width');

  /** Sets the value of "border-start-width" */
  void set borderStartWidth(String value) {
    setProperty('${_browserPrefix}border-start-width', value, '');
  }

  /** Gets the value of "border-style" */
  String get borderStyle() =>
    getPropertyValue('border-style');

  /** Sets the value of "border-style" */
  void set borderStyle(String value) {
    setProperty('border-style', value, '');
  }

  /** Gets the value of "border-top" */
  String get borderTop() =>
    getPropertyValue('border-top');

  /** Sets the value of "border-top" */
  void set borderTop(String value) {
    setProperty('border-top', value, '');
  }

  /** Gets the value of "border-top-color" */
  String get borderTopColor() =>
    getPropertyValue('border-top-color');

  /** Sets the value of "border-top-color" */
  void set borderTopColor(String value) {
    setProperty('border-top-color', value, '');
  }

  /** Gets the value of "border-top-left-radius" */
  String get borderTopLeftRadius() =>
    getPropertyValue('border-top-left-radius');

  /** Sets the value of "border-top-left-radius" */
  void set borderTopLeftRadius(String value) {
    setProperty('border-top-left-radius', value, '');
  }

  /** Gets the value of "border-top-right-radius" */
  String get borderTopRightRadius() =>
    getPropertyValue('border-top-right-radius');

  /** Sets the value of "border-top-right-radius" */
  void set borderTopRightRadius(String value) {
    setProperty('border-top-right-radius', value, '');
  }

  /** Gets the value of "border-top-style" */
  String get borderTopStyle() =>
    getPropertyValue('border-top-style');

  /** Sets the value of "border-top-style" */
  void set borderTopStyle(String value) {
    setProperty('border-top-style', value, '');
  }

  /** Gets the value of "border-top-width" */
  String get borderTopWidth() =>
    getPropertyValue('border-top-width');

  /** Sets the value of "border-top-width" */
  void set borderTopWidth(String value) {
    setProperty('border-top-width', value, '');
  }

  /** Gets the value of "border-vertical-spacing" */
  String get borderVerticalSpacing() =>
    getPropertyValue('${_browserPrefix}border-vertical-spacing');

  /** Sets the value of "border-vertical-spacing" */
  void set borderVerticalSpacing(String value) {
    setProperty('${_browserPrefix}border-vertical-spacing', value, '');
  }

  /** Gets the value of "border-width" */
  String get borderWidth() =>
    getPropertyValue('border-width');

  /** Sets the value of "border-width" */
  void set borderWidth(String value) {
    setProperty('border-width', value, '');
  }

  /** Gets the value of "bottom" */
  String get bottom() =>
    getPropertyValue('bottom');

  /** Sets the value of "bottom" */
  void set bottom(String value) {
    setProperty('bottom', value, '');
  }

  /** Gets the value of "box-align" */
  String get boxAlign() =>
    getPropertyValue('${_browserPrefix}box-align');

  /** Sets the value of "box-align" */
  void set boxAlign(String value) {
    setProperty('${_browserPrefix}box-align', value, '');
  }

  /** Gets the value of "box-direction" */
  String get boxDirection() =>
    getPropertyValue('${_browserPrefix}box-direction');

  /** Sets the value of "box-direction" */
  void set boxDirection(String value) {
    setProperty('${_browserPrefix}box-direction', value, '');
  }

  /** Gets the value of "box-flex" */
  String get boxFlex() =>
    getPropertyValue('${_browserPrefix}box-flex');

  /** Sets the value of "box-flex" */
  void set boxFlex(String value) {
    setProperty('${_browserPrefix}box-flex', value, '');
  }

  /** Gets the value of "box-flex-group" */
  String get boxFlexGroup() =>
    getPropertyValue('${_browserPrefix}box-flex-group');

  /** Sets the value of "box-flex-group" */
  void set boxFlexGroup(String value) {
    setProperty('${_browserPrefix}box-flex-group', value, '');
  }

  /** Gets the value of "box-lines" */
  String get boxLines() =>
    getPropertyValue('${_browserPrefix}box-lines');

  /** Sets the value of "box-lines" */
  void set boxLines(String value) {
    setProperty('${_browserPrefix}box-lines', value, '');
  }

  /** Gets the value of "box-ordinal-group" */
  String get boxOrdinalGroup() =>
    getPropertyValue('${_browserPrefix}box-ordinal-group');

  /** Sets the value of "box-ordinal-group" */
  void set boxOrdinalGroup(String value) {
    setProperty('${_browserPrefix}box-ordinal-group', value, '');
  }

  /** Gets the value of "box-orient" */
  String get boxOrient() =>
    getPropertyValue('${_browserPrefix}box-orient');

  /** Sets the value of "box-orient" */
  void set boxOrient(String value) {
    setProperty('${_browserPrefix}box-orient', value, '');
  }

  /** Gets the value of "box-pack" */
  String get boxPack() =>
    getPropertyValue('${_browserPrefix}box-pack');

  /** Sets the value of "box-pack" */
  void set boxPack(String value) {
    setProperty('${_browserPrefix}box-pack', value, '');
  }

  /** Gets the value of "box-reflect" */
  String get boxReflect() =>
    getPropertyValue('${_browserPrefix}box-reflect');

  /** Sets the value of "box-reflect" */
  void set boxReflect(String value) {
    setProperty('${_browserPrefix}box-reflect', value, '');
  }

  /** Gets the value of "box-shadow" */
  String get boxShadow() =>
    getPropertyValue('box-shadow');

  /** Sets the value of "box-shadow" */
  void set boxShadow(String value) {
    setProperty('box-shadow', value, '');
  }

  /** Gets the value of "box-sizing" */
  String get boxSizing() =>
    getPropertyValue('box-sizing');

  /** Sets the value of "box-sizing" */
  void set boxSizing(String value) {
    setProperty('box-sizing', value, '');
  }

  /** Gets the value of "caption-side" */
  String get captionSide() =>
    getPropertyValue('caption-side');

  /** Sets the value of "caption-side" */
  void set captionSide(String value) {
    setProperty('caption-side', value, '');
  }

  /** Gets the value of "clear" */
  String get clear() =>
    getPropertyValue('clear');

  /** Sets the value of "clear" */
  void set clear(String value) {
    setProperty('clear', value, '');
  }

  /** Gets the value of "clip" */
  String get clip() =>
    getPropertyValue('clip');

  /** Sets the value of "clip" */
  void set clip(String value) {
    setProperty('clip', value, '');
  }

  /** Gets the value of "color" */
  String get color() =>
    getPropertyValue('color');

  /** Sets the value of "color" */
  void set color(String value) {
    setProperty('color', value, '');
  }

  /** Gets the value of "color-correction" */
  String get colorCorrection() =>
    getPropertyValue('${_browserPrefix}color-correction');

  /** Sets the value of "color-correction" */
  void set colorCorrection(String value) {
    setProperty('${_browserPrefix}color-correction', value, '');
  }

  /** Gets the value of "column-break-after" */
  String get columnBreakAfter() =>
    getPropertyValue('${_browserPrefix}column-break-after');

  /** Sets the value of "column-break-after" */
  void set columnBreakAfter(String value) {
    setProperty('${_browserPrefix}column-break-after', value, '');
  }

  /** Gets the value of "column-break-before" */
  String get columnBreakBefore() =>
    getPropertyValue('${_browserPrefix}column-break-before');

  /** Sets the value of "column-break-before" */
  void set columnBreakBefore(String value) {
    setProperty('${_browserPrefix}column-break-before', value, '');
  }

  /** Gets the value of "column-break-inside" */
  String get columnBreakInside() =>
    getPropertyValue('${_browserPrefix}column-break-inside');

  /** Sets the value of "column-break-inside" */
  void set columnBreakInside(String value) {
    setProperty('${_browserPrefix}column-break-inside', value, '');
  }

  /** Gets the value of "column-count" */
  String get columnCount() =>
    getPropertyValue('${_browserPrefix}column-count');

  /** Sets the value of "column-count" */
  void set columnCount(String value) {
    setProperty('${_browserPrefix}column-count', value, '');
  }

  /** Gets the value of "column-gap" */
  String get columnGap() =>
    getPropertyValue('${_browserPrefix}column-gap');

  /** Sets the value of "column-gap" */
  void set columnGap(String value) {
    setProperty('${_browserPrefix}column-gap', value, '');
  }

  /** Gets the value of "column-rule" */
  String get columnRule() =>
    getPropertyValue('${_browserPrefix}column-rule');

  /** Sets the value of "column-rule" */
  void set columnRule(String value) {
    setProperty('${_browserPrefix}column-rule', value, '');
  }

  /** Gets the value of "column-rule-color" */
  String get columnRuleColor() =>
    getPropertyValue('${_browserPrefix}column-rule-color');

  /** Sets the value of "column-rule-color" */
  void set columnRuleColor(String value) {
    setProperty('${_browserPrefix}column-rule-color', value, '');
  }

  /** Gets the value of "column-rule-style" */
  String get columnRuleStyle() =>
    getPropertyValue('${_browserPrefix}column-rule-style');

  /** Sets the value of "column-rule-style" */
  void set columnRuleStyle(String value) {
    setProperty('${_browserPrefix}column-rule-style', value, '');
  }

  /** Gets the value of "column-rule-width" */
  String get columnRuleWidth() =>
    getPropertyValue('${_browserPrefix}column-rule-width');

  /** Sets the value of "column-rule-width" */
  void set columnRuleWidth(String value) {
    setProperty('${_browserPrefix}column-rule-width', value, '');
  }

  /** Gets the value of "column-span" */
  String get columnSpan() =>
    getPropertyValue('${_browserPrefix}column-span');

  /** Sets the value of "column-span" */
  void set columnSpan(String value) {
    setProperty('${_browserPrefix}column-span', value, '');
  }

  /** Gets the value of "column-width" */
  String get columnWidth() =>
    getPropertyValue('${_browserPrefix}column-width');

  /** Sets the value of "column-width" */
  void set columnWidth(String value) {
    setProperty('${_browserPrefix}column-width', value, '');
  }

  /** Gets the value of "columns" */
  String get columns() =>
    getPropertyValue('${_browserPrefix}columns');

  /** Sets the value of "columns" */
  void set columns(String value) {
    setProperty('${_browserPrefix}columns', value, '');
  }

  /** Gets the value of "content" */
  String get content() =>
    getPropertyValue('content');

  /** Sets the value of "content" */
  void set content(String value) {
    setProperty('content', value, '');
  }

  /** Gets the value of "counter-increment" */
  String get counterIncrement() =>
    getPropertyValue('counter-increment');

  /** Sets the value of "counter-increment" */
  void set counterIncrement(String value) {
    setProperty('counter-increment', value, '');
  }

  /** Gets the value of "counter-reset" */
  String get counterReset() =>
    getPropertyValue('counter-reset');

  /** Sets the value of "counter-reset" */
  void set counterReset(String value) {
    setProperty('counter-reset', value, '');
  }

  /** Gets the value of "cursor" */
  String get cursor() =>
    getPropertyValue('cursor');

  /** Sets the value of "cursor" */
  void set cursor(String value) {
    setProperty('cursor', value, '');
  }

  /** Gets the value of "direction" */
  String get direction() =>
    getPropertyValue('direction');

  /** Sets the value of "direction" */
  void set direction(String value) {
    setProperty('direction', value, '');
  }

  /** Gets the value of "display" */
  String get display() =>
    getPropertyValue('display');

  /** Sets the value of "display" */
  void set display(String value) {
    setProperty('display', value, '');
  }

  /** Gets the value of "empty-cells" */
  String get emptyCells() =>
    getPropertyValue('empty-cells');

  /** Sets the value of "empty-cells" */
  void set emptyCells(String value) {
    setProperty('empty-cells', value, '');
  }

  /** Gets the value of "filter" */
  String get filter() =>
    getPropertyValue('${_browserPrefix}filter');

  /** Sets the value of "filter" */
  void set filter(String value) {
    setProperty('${_browserPrefix}filter', value, '');
  }

  /** Gets the value of "flex-align" */
  String get flexAlign() =>
    getPropertyValue('${_browserPrefix}flex-align');

  /** Sets the value of "flex-align" */
  void set flexAlign(String value) {
    setProperty('${_browserPrefix}flex-align', value, '');
  }

  /** Gets the value of "flex-flow" */
  String get flexFlow() =>
    getPropertyValue('${_browserPrefix}flex-flow');

  /** Sets the value of "flex-flow" */
  void set flexFlow(String value) {
    setProperty('${_browserPrefix}flex-flow', value, '');
  }

  /** Gets the value of "flex-order" */
  String get flexOrder() =>
    getPropertyValue('${_browserPrefix}flex-order');

  /** Sets the value of "flex-order" */
  void set flexOrder(String value) {
    setProperty('${_browserPrefix}flex-order', value, '');
  }

  /** Gets the value of "flex-pack" */
  String get flexPack() =>
    getPropertyValue('${_browserPrefix}flex-pack');

  /** Sets the value of "flex-pack" */
  void set flexPack(String value) {
    setProperty('${_browserPrefix}flex-pack', value, '');
  }

  /** Gets the value of "float" */
  String get float() =>
    getPropertyValue('float');

  /** Sets the value of "float" */
  void set float(String value) {
    setProperty('float', value, '');
  }

  /** Gets the value of "flow-from" */
  String get flowFrom() =>
    getPropertyValue('${_browserPrefix}flow-from');

  /** Sets the value of "flow-from" */
  void set flowFrom(String value) {
    setProperty('${_browserPrefix}flow-from', value, '');
  }

  /** Gets the value of "flow-into" */
  String get flowInto() =>
    getPropertyValue('${_browserPrefix}flow-into');

  /** Sets the value of "flow-into" */
  void set flowInto(String value) {
    setProperty('${_browserPrefix}flow-into', value, '');
  }

  /** Gets the value of "font" */
  String get font() =>
    getPropertyValue('font');

  /** Sets the value of "font" */
  void set font(String value) {
    setProperty('font', value, '');
  }

  /** Gets the value of "font-family" */
  String get fontFamily() =>
    getPropertyValue('font-family');

  /** Sets the value of "font-family" */
  void set fontFamily(String value) {
    setProperty('font-family', value, '');
  }

  /** Gets the value of "font-feature-settings" */
  String get fontFeatureSettings() =>
    getPropertyValue('${_browserPrefix}font-feature-settings');

  /** Sets the value of "font-feature-settings" */
  void set fontFeatureSettings(String value) {
    setProperty('${_browserPrefix}font-feature-settings', value, '');
  }

  /** Gets the value of "font-size" */
  String get fontSize() =>
    getPropertyValue('font-size');

  /** Sets the value of "font-size" */
  void set fontSize(String value) {
    setProperty('font-size', value, '');
  }

  /** Gets the value of "font-size-delta" */
  String get fontSizeDelta() =>
    getPropertyValue('${_browserPrefix}font-size-delta');

  /** Sets the value of "font-size-delta" */
  void set fontSizeDelta(String value) {
    setProperty('${_browserPrefix}font-size-delta', value, '');
  }

  /** Gets the value of "font-smoothing" */
  String get fontSmoothing() =>
    getPropertyValue('${_browserPrefix}font-smoothing');

  /** Sets the value of "font-smoothing" */
  void set fontSmoothing(String value) {
    setProperty('${_browserPrefix}font-smoothing', value, '');
  }

  /** Gets the value of "font-stretch" */
  String get fontStretch() =>
    getPropertyValue('font-stretch');

  /** Sets the value of "font-stretch" */
  void set fontStretch(String value) {
    setProperty('font-stretch', value, '');
  }

  /** Gets the value of "font-style" */
  String get fontStyle() =>
    getPropertyValue('font-style');

  /** Sets the value of "font-style" */
  void set fontStyle(String value) {
    setProperty('font-style', value, '');
  }

  /** Gets the value of "font-variant" */
  String get fontVariant() =>
    getPropertyValue('font-variant');

  /** Sets the value of "font-variant" */
  void set fontVariant(String value) {
    setProperty('font-variant', value, '');
  }

  /** Gets the value of "font-weight" */
  String get fontWeight() =>
    getPropertyValue('font-weight');

  /** Sets the value of "font-weight" */
  void set fontWeight(String value) {
    setProperty('font-weight', value, '');
  }

  /** Gets the value of "height" */
  String get height() =>
    getPropertyValue('height');

  /** Sets the value of "height" */
  void set height(String value) {
    setProperty('height', value, '');
  }

  /** Gets the value of "highlight" */
  String get highlight() =>
    getPropertyValue('${_browserPrefix}highlight');

  /** Sets the value of "highlight" */
  void set highlight(String value) {
    setProperty('${_browserPrefix}highlight', value, '');
  }

  /** Gets the value of "hyphenate-character" */
  String get hyphenateCharacter() =>
    getPropertyValue('${_browserPrefix}hyphenate-character');

  /** Sets the value of "hyphenate-character" */
  void set hyphenateCharacter(String value) {
    setProperty('${_browserPrefix}hyphenate-character', value, '');
  }

  /** Gets the value of "hyphenate-limit-after" */
  String get hyphenateLimitAfter() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-after');

  /** Sets the value of "hyphenate-limit-after" */
  void set hyphenateLimitAfter(String value) {
    setProperty('${_browserPrefix}hyphenate-limit-after', value, '');
  }

  /** Gets the value of "hyphenate-limit-before" */
  String get hyphenateLimitBefore() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-before');

  /** Sets the value of "hyphenate-limit-before" */
  void set hyphenateLimitBefore(String value) {
    setProperty('${_browserPrefix}hyphenate-limit-before', value, '');
  }

  /** Gets the value of "hyphenate-limit-lines" */
  String get hyphenateLimitLines() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-lines');

  /** Sets the value of "hyphenate-limit-lines" */
  void set hyphenateLimitLines(String value) {
    setProperty('${_browserPrefix}hyphenate-limit-lines', value, '');
  }

  /** Gets the value of "hyphens" */
  String get hyphens() =>
    getPropertyValue('${_browserPrefix}hyphens');

  /** Sets the value of "hyphens" */
  void set hyphens(String value) {
    setProperty('${_browserPrefix}hyphens', value, '');
  }

  /** Gets the value of "image-rendering" */
  String get imageRendering() =>
    getPropertyValue('image-rendering');

  /** Sets the value of "image-rendering" */
  void set imageRendering(String value) {
    setProperty('image-rendering', value, '');
  }

  /** Gets the value of "left" */
  String get left() =>
    getPropertyValue('left');

  /** Sets the value of "left" */
  void set left(String value) {
    setProperty('left', value, '');
  }

  /** Gets the value of "letter-spacing" */
  String get letterSpacing() =>
    getPropertyValue('letter-spacing');

  /** Sets the value of "letter-spacing" */
  void set letterSpacing(String value) {
    setProperty('letter-spacing', value, '');
  }

  /** Gets the value of "line-box-contain" */
  String get lineBoxContain() =>
    getPropertyValue('${_browserPrefix}line-box-contain');

  /** Sets the value of "line-box-contain" */
  void set lineBoxContain(String value) {
    setProperty('${_browserPrefix}line-box-contain', value, '');
  }

  /** Gets the value of "line-break" */
  String get lineBreak() =>
    getPropertyValue('${_browserPrefix}line-break');

  /** Sets the value of "line-break" */
  void set lineBreak(String value) {
    setProperty('${_browserPrefix}line-break', value, '');
  }

  /** Gets the value of "line-clamp" */
  String get lineClamp() =>
    getPropertyValue('${_browserPrefix}line-clamp');

  /** Sets the value of "line-clamp" */
  void set lineClamp(String value) {
    setProperty('${_browserPrefix}line-clamp', value, '');
  }

  /** Gets the value of "line-height" */
  String get lineHeight() =>
    getPropertyValue('line-height');

  /** Sets the value of "line-height" */
  void set lineHeight(String value) {
    setProperty('line-height', value, '');
  }

  /** Gets the value of "list-style" */
  String get listStyle() =>
    getPropertyValue('list-style');

  /** Sets the value of "list-style" */
  void set listStyle(String value) {
    setProperty('list-style', value, '');
  }

  /** Gets the value of "list-style-image" */
  String get listStyleImage() =>
    getPropertyValue('list-style-image');

  /** Sets the value of "list-style-image" */
  void set listStyleImage(String value) {
    setProperty('list-style-image', value, '');
  }

  /** Gets the value of "list-style-position" */
  String get listStylePosition() =>
    getPropertyValue('list-style-position');

  /** Sets the value of "list-style-position" */
  void set listStylePosition(String value) {
    setProperty('list-style-position', value, '');
  }

  /** Gets the value of "list-style-type" */
  String get listStyleType() =>
    getPropertyValue('list-style-type');

  /** Sets the value of "list-style-type" */
  void set listStyleType(String value) {
    setProperty('list-style-type', value, '');
  }

  /** Gets the value of "locale" */
  String get locale() =>
    getPropertyValue('${_browserPrefix}locale');

  /** Sets the value of "locale" */
  void set locale(String value) {
    setProperty('${_browserPrefix}locale', value, '');
  }

  /** Gets the value of "logical-height" */
  String get logicalHeight() =>
    getPropertyValue('${_browserPrefix}logical-height');

  /** Sets the value of "logical-height" */
  void set logicalHeight(String value) {
    setProperty('${_browserPrefix}logical-height', value, '');
  }

  /** Gets the value of "logical-width" */
  String get logicalWidth() =>
    getPropertyValue('${_browserPrefix}logical-width');

  /** Sets the value of "logical-width" */
  void set logicalWidth(String value) {
    setProperty('${_browserPrefix}logical-width', value, '');
  }

  /** Gets the value of "margin" */
  String get margin() =>
    getPropertyValue('margin');

  /** Sets the value of "margin" */
  void set margin(String value) {
    setProperty('margin', value, '');
  }

  /** Gets the value of "margin-after" */
  String get marginAfter() =>
    getPropertyValue('${_browserPrefix}margin-after');

  /** Sets the value of "margin-after" */
  void set marginAfter(String value) {
    setProperty('${_browserPrefix}margin-after', value, '');
  }

  /** Gets the value of "margin-after-collapse" */
  String get marginAfterCollapse() =>
    getPropertyValue('${_browserPrefix}margin-after-collapse');

  /** Sets the value of "margin-after-collapse" */
  void set marginAfterCollapse(String value) {
    setProperty('${_browserPrefix}margin-after-collapse', value, '');
  }

  /** Gets the value of "margin-before" */
  String get marginBefore() =>
    getPropertyValue('${_browserPrefix}margin-before');

  /** Sets the value of "margin-before" */
  void set marginBefore(String value) {
    setProperty('${_browserPrefix}margin-before', value, '');
  }

  /** Gets the value of "margin-before-collapse" */
  String get marginBeforeCollapse() =>
    getPropertyValue('${_browserPrefix}margin-before-collapse');

  /** Sets the value of "margin-before-collapse" */
  void set marginBeforeCollapse(String value) {
    setProperty('${_browserPrefix}margin-before-collapse', value, '');
  }

  /** Gets the value of "margin-bottom" */
  String get marginBottom() =>
    getPropertyValue('margin-bottom');

  /** Sets the value of "margin-bottom" */
  void set marginBottom(String value) {
    setProperty('margin-bottom', value, '');
  }

  /** Gets the value of "margin-bottom-collapse" */
  String get marginBottomCollapse() =>
    getPropertyValue('${_browserPrefix}margin-bottom-collapse');

  /** Sets the value of "margin-bottom-collapse" */
  void set marginBottomCollapse(String value) {
    setProperty('${_browserPrefix}margin-bottom-collapse', value, '');
  }

  /** Gets the value of "margin-collapse" */
  String get marginCollapse() =>
    getPropertyValue('${_browserPrefix}margin-collapse');

  /** Sets the value of "margin-collapse" */
  void set marginCollapse(String value) {
    setProperty('${_browserPrefix}margin-collapse', value, '');
  }

  /** Gets the value of "margin-end" */
  String get marginEnd() =>
    getPropertyValue('${_browserPrefix}margin-end');

  /** Sets the value of "margin-end" */
  void set marginEnd(String value) {
    setProperty('${_browserPrefix}margin-end', value, '');
  }

  /** Gets the value of "margin-left" */
  String get marginLeft() =>
    getPropertyValue('margin-left');

  /** Sets the value of "margin-left" */
  void set marginLeft(String value) {
    setProperty('margin-left', value, '');
  }

  /** Gets the value of "margin-right" */
  String get marginRight() =>
    getPropertyValue('margin-right');

  /** Sets the value of "margin-right" */
  void set marginRight(String value) {
    setProperty('margin-right', value, '');
  }

  /** Gets the value of "margin-start" */
  String get marginStart() =>
    getPropertyValue('${_browserPrefix}margin-start');

  /** Sets the value of "margin-start" */
  void set marginStart(String value) {
    setProperty('${_browserPrefix}margin-start', value, '');
  }

  /** Gets the value of "margin-top" */
  String get marginTop() =>
    getPropertyValue('margin-top');

  /** Sets the value of "margin-top" */
  void set marginTop(String value) {
    setProperty('margin-top', value, '');
  }

  /** Gets the value of "margin-top-collapse" */
  String get marginTopCollapse() =>
    getPropertyValue('${_browserPrefix}margin-top-collapse');

  /** Sets the value of "margin-top-collapse" */
  void set marginTopCollapse(String value) {
    setProperty('${_browserPrefix}margin-top-collapse', value, '');
  }

  /** Gets the value of "marquee" */
  String get marquee() =>
    getPropertyValue('${_browserPrefix}marquee');

  /** Sets the value of "marquee" */
  void set marquee(String value) {
    setProperty('${_browserPrefix}marquee', value, '');
  }

  /** Gets the value of "marquee-direction" */
  String get marqueeDirection() =>
    getPropertyValue('${_browserPrefix}marquee-direction');

  /** Sets the value of "marquee-direction" */
  void set marqueeDirection(String value) {
    setProperty('${_browserPrefix}marquee-direction', value, '');
  }

  /** Gets the value of "marquee-increment" */
  String get marqueeIncrement() =>
    getPropertyValue('${_browserPrefix}marquee-increment');

  /** Sets the value of "marquee-increment" */
  void set marqueeIncrement(String value) {
    setProperty('${_browserPrefix}marquee-increment', value, '');
  }

  /** Gets the value of "marquee-repetition" */
  String get marqueeRepetition() =>
    getPropertyValue('${_browserPrefix}marquee-repetition');

  /** Sets the value of "marquee-repetition" */
  void set marqueeRepetition(String value) {
    setProperty('${_browserPrefix}marquee-repetition', value, '');
  }

  /** Gets the value of "marquee-speed" */
  String get marqueeSpeed() =>
    getPropertyValue('${_browserPrefix}marquee-speed');

  /** Sets the value of "marquee-speed" */
  void set marqueeSpeed(String value) {
    setProperty('${_browserPrefix}marquee-speed', value, '');
  }

  /** Gets the value of "marquee-style" */
  String get marqueeStyle() =>
    getPropertyValue('${_browserPrefix}marquee-style');

  /** Sets the value of "marquee-style" */
  void set marqueeStyle(String value) {
    setProperty('${_browserPrefix}marquee-style', value, '');
  }

  /** Gets the value of "mask" */
  String get mask() =>
    getPropertyValue('${_browserPrefix}mask');

  /** Sets the value of "mask" */
  void set mask(String value) {
    setProperty('${_browserPrefix}mask', value, '');
  }

  /** Gets the value of "mask-attachment" */
  String get maskAttachment() =>
    getPropertyValue('${_browserPrefix}mask-attachment');

  /** Sets the value of "mask-attachment" */
  void set maskAttachment(String value) {
    setProperty('${_browserPrefix}mask-attachment', value, '');
  }

  /** Gets the value of "mask-box-image" */
  String get maskBoxImage() =>
    getPropertyValue('${_browserPrefix}mask-box-image');

  /** Sets the value of "mask-box-image" */
  void set maskBoxImage(String value) {
    setProperty('${_browserPrefix}mask-box-image', value, '');
  }

  /** Gets the value of "mask-box-image-outset" */
  String get maskBoxImageOutset() =>
    getPropertyValue('${_browserPrefix}mask-box-image-outset');

  /** Sets the value of "mask-box-image-outset" */
  void set maskBoxImageOutset(String value) {
    setProperty('${_browserPrefix}mask-box-image-outset', value, '');
  }

  /** Gets the value of "mask-box-image-repeat" */
  String get maskBoxImageRepeat() =>
    getPropertyValue('${_browserPrefix}mask-box-image-repeat');

  /** Sets the value of "mask-box-image-repeat" */
  void set maskBoxImageRepeat(String value) {
    setProperty('${_browserPrefix}mask-box-image-repeat', value, '');
  }

  /** Gets the value of "mask-box-image-slice" */
  String get maskBoxImageSlice() =>
    getPropertyValue('${_browserPrefix}mask-box-image-slice');

  /** Sets the value of "mask-box-image-slice" */
  void set maskBoxImageSlice(String value) {
    setProperty('${_browserPrefix}mask-box-image-slice', value, '');
  }

  /** Gets the value of "mask-box-image-source" */
  String get maskBoxImageSource() =>
    getPropertyValue('${_browserPrefix}mask-box-image-source');

  /** Sets the value of "mask-box-image-source" */
  void set maskBoxImageSource(String value) {
    setProperty('${_browserPrefix}mask-box-image-source', value, '');
  }

  /** Gets the value of "mask-box-image-width" */
  String get maskBoxImageWidth() =>
    getPropertyValue('${_browserPrefix}mask-box-image-width');

  /** Sets the value of "mask-box-image-width" */
  void set maskBoxImageWidth(String value) {
    setProperty('${_browserPrefix}mask-box-image-width', value, '');
  }

  /** Gets the value of "mask-clip" */
  String get maskClip() =>
    getPropertyValue('${_browserPrefix}mask-clip');

  /** Sets the value of "mask-clip" */
  void set maskClip(String value) {
    setProperty('${_browserPrefix}mask-clip', value, '');
  }

  /** Gets the value of "mask-composite" */
  String get maskComposite() =>
    getPropertyValue('${_browserPrefix}mask-composite');

  /** Sets the value of "mask-composite" */
  void set maskComposite(String value) {
    setProperty('${_browserPrefix}mask-composite', value, '');
  }

  /** Gets the value of "mask-image" */
  String get maskImage() =>
    getPropertyValue('${_browserPrefix}mask-image');

  /** Sets the value of "mask-image" */
  void set maskImage(String value) {
    setProperty('${_browserPrefix}mask-image', value, '');
  }

  /** Gets the value of "mask-origin" */
  String get maskOrigin() =>
    getPropertyValue('${_browserPrefix}mask-origin');

  /** Sets the value of "mask-origin" */
  void set maskOrigin(String value) {
    setProperty('${_browserPrefix}mask-origin', value, '');
  }

  /** Gets the value of "mask-position" */
  String get maskPosition() =>
    getPropertyValue('${_browserPrefix}mask-position');

  /** Sets the value of "mask-position" */
  void set maskPosition(String value) {
    setProperty('${_browserPrefix}mask-position', value, '');
  }

  /** Gets the value of "mask-position-x" */
  String get maskPositionX() =>
    getPropertyValue('${_browserPrefix}mask-position-x');

  /** Sets the value of "mask-position-x" */
  void set maskPositionX(String value) {
    setProperty('${_browserPrefix}mask-position-x', value, '');
  }

  /** Gets the value of "mask-position-y" */
  String get maskPositionY() =>
    getPropertyValue('${_browserPrefix}mask-position-y');

  /** Sets the value of "mask-position-y" */
  void set maskPositionY(String value) {
    setProperty('${_browserPrefix}mask-position-y', value, '');
  }

  /** Gets the value of "mask-repeat" */
  String get maskRepeat() =>
    getPropertyValue('${_browserPrefix}mask-repeat');

  /** Sets the value of "mask-repeat" */
  void set maskRepeat(String value) {
    setProperty('${_browserPrefix}mask-repeat', value, '');
  }

  /** Gets the value of "mask-repeat-x" */
  String get maskRepeatX() =>
    getPropertyValue('${_browserPrefix}mask-repeat-x');

  /** Sets the value of "mask-repeat-x" */
  void set maskRepeatX(String value) {
    setProperty('${_browserPrefix}mask-repeat-x', value, '');
  }

  /** Gets the value of "mask-repeat-y" */
  String get maskRepeatY() =>
    getPropertyValue('${_browserPrefix}mask-repeat-y');

  /** Sets the value of "mask-repeat-y" */
  void set maskRepeatY(String value) {
    setProperty('${_browserPrefix}mask-repeat-y', value, '');
  }

  /** Gets the value of "mask-size" */
  String get maskSize() =>
    getPropertyValue('${_browserPrefix}mask-size');

  /** Sets the value of "mask-size" */
  void set maskSize(String value) {
    setProperty('${_browserPrefix}mask-size', value, '');
  }

  /** Gets the value of "match-nearest-mail-blockquote-color" */
  String get matchNearestMailBlockquoteColor() =>
    getPropertyValue('${_browserPrefix}match-nearest-mail-blockquote-color');

  /** Sets the value of "match-nearest-mail-blockquote-color" */
  void set matchNearestMailBlockquoteColor(String value) {
    setProperty('${_browserPrefix}match-nearest-mail-blockquote-color', value, '');
  }

  /** Gets the value of "max-height" */
  String get maxHeight() =>
    getPropertyValue('max-height');

  /** Sets the value of "max-height" */
  void set maxHeight(String value) {
    setProperty('max-height', value, '');
  }

  /** Gets the value of "max-logical-height" */
  String get maxLogicalHeight() =>
    getPropertyValue('${_browserPrefix}max-logical-height');

  /** Sets the value of "max-logical-height" */
  void set maxLogicalHeight(String value) {
    setProperty('${_browserPrefix}max-logical-height', value, '');
  }

  /** Gets the value of "max-logical-width" */
  String get maxLogicalWidth() =>
    getPropertyValue('${_browserPrefix}max-logical-width');

  /** Sets the value of "max-logical-width" */
  void set maxLogicalWidth(String value) {
    setProperty('${_browserPrefix}max-logical-width', value, '');
  }

  /** Gets the value of "max-width" */
  String get maxWidth() =>
    getPropertyValue('max-width');

  /** Sets the value of "max-width" */
  void set maxWidth(String value) {
    setProperty('max-width', value, '');
  }

  /** Gets the value of "min-height" */
  String get minHeight() =>
    getPropertyValue('min-height');

  /** Sets the value of "min-height" */
  void set minHeight(String value) {
    setProperty('min-height', value, '');
  }

  /** Gets the value of "min-logical-height" */
  String get minLogicalHeight() =>
    getPropertyValue('${_browserPrefix}min-logical-height');

  /** Sets the value of "min-logical-height" */
  void set minLogicalHeight(String value) {
    setProperty('${_browserPrefix}min-logical-height', value, '');
  }

  /** Gets the value of "min-logical-width" */
  String get minLogicalWidth() =>
    getPropertyValue('${_browserPrefix}min-logical-width');

  /** Sets the value of "min-logical-width" */
  void set minLogicalWidth(String value) {
    setProperty('${_browserPrefix}min-logical-width', value, '');
  }

  /** Gets the value of "min-width" */
  String get minWidth() =>
    getPropertyValue('min-width');

  /** Sets the value of "min-width" */
  void set minWidth(String value) {
    setProperty('min-width', value, '');
  }

  /** Gets the value of "nbsp-mode" */
  String get nbspMode() =>
    getPropertyValue('${_browserPrefix}nbsp-mode');

  /** Sets the value of "nbsp-mode" */
  void set nbspMode(String value) {
    setProperty('${_browserPrefix}nbsp-mode', value, '');
  }

  /** Gets the value of "opacity" */
  String get opacity() =>
    getPropertyValue('opacity');

  /** Sets the value of "opacity" */
  void set opacity(String value) {
    setProperty('opacity', value, '');
  }

  /** Gets the value of "orphans" */
  String get orphans() =>
    getPropertyValue('orphans');

  /** Sets the value of "orphans" */
  void set orphans(String value) {
    setProperty('orphans', value, '');
  }

  /** Gets the value of "outline" */
  String get outline() =>
    getPropertyValue('outline');

  /** Sets the value of "outline" */
  void set outline(String value) {
    setProperty('outline', value, '');
  }

  /** Gets the value of "outline-color" */
  String get outlineColor() =>
    getPropertyValue('outline-color');

  /** Sets the value of "outline-color" */
  void set outlineColor(String value) {
    setProperty('outline-color', value, '');
  }

  /** Gets the value of "outline-offset" */
  String get outlineOffset() =>
    getPropertyValue('outline-offset');

  /** Sets the value of "outline-offset" */
  void set outlineOffset(String value) {
    setProperty('outline-offset', value, '');
  }

  /** Gets the value of "outline-style" */
  String get outlineStyle() =>
    getPropertyValue('outline-style');

  /** Sets the value of "outline-style" */
  void set outlineStyle(String value) {
    setProperty('outline-style', value, '');
  }

  /** Gets the value of "outline-width" */
  String get outlineWidth() =>
    getPropertyValue('outline-width');

  /** Sets the value of "outline-width" */
  void set outlineWidth(String value) {
    setProperty('outline-width', value, '');
  }

  /** Gets the value of "overflow" */
  String get overflow() =>
    getPropertyValue('overflow');

  /** Sets the value of "overflow" */
  void set overflow(String value) {
    setProperty('overflow', value, '');
  }

  /** Gets the value of "overflow-x" */
  String get overflowX() =>
    getPropertyValue('overflow-x');

  /** Sets the value of "overflow-x" */
  void set overflowX(String value) {
    setProperty('overflow-x', value, '');
  }

  /** Gets the value of "overflow-y" */
  String get overflowY() =>
    getPropertyValue('overflow-y');

  /** Sets the value of "overflow-y" */
  void set overflowY(String value) {
    setProperty('overflow-y', value, '');
  }

  /** Gets the value of "padding" */
  String get padding() =>
    getPropertyValue('padding');

  /** Sets the value of "padding" */
  void set padding(String value) {
    setProperty('padding', value, '');
  }

  /** Gets the value of "padding-after" */
  String get paddingAfter() =>
    getPropertyValue('${_browserPrefix}padding-after');

  /** Sets the value of "padding-after" */
  void set paddingAfter(String value) {
    setProperty('${_browserPrefix}padding-after', value, '');
  }

  /** Gets the value of "padding-before" */
  String get paddingBefore() =>
    getPropertyValue('${_browserPrefix}padding-before');

  /** Sets the value of "padding-before" */
  void set paddingBefore(String value) {
    setProperty('${_browserPrefix}padding-before', value, '');
  }

  /** Gets the value of "padding-bottom" */
  String get paddingBottom() =>
    getPropertyValue('padding-bottom');

  /** Sets the value of "padding-bottom" */
  void set paddingBottom(String value) {
    setProperty('padding-bottom', value, '');
  }

  /** Gets the value of "padding-end" */
  String get paddingEnd() =>
    getPropertyValue('${_browserPrefix}padding-end');

  /** Sets the value of "padding-end" */
  void set paddingEnd(String value) {
    setProperty('${_browserPrefix}padding-end', value, '');
  }

  /** Gets the value of "padding-left" */
  String get paddingLeft() =>
    getPropertyValue('padding-left');

  /** Sets the value of "padding-left" */
  void set paddingLeft(String value) {
    setProperty('padding-left', value, '');
  }

  /** Gets the value of "padding-right" */
  String get paddingRight() =>
    getPropertyValue('padding-right');

  /** Sets the value of "padding-right" */
  void set paddingRight(String value) {
    setProperty('padding-right', value, '');
  }

  /** Gets the value of "padding-start" */
  String get paddingStart() =>
    getPropertyValue('${_browserPrefix}padding-start');

  /** Sets the value of "padding-start" */
  void set paddingStart(String value) {
    setProperty('${_browserPrefix}padding-start', value, '');
  }

  /** Gets the value of "padding-top" */
  String get paddingTop() =>
    getPropertyValue('padding-top');

  /** Sets the value of "padding-top" */
  void set paddingTop(String value) {
    setProperty('padding-top', value, '');
  }

  /** Gets the value of "page" */
  String get page() =>
    getPropertyValue('page');

  /** Sets the value of "page" */
  void set page(String value) {
    setProperty('page', value, '');
  }

  /** Gets the value of "page-break-after" */
  String get pageBreakAfter() =>
    getPropertyValue('page-break-after');

  /** Sets the value of "page-break-after" */
  void set pageBreakAfter(String value) {
    setProperty('page-break-after', value, '');
  }

  /** Gets the value of "page-break-before" */
  String get pageBreakBefore() =>
    getPropertyValue('page-break-before');

  /** Sets the value of "page-break-before" */
  void set pageBreakBefore(String value) {
    setProperty('page-break-before', value, '');
  }

  /** Gets the value of "page-break-inside" */
  String get pageBreakInside() =>
    getPropertyValue('page-break-inside');

  /** Sets the value of "page-break-inside" */
  void set pageBreakInside(String value) {
    setProperty('page-break-inside', value, '');
  }

  /** Gets the value of "perspective" */
  String get perspective() =>
    getPropertyValue('${_browserPrefix}perspective');

  /** Sets the value of "perspective" */
  void set perspective(String value) {
    setProperty('${_browserPrefix}perspective', value, '');
  }

  /** Gets the value of "perspective-origin" */
  String get perspectiveOrigin() =>
    getPropertyValue('${_browserPrefix}perspective-origin');

  /** Sets the value of "perspective-origin" */
  void set perspectiveOrigin(String value) {
    setProperty('${_browserPrefix}perspective-origin', value, '');
  }

  /** Gets the value of "perspective-origin-x" */
  String get perspectiveOriginX() =>
    getPropertyValue('${_browserPrefix}perspective-origin-x');

  /** Sets the value of "perspective-origin-x" */
  void set perspectiveOriginX(String value) {
    setProperty('${_browserPrefix}perspective-origin-x', value, '');
  }

  /** Gets the value of "perspective-origin-y" */
  String get perspectiveOriginY() =>
    getPropertyValue('${_browserPrefix}perspective-origin-y');

  /** Sets the value of "perspective-origin-y" */
  void set perspectiveOriginY(String value) {
    setProperty('${_browserPrefix}perspective-origin-y', value, '');
  }

  /** Gets the value of "pointer-events" */
  String get pointerEvents() =>
    getPropertyValue('pointer-events');

  /** Sets the value of "pointer-events" */
  void set pointerEvents(String value) {
    setProperty('pointer-events', value, '');
  }

  /** Gets the value of "position" */
  String get position() =>
    getPropertyValue('position');

  /** Sets the value of "position" */
  void set position(String value) {
    setProperty('position', value, '');
  }

  /** Gets the value of "quotes" */
  String get quotes() =>
    getPropertyValue('quotes');

  /** Sets the value of "quotes" */
  void set quotes(String value) {
    setProperty('quotes', value, '');
  }

  /** Gets the value of "region-break-after" */
  String get regionBreakAfter() =>
    getPropertyValue('${_browserPrefix}region-break-after');

  /** Sets the value of "region-break-after" */
  void set regionBreakAfter(String value) {
    setProperty('${_browserPrefix}region-break-after', value, '');
  }

  /** Gets the value of "region-break-before" */
  String get regionBreakBefore() =>
    getPropertyValue('${_browserPrefix}region-break-before');

  /** Sets the value of "region-break-before" */
  void set regionBreakBefore(String value) {
    setProperty('${_browserPrefix}region-break-before', value, '');
  }

  /** Gets the value of "region-break-inside" */
  String get regionBreakInside() =>
    getPropertyValue('${_browserPrefix}region-break-inside');

  /** Sets the value of "region-break-inside" */
  void set regionBreakInside(String value) {
    setProperty('${_browserPrefix}region-break-inside', value, '');
  }

  /** Gets the value of "region-overflow" */
  String get regionOverflow() =>
    getPropertyValue('${_browserPrefix}region-overflow');

  /** Sets the value of "region-overflow" */
  void set regionOverflow(String value) {
    setProperty('${_browserPrefix}region-overflow', value, '');
  }

  /** Gets the value of "resize" */
  String get resize() =>
    getPropertyValue('resize');

  /** Sets the value of "resize" */
  void set resize(String value) {
    setProperty('resize', value, '');
  }

  /** Gets the value of "right" */
  String get right() =>
    getPropertyValue('right');

  /** Sets the value of "right" */
  void set right(String value) {
    setProperty('right', value, '');
  }

  /** Gets the value of "rtl-ordering" */
  String get rtlOrdering() =>
    getPropertyValue('${_browserPrefix}rtl-ordering');

  /** Sets the value of "rtl-ordering" */
  void set rtlOrdering(String value) {
    setProperty('${_browserPrefix}rtl-ordering', value, '');
  }

  /** Gets the value of "size" */
  String get size() =>
    getPropertyValue('size');

  /** Sets the value of "size" */
  void set size(String value) {
    setProperty('size', value, '');
  }

  /** Gets the value of "speak" */
  String get speak() =>
    getPropertyValue('speak');

  /** Sets the value of "speak" */
  void set speak(String value) {
    setProperty('speak', value, '');
  }

  /** Gets the value of "src" */
  String get src() =>
    getPropertyValue('src');

  /** Sets the value of "src" */
  void set src(String value) {
    setProperty('src', value, '');
  }

  /** Gets the value of "table-layout" */
  String get tableLayout() =>
    getPropertyValue('table-layout');

  /** Sets the value of "table-layout" */
  void set tableLayout(String value) {
    setProperty('table-layout', value, '');
  }

  /** Gets the value of "tap-highlight-color" */
  String get tapHighlightColor() =>
    getPropertyValue('${_browserPrefix}tap-highlight-color');

  /** Sets the value of "tap-highlight-color" */
  void set tapHighlightColor(String value) {
    setProperty('${_browserPrefix}tap-highlight-color', value, '');
  }

  /** Gets the value of "text-align" */
  String get textAlign() =>
    getPropertyValue('text-align');

  /** Sets the value of "text-align" */
  void set textAlign(String value) {
    setProperty('text-align', value, '');
  }

  /** Gets the value of "text-combine" */
  String get textCombine() =>
    getPropertyValue('${_browserPrefix}text-combine');

  /** Sets the value of "text-combine" */
  void set textCombine(String value) {
    setProperty('${_browserPrefix}text-combine', value, '');
  }

  /** Gets the value of "text-decoration" */
  String get textDecoration() =>
    getPropertyValue('text-decoration');

  /** Sets the value of "text-decoration" */
  void set textDecoration(String value) {
    setProperty('text-decoration', value, '');
  }

  /** Gets the value of "text-decorations-in-effect" */
  String get textDecorationsInEffect() =>
    getPropertyValue('${_browserPrefix}text-decorations-in-effect');

  /** Sets the value of "text-decorations-in-effect" */
  void set textDecorationsInEffect(String value) {
    setProperty('${_browserPrefix}text-decorations-in-effect', value, '');
  }

  /** Gets the value of "text-emphasis" */
  String get textEmphasis() =>
    getPropertyValue('${_browserPrefix}text-emphasis');

  /** Sets the value of "text-emphasis" */
  void set textEmphasis(String value) {
    setProperty('${_browserPrefix}text-emphasis', value, '');
  }

  /** Gets the value of "text-emphasis-color" */
  String get textEmphasisColor() =>
    getPropertyValue('${_browserPrefix}text-emphasis-color');

  /** Sets the value of "text-emphasis-color" */
  void set textEmphasisColor(String value) {
    setProperty('${_browserPrefix}text-emphasis-color', value, '');
  }

  /** Gets the value of "text-emphasis-position" */
  String get textEmphasisPosition() =>
    getPropertyValue('${_browserPrefix}text-emphasis-position');

  /** Sets the value of "text-emphasis-position" */
  void set textEmphasisPosition(String value) {
    setProperty('${_browserPrefix}text-emphasis-position', value, '');
  }

  /** Gets the value of "text-emphasis-style" */
  String get textEmphasisStyle() =>
    getPropertyValue('${_browserPrefix}text-emphasis-style');

  /** Sets the value of "text-emphasis-style" */
  void set textEmphasisStyle(String value) {
    setProperty('${_browserPrefix}text-emphasis-style', value, '');
  }

  /** Gets the value of "text-fill-color" */
  String get textFillColor() =>
    getPropertyValue('${_browserPrefix}text-fill-color');

  /** Sets the value of "text-fill-color" */
  void set textFillColor(String value) {
    setProperty('${_browserPrefix}text-fill-color', value, '');
  }

  /** Gets the value of "text-indent" */
  String get textIndent() =>
    getPropertyValue('text-indent');

  /** Sets the value of "text-indent" */
  void set textIndent(String value) {
    setProperty('text-indent', value, '');
  }

  /** Gets the value of "text-line-through" */
  String get textLineThrough() =>
    getPropertyValue('text-line-through');

  /** Sets the value of "text-line-through" */
  void set textLineThrough(String value) {
    setProperty('text-line-through', value, '');
  }

  /** Gets the value of "text-line-through-color" */
  String get textLineThroughColor() =>
    getPropertyValue('text-line-through-color');

  /** Sets the value of "text-line-through-color" */
  void set textLineThroughColor(String value) {
    setProperty('text-line-through-color', value, '');
  }

  /** Gets the value of "text-line-through-mode" */
  String get textLineThroughMode() =>
    getPropertyValue('text-line-through-mode');

  /** Sets the value of "text-line-through-mode" */
  void set textLineThroughMode(String value) {
    setProperty('text-line-through-mode', value, '');
  }

  /** Gets the value of "text-line-through-style" */
  String get textLineThroughStyle() =>
    getPropertyValue('text-line-through-style');

  /** Sets the value of "text-line-through-style" */
  void set textLineThroughStyle(String value) {
    setProperty('text-line-through-style', value, '');
  }

  /** Gets the value of "text-line-through-width" */
  String get textLineThroughWidth() =>
    getPropertyValue('text-line-through-width');

  /** Sets the value of "text-line-through-width" */
  void set textLineThroughWidth(String value) {
    setProperty('text-line-through-width', value, '');
  }

  /** Gets the value of "text-orientation" */
  String get textOrientation() =>
    getPropertyValue('${_browserPrefix}text-orientation');

  /** Sets the value of "text-orientation" */
  void set textOrientation(String value) {
    setProperty('${_browserPrefix}text-orientation', value, '');
  }

  /** Gets the value of "text-overflow" */
  String get textOverflow() =>
    getPropertyValue('text-overflow');

  /** Sets the value of "text-overflow" */
  void set textOverflow(String value) {
    setProperty('text-overflow', value, '');
  }

  /** Gets the value of "text-overline" */
  String get textOverline() =>
    getPropertyValue('text-overline');

  /** Sets the value of "text-overline" */
  void set textOverline(String value) {
    setProperty('text-overline', value, '');
  }

  /** Gets the value of "text-overline-color" */
  String get textOverlineColor() =>
    getPropertyValue('text-overline-color');

  /** Sets the value of "text-overline-color" */
  void set textOverlineColor(String value) {
    setProperty('text-overline-color', value, '');
  }

  /** Gets the value of "text-overline-mode" */
  String get textOverlineMode() =>
    getPropertyValue('text-overline-mode');

  /** Sets the value of "text-overline-mode" */
  void set textOverlineMode(String value) {
    setProperty('text-overline-mode', value, '');
  }

  /** Gets the value of "text-overline-style" */
  String get textOverlineStyle() =>
    getPropertyValue('text-overline-style');

  /** Sets the value of "text-overline-style" */
  void set textOverlineStyle(String value) {
    setProperty('text-overline-style', value, '');
  }

  /** Gets the value of "text-overline-width" */
  String get textOverlineWidth() =>
    getPropertyValue('text-overline-width');

  /** Sets the value of "text-overline-width" */
  void set textOverlineWidth(String value) {
    setProperty('text-overline-width', value, '');
  }

  /** Gets the value of "text-rendering" */
  String get textRendering() =>
    getPropertyValue('text-rendering');

  /** Sets the value of "text-rendering" */
  void set textRendering(String value) {
    setProperty('text-rendering', value, '');
  }

  /** Gets the value of "text-security" */
  String get textSecurity() =>
    getPropertyValue('${_browserPrefix}text-security');

  /** Sets the value of "text-security" */
  void set textSecurity(String value) {
    setProperty('${_browserPrefix}text-security', value, '');
  }

  /** Gets the value of "text-shadow" */
  String get textShadow() =>
    getPropertyValue('text-shadow');

  /** Sets the value of "text-shadow" */
  void set textShadow(String value) {
    setProperty('text-shadow', value, '');
  }

  /** Gets the value of "text-size-adjust" */
  String get textSizeAdjust() =>
    getPropertyValue('${_browserPrefix}text-size-adjust');

  /** Sets the value of "text-size-adjust" */
  void set textSizeAdjust(String value) {
    setProperty('${_browserPrefix}text-size-adjust', value, '');
  }

  /** Gets the value of "text-stroke" */
  String get textStroke() =>
    getPropertyValue('${_browserPrefix}text-stroke');

  /** Sets the value of "text-stroke" */
  void set textStroke(String value) {
    setProperty('${_browserPrefix}text-stroke', value, '');
  }

  /** Gets the value of "text-stroke-color" */
  String get textStrokeColor() =>
    getPropertyValue('${_browserPrefix}text-stroke-color');

  /** Sets the value of "text-stroke-color" */
  void set textStrokeColor(String value) {
    setProperty('${_browserPrefix}text-stroke-color', value, '');
  }

  /** Gets the value of "text-stroke-width" */
  String get textStrokeWidth() =>
    getPropertyValue('${_browserPrefix}text-stroke-width');

  /** Sets the value of "text-stroke-width" */
  void set textStrokeWidth(String value) {
    setProperty('${_browserPrefix}text-stroke-width', value, '');
  }

  /** Gets the value of "text-transform" */
  String get textTransform() =>
    getPropertyValue('text-transform');

  /** Sets the value of "text-transform" */
  void set textTransform(String value) {
    setProperty('text-transform', value, '');
  }

  /** Gets the value of "text-underline" */
  String get textUnderline() =>
    getPropertyValue('text-underline');

  /** Sets the value of "text-underline" */
  void set textUnderline(String value) {
    setProperty('text-underline', value, '');
  }

  /** Gets the value of "text-underline-color" */
  String get textUnderlineColor() =>
    getPropertyValue('text-underline-color');

  /** Sets the value of "text-underline-color" */
  void set textUnderlineColor(String value) {
    setProperty('text-underline-color', value, '');
  }

  /** Gets the value of "text-underline-mode" */
  String get textUnderlineMode() =>
    getPropertyValue('text-underline-mode');

  /** Sets the value of "text-underline-mode" */
  void set textUnderlineMode(String value) {
    setProperty('text-underline-mode', value, '');
  }

  /** Gets the value of "text-underline-style" */
  String get textUnderlineStyle() =>
    getPropertyValue('text-underline-style');

  /** Sets the value of "text-underline-style" */
  void set textUnderlineStyle(String value) {
    setProperty('text-underline-style', value, '');
  }

  /** Gets the value of "text-underline-width" */
  String get textUnderlineWidth() =>
    getPropertyValue('text-underline-width');

  /** Sets the value of "text-underline-width" */
  void set textUnderlineWidth(String value) {
    setProperty('text-underline-width', value, '');
  }

  /** Gets the value of "top" */
  String get top() =>
    getPropertyValue('top');

  /** Sets the value of "top" */
  void set top(String value) {
    setProperty('top', value, '');
  }

  /** Gets the value of "transform" */
  String get transform() =>
    getPropertyValue('${_browserPrefix}transform');

  /** Sets the value of "transform" */
  void set transform(String value) {
    setProperty('${_browserPrefix}transform', value, '');
  }

  /** Gets the value of "transform-origin" */
  String get transformOrigin() =>
    getPropertyValue('${_browserPrefix}transform-origin');

  /** Sets the value of "transform-origin" */
  void set transformOrigin(String value) {
    setProperty('${_browserPrefix}transform-origin', value, '');
  }

  /** Gets the value of "transform-origin-x" */
  String get transformOriginX() =>
    getPropertyValue('${_browserPrefix}transform-origin-x');

  /** Sets the value of "transform-origin-x" */
  void set transformOriginX(String value) {
    setProperty('${_browserPrefix}transform-origin-x', value, '');
  }

  /** Gets the value of "transform-origin-y" */
  String get transformOriginY() =>
    getPropertyValue('${_browserPrefix}transform-origin-y');

  /** Sets the value of "transform-origin-y" */
  void set transformOriginY(String value) {
    setProperty('${_browserPrefix}transform-origin-y', value, '');
  }

  /** Gets the value of "transform-origin-z" */
  String get transformOriginZ() =>
    getPropertyValue('${_browserPrefix}transform-origin-z');

  /** Sets the value of "transform-origin-z" */
  void set transformOriginZ(String value) {
    setProperty('${_browserPrefix}transform-origin-z', value, '');
  }

  /** Gets the value of "transform-style" */
  String get transformStyle() =>
    getPropertyValue('${_browserPrefix}transform-style');

  /** Sets the value of "transform-style" */
  void set transformStyle(String value) {
    setProperty('${_browserPrefix}transform-style', value, '');
  }

  /** Gets the value of "transition" */
  String get transition() =>
    getPropertyValue('${_browserPrefix}transition');

  /** Sets the value of "transition" */
  void set transition(String value) {
    setProperty('${_browserPrefix}transition', value, '');
  }

  /** Gets the value of "transition-delay" */
  String get transitionDelay() =>
    getPropertyValue('${_browserPrefix}transition-delay');

  /** Sets the value of "transition-delay" */
  void set transitionDelay(String value) {
    setProperty('${_browserPrefix}transition-delay', value, '');
  }

  /** Gets the value of "transition-duration" */
  String get transitionDuration() =>
    getPropertyValue('${_browserPrefix}transition-duration');

  /** Sets the value of "transition-duration" */
  void set transitionDuration(String value) {
    setProperty('${_browserPrefix}transition-duration', value, '');
  }

  /** Gets the value of "transition-property" */
  String get transitionProperty() =>
    getPropertyValue('${_browserPrefix}transition-property');

  /** Sets the value of "transition-property" */
  void set transitionProperty(String value) {
    setProperty('${_browserPrefix}transition-property', value, '');
  }

  /** Gets the value of "transition-timing-function" */
  String get transitionTimingFunction() =>
    getPropertyValue('${_browserPrefix}transition-timing-function');

  /** Sets the value of "transition-timing-function" */
  void set transitionTimingFunction(String value) {
    setProperty('${_browserPrefix}transition-timing-function', value, '');
  }

  /** Gets the value of "unicode-bidi" */
  String get unicodeBidi() =>
    getPropertyValue('unicode-bidi');

  /** Sets the value of "unicode-bidi" */
  void set unicodeBidi(String value) {
    setProperty('unicode-bidi', value, '');
  }

  /** Gets the value of "unicode-range" */
  String get unicodeRange() =>
    getPropertyValue('unicode-range');

  /** Sets the value of "unicode-range" */
  void set unicodeRange(String value) {
    setProperty('unicode-range', value, '');
  }

  /** Gets the value of "user-drag" */
  String get userDrag() =>
    getPropertyValue('${_browserPrefix}user-drag');

  /** Sets the value of "user-drag" */
  void set userDrag(String value) {
    setProperty('${_browserPrefix}user-drag', value, '');
  }

  /** Gets the value of "user-modify" */
  String get userModify() =>
    getPropertyValue('${_browserPrefix}user-modify');

  /** Sets the value of "user-modify" */
  void set userModify(String value) {
    setProperty('${_browserPrefix}user-modify', value, '');
  }

  /** Gets the value of "user-select" */
  String get userSelect() =>
    getPropertyValue('${_browserPrefix}user-select');

  /** Sets the value of "user-select" */
  void set userSelect(String value) {
    setProperty('${_browserPrefix}user-select', value, '');
  }

  /** Gets the value of "vertical-align" */
  String get verticalAlign() =>
    getPropertyValue('vertical-align');

  /** Sets the value of "vertical-align" */
  void set verticalAlign(String value) {
    setProperty('vertical-align', value, '');
  }

  /** Gets the value of "visibility" */
  String get visibility() =>
    getPropertyValue('visibility');

  /** Sets the value of "visibility" */
  void set visibility(String value) {
    setProperty('visibility', value, '');
  }

  /** Gets the value of "white-space" */
  String get whiteSpace() =>
    getPropertyValue('white-space');

  /** Sets the value of "white-space" */
  void set whiteSpace(String value) {
    setProperty('white-space', value, '');
  }

  /** Gets the value of "widows" */
  String get widows() =>
    getPropertyValue('widows');

  /** Sets the value of "widows" */
  void set widows(String value) {
    setProperty('widows', value, '');
  }

  /** Gets the value of "width" */
  String get width() =>
    getPropertyValue('width');

  /** Sets the value of "width" */
  void set width(String value) {
    setProperty('width', value, '');
  }

  /** Gets the value of "word-break" */
  String get wordBreak() =>
    getPropertyValue('word-break');

  /** Sets the value of "word-break" */
  void set wordBreak(String value) {
    setProperty('word-break', value, '');
  }

  /** Gets the value of "word-spacing" */
  String get wordSpacing() =>
    getPropertyValue('word-spacing');

  /** Sets the value of "word-spacing" */
  void set wordSpacing(String value) {
    setProperty('word-spacing', value, '');
  }

  /** Gets the value of "word-wrap" */
  String get wordWrap() =>
    getPropertyValue('word-wrap');

  /** Sets the value of "word-wrap" */
  void set wordWrap(String value) {
    setProperty('word-wrap', value, '');
  }

  /** Gets the value of "wrap-shape" */
  String get wrapShape() =>
    getPropertyValue('${_browserPrefix}wrap-shape');

  /** Sets the value of "wrap-shape" */
  void set wrapShape(String value) {
    setProperty('${_browserPrefix}wrap-shape', value, '');
  }

  /** Gets the value of "writing-mode" */
  String get writingMode() =>
    getPropertyValue('${_browserPrefix}writing-mode');

  /** Sets the value of "writing-mode" */
  void set writingMode(String value) {
    setProperty('${_browserPrefix}writing-mode', value, '');
  }

  /** Gets the value of "z-index" */
  String get zIndex() =>
    getPropertyValue('z-index');

  /** Sets the value of "z-index" */
  void set zIndex(String value) {
    setProperty('z-index', value, '');
  }

  /** Gets the value of "zoom" */
  String get zoom() =>
    getPropertyValue('zoom');

  /** Sets the value of "zoom" */
  void set zoom(String value) {
    setProperty('zoom', value, '');
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class CustomEventWrappingImplementation extends EventWrappingImplementation implements CustomEvent {
  CustomEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory CustomEventWrappingImplementation(String type,
      [bool canBubble = true, bool cancelable = true, Object detail = null]) {
    final e = dom.document.createEvent("CustomEvent");
    e.initCustomEvent(type, canBubble, cancelable, detail);
    return LevelDom.wrapCustomEvent(e);
  }

  String get detail() => _ptr.detail;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Provides a Map abstraction on top of data-* attributes, similar to the
 * dataSet in the old DOM.
 */
class _DataAttributeMap implements Map<String, String> {

  final Map<String, String> _attributes;

  _DataAttributeMap(this._attributes);

  // interface Map

  // TODO: Use lazy iterator when it is available on Map.
  bool containsValue(String value) => getValues().some((v) => v == value);

  bool containsKey(String key) => _attributes.containsKey(_attr(key));

  String operator [](String key) => _attributes[_attr(key)];

  void operator []=(String key, String value) {
    _attributes[_attr(key)] = value;
  }

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) {
      return this[key] = ifAbsent();
    }
    return this[key];
  }

  String remove(String key) => _attributes.remove(_attr(key));

  void clear() {
    // Needs to operate on a snapshot since we are mutatiting the collection.
    for (String key in getKeys()) {
      remove(key);
    }
  }

  void forEach(void f(String key, String value)) {
    _attributes.forEach((String key, String value) {
      if (_matches(key)) {
        f(_strip(key), value);
      }
    });
  }

  Collection<String> getKeys() {
    final keys = new List<String>();
    _attributes.forEach((String key, String value) {
      if (_matches(key)) {
        keys.add(_strip(key));
      }
    });
    return keys;
  }

  Collection<String> getValues() {
    final values = new List<String>();
    _attributes.forEach((String key, String value) {
      if (_matches(key)) {
        values.add(value);
      }
    });
    return values;
  }

  int get length() => getKeys().length;

  // TODO: Use lazy iterator when it is available on Map.
  bool isEmpty() => length == 0;

  // Helpers.
  String _attr(String key) => 'data-$key';
  bool _matches(String key) => key.startsWith('data-');
  String _strip(String key) => key.substring(5);
}

// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Utils for device detection.
 */
class _Device {
  /**
   * Gets the browser's user agent. Using this function allows tests to inject
   * the user agent.
   * Returns the user agent.
   */
  static String get userAgent() => dom.window.navigator.userAgent;

  /**
   * Determines if the current device is running Firefox.
   */
  static bool get isFirefox() => userAgent.contains("Firefox", 0);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class DeviceMotionEventWrappingImplementation extends EventWrappingImplementation implements DeviceMotionEvent {
  DeviceMotionEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory DeviceMotionEventWrappingImplementation(String type,
      [bool canBubble = true, bool cancelable = true]) {
    final e = dom.document.createEvent("DeviceMotionEvent");
    e.initEvent(type, canBubble, cancelable);
    return LevelDom.wrapDeviceMotionEvent(e);
  }

  num get interval() => _ptr.interval;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class DeviceOrientationEventWrappingImplementation extends EventWrappingImplementation implements DeviceOrientationEvent {
  DeviceOrientationEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory DeviceOrientationEventWrappingImplementation(String type,
      double alpha, double beta, double gamma, [bool canBubble = true,
      bool cancelable = true]) {
    final e = dom.document.createEvent("DeviceOrientationEvent");
    e.initDeviceOrientationEvent(
        type, canBubble, cancelable, alpha, beta, gamma);
    return LevelDom.wrapDeviceOrientationEvent(e);
  }

  num get alpha() => _ptr.alpha;

  num get beta() => _ptr.beta;

  num get gamma() => _ptr.gamma;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class FilteredElementList implements ElementList {
  final Node _node;
  final NodeList _childNodes;

  FilteredElementList(Node node): _childNodes = node.nodes, _node = node;

  // We can't memoize this, since it's possible that children will be messed
  // with externally to this class.
  //
  // TODO(nweiz): Do we really need to copy the list to make the types work out?
  List<Element> get _filtered() =>
    new List.from(_childNodes.filter((n) => n is Element));

  // Don't use _filtered.first so we can short-circuit once we find an element.
  Element get first() {
    for (var node in _childNodes) {
      if (node is Element) {
        return node;
      }
    }
    return null;
  }

  void forEach(void f(Element element)) {
    _filtered.forEach(f);
  }

  void operator []=(int index, Element value) {
    this[index].replaceWith(value);
  }

  void set length(int newLength) {
    var len = this.length;
    if (newLength >= len) {
      return;
    } else if (newLength < 0) {
      throw const IllegalArgumentException("Invalid list length");
    }

    removeRange(newLength - 1, len - newLength);
  }

  void add(Element value) {
    _childNodes.add(value);
  }

  void addAll(Collection<Element> collection) {
    collection.forEach(add);
  }

  void addLast(Element value) {
    add(value);
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('TODO(jacobr): should we impl?');
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw const NotImplementedException();
  }

  void setRange(int start, int length, List from, [int startFrom = 0]) {
    throw const NotImplementedException();
  }

  void removeRange(int start, int length) {
    _filtered.getRange(start, length).forEach((el) => el.remove());
  }

  void insertRange(int start, int length, [initialValue = null]) {
    throw const NotImplementedException();
  }

  void clear() {
    // Currently, ElementList#clear clears even non-element nodes, so we follow
    // that behavior.
    _childNodes.clear();
  }

  Element removeLast() {
    var last_ = this.last();
    if (last_ != null) {
      last_.remove();
    }
    return last_;
  }

  Collection<Element> filter(bool f(Element element)) => _filtered.filter(f);
  bool every(bool f(Element element)) => _filtered.every(f);
  bool some(bool f(Element element)) => _filtered.some(f);
  bool isEmpty() => _filtered.isEmpty();
  int get length() => _filtered.length;
  Element operator [](int index) => _filtered[index];
  Iterator<Element> iterator() => _filtered.iterator();
  List<Element> getRange(int start, int length) =>
    _filtered.getRange(start, length);
  int indexOf(Element element, [int start = 0]) =>
    _filtered.indexOf(element, start);

  int lastIndexOf(Element element, [int start = null]) {
    if (start === null) start = length - 1;
    return _filtered.lastIndexOf(element, start);
  }

  Element last() => _filtered.last();
}

class EmptyStyleDeclaration extends CSSStyleDeclarationWrappingImplementation {
  // This can't call super(), since that's a factory constructor
  EmptyStyleDeclaration()
    : super._wrap(dom.document.createElement('div').style);

  void set cssText(String value) {
    throw new UnsupportedOperationException(
        "Can't modify a frozen style declaration.");
  }

  String removeProperty(String propertyName) {
    throw new UnsupportedOperationException(
        "Can't modify a frozen style declaration.");
  }

  void setProperty(String propertyName, String value, [String priority]) {
    throw new UnsupportedOperationException(
        "Can't modify a frozen style declaration.");
  }
}

Future<CSSStyleDeclaration> _emptyStyleFuture() {
  return _createMeasurementFuture(() => new EmptyStyleDeclaration(),
                                  new Completer<CSSStyleDeclaration>());
}

class EmptyElementRect implements ElementRect {
  final ClientRect client = const SimpleClientRect(0, 0, 0, 0);
  final ClientRect offset = const SimpleClientRect(0, 0, 0, 0);
  final ClientRect scroll = const SimpleClientRect(0, 0, 0, 0);
  final ClientRect bounding = const SimpleClientRect(0, 0, 0, 0);
  final List<ClientRect> clientRects = const <ClientRect>[];

  const EmptyElementRect();
}

class DocumentFragmentWrappingImplementation extends NodeWrappingImplementation implements DocumentFragment {
  ElementList _elements;

  DocumentFragmentWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  /** @domName Document.createDocumentFragment */
  factory DocumentFragmentWrappingImplementation() {
    return new DocumentFragmentWrappingImplementation._wrap(
	    dom.document.createDocumentFragment());
  }

  factory DocumentFragmentWrappingImplementation.html(String html) {
    var fragment = new DocumentFragment();
    fragment.innerHTML = html;
    return fragment;
  }

  ElementList get elements() {
    if (_elements == null) {
      _elements = new FilteredElementList(this);
    }
    return _elements;
  }

  // TODO: The type of value should be Collection<Element>. See http://b/5392897
  void set elements(value) {
    // Copy list first since we don't want liveness during iteration.
    List copy = new List.from(value);
    final elements = this.elements;
    elements.clear();
    elements.addAll(copy);
  }

  String get innerHTML() {
    var e = new Element.tag("div");
    e.nodes.add(this.clone(true));
    return e.innerHTML;
  }

  String get outerHTML() => innerHTML;

  void set innerHTML(String value) {
    this.nodes.clear();

    var e = new Element.tag("div");
    e.innerHTML = value;

    // Copy list first since we don't want liveness during iteration.
    List nodes = new List.from(e.nodes);
    this.nodes.addAll(nodes);
  }

  Node _insertAdjacentNode(String where, Node node) {
    switch (where.toLowerCase()) {
      case "beforebegin": return null;
      case "afterend": return null;
      case "afterbegin":
        this.insertBefore(node, nodes.first);
        return node;
      case "beforeend":
        this.nodes.add(node);
        return node;
      default:
        throw new IllegalArgumentException("Invalid position ${where}");
    }
  }

  Element insertAdjacentElement([String where = null, Element element = null])
    => this._insertAdjacentNode(where, element);

  void insertAdjacentText([String where = null, String text = null]) {
    this._insertAdjacentNode(where, new Text(text));
  }

  void insertAdjacentHTML(
      [String position_OR_where = null, String text = null]) {
    this._insertAdjacentNode(
      position_OR_where, new DocumentFragment.html(text));
  }

  ElementEvents get on() {
    if (_on === null) {
      _on = new ElementEventsImplementation._wrap(_ptr);
    }
    return _on;
  }

  Future<ElementRect> get rect() {
    return _createMeasurementFuture(() => const EmptyElementRect(),
                                    new Completer<ElementRect>());
  }

  Element query(String selectors) =>
    LevelDom.wrapElement(_ptr.querySelector(selectors));

  ElementList queryAll(String selectors) =>
    LevelDom.wrapElementList(_ptr.querySelectorAll(selectors));

  // If we can come up with a semi-reasonable default value for an Element
  // getter, we'll use it. In general, these return the same values as an
  // element that has no parent.
  String get contentEditable() => "false";
  bool get isContentEditable() => false;
  bool get draggable() => false;
  bool get hidden() => false;
  bool get spellcheck() => false;
  int get tabIndex() => -1;
  String get id() => "";
  String get title() => "";
  String get tagName() => "";
  String get webkitdropzone() => "";
  Element get firstElementChild() => elements.first();
  Element get lastElementChild() => elements.last();
  Element get nextElementSibling() => null;
  Element get previousElementSibling() => null;
  Element get offsetParent() => null;
  Element get parent() => null;
  Map<String, String> get attributes() => const {};
  // Issue 174: this should be a const set.
  Set<String> get classes() => new Set<String>();
  Map<String, String> get dataAttributes() => const {};
  CSSStyleDeclaration get style() => new EmptyStyleDeclaration();
  Future<CSSStyleDeclaration> get computedStyle() =>
      _emptyStyleFuture();
  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement) =>
      _emptyStyleFuture();
  bool matchesSelector([String selectors]) => false;

  // Imperative Element methods are made into no-ops, as they are on parentless
  // elements.
  void blur() {}
  void focus() {}
  void scrollByLines([int lines]) {}
  void scrollByPages([int pages]) {}
  void scrollIntoView([bool centerIfNeeded]) {}

  // Setters throw errors rather than being no-ops because we aren't going to
  // retain the values that were set, and erroring out seems clearer.
  void set attributes(Map<String, String> value) {
    throw new UnsupportedOperationException(
      "Attributes can't be set for document fragments.");
  }

  void set classes(Collection<String> value) {
    throw new UnsupportedOperationException(
      "Classes can't be set for document fragments.");
  }

  void set dataAttributes(Map<String, String> value) {
    throw new UnsupportedOperationException(
      "Data attributes can't be set for document fragments.");
  }

  void set contentEditable(String value) {
    throw new UnsupportedOperationException(
      "Content editable can't be set for document fragments.");
  }

  String get dir() {
    throw new UnsupportedOperationException(
      "Document fragments don't support text direction.");
  }

  void set dir(String value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support text direction.");
  }

  void set draggable(bool value) {
    throw new UnsupportedOperationException(
      "Draggable can't be set for document fragments.");
  }

  void set hidden(bool value) {
    throw new UnsupportedOperationException(
      "Hidden can't be set for document fragments.");
  }

  void set id(String value) {
    throw new UnsupportedOperationException(
      "ID can't be set for document fragments.");
  }

  String get lang() {
    throw new UnsupportedOperationException(
      "Document fragments don't support language.");
  }

  void set lang(String value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support language.");
  }

  void set scrollLeft(int value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support scrolling.");
  }

  void set scrollTop(int value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support scrolling.");
  }

  void set spellcheck(bool value) {
     throw new UnsupportedOperationException(
      "Spellcheck can't be set for document fragments.");
  }

  void set tabIndex(int value) {
    throw new UnsupportedOperationException(
      "Tab index can't be set for document fragments.");
  }

  void set title(String value) {
    throw new UnsupportedOperationException(
      "Title can't be set for document fragments.");
  }

  void set webkitdropzone(String value) {
    throw new UnsupportedOperationException(
      "WebKit drop zone can't be set for document fragments.");
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class DocumentEventsImplementation extends ElementEventsImplementation
      implements DocumentEvents {

  DocumentEventsImplementation._wrap(_ptr) : super._wrap(_ptr);

  EventListenerList get readyStateChange() => _get('readystatechange');

  EventListenerList get selectionChange() => _get('selectionchange');

  EventListenerList get contentLoaded() => _get('DOMContentLoaded');
}

/** @domName Document, HTMLDocument */
class DocumentWrappingImplementation extends ElementWrappingImplementation implements Document {

  final _documentPtr;

  DocumentWrappingImplementation._wrap(this._documentPtr, ptr) : super._wrap(ptr) {
    // We have to set the back ptr on the document as well as the documentElement
    // so that it is always simple to detect when an existing wrapper exists.
    _documentPtr.dynamic.dartObjectLocalStorage = this;
  }

  /** @domName activeElement */
  Element get activeElement() => LevelDom.wrapElement(_documentPtr.dynamic.activeElement);

  Node get parent() => null;

  /** @domName body */
  Element get body() => LevelDom.wrapElement(_documentPtr.body);

  /** @domName body */
  void set body(Element value) { _documentPtr.body = LevelDom.unwrap(value); }

  /** @domName charset */
  String get charset() => _documentPtr.charset;

  /** @domName charset */
  void set charset(String value) { _documentPtr.charset = value; }

  /** @domName cookie */
  String get cookie() => _documentPtr.cookie;

  /** @domName cookie */
  void set cookie(String value) { _documentPtr.cookie = value; }

  /** @domName defaultView */
  Window get window() => LevelDom.wrapWindow(_documentPtr.defaultView);

  /** @domName designMode */
  void set designMode(String value) { _documentPtr.dynamic.designMode = value; }

  /** @domName domain */
  String get domain() => _documentPtr.domain;

  /** @domName head */
  HeadElement get head() => LevelDom.wrapHeadElement(_documentPtr.head);

  /** @domName lastModified */
  String get lastModified() => _documentPtr.lastModified;

  /** @domName readyState */
  String get readyState() => _documentPtr.readyState;

  /** @domName referrer */
  String get referrer() => _documentPtr.referrer;

  /** @domName styleSheets */
  StyleSheetList get styleSheets() => LevelDom.wrapStyleSheetList(_documentPtr.styleSheets);

  /** @domName title */
  String get title() => _documentPtr.title;

  /** @domName title */
  void set title(String value) { _documentPtr.title = value; }

  /** @domName webkitHidden */
  bool get webkitHidden() => _documentPtr.webkitHidden;

  /** @domName webkitVisibilityState */
  String get webkitVisibilityState() => _documentPtr.webkitVisibilityState;

  /** @domName caretRangeFromPoint */
  Future<Range> caretRangeFromPoint([int x = null, int y = null]) {
    return _createMeasurementFuture(
        () => LevelDom.wrapRange(_documentPtr.caretRangeFromPoint(x, y)),
        new Completer<Range>());
  }

  /** @domName createEvent */
  Event createEvent(String eventType) {
    return LevelDom.wrapEvent(_documentPtr.createEvent(eventType));
  }

  /** @domName elementFromPoint */
  Future<Element> elementFromPoint([int x = null, int y = null]) {
    return _createMeasurementFuture(
        () => LevelDom.wrapElement(_documentPtr.elementFromPoint(x, y)),
        new Completer<Element>());
  }

  /** @domName execCommand */
  bool execCommand([String command = null, bool userInterface = null, String value = null]) {
    return _documentPtr.execCommand(command, userInterface, value);
  }

  /** @domName getCSSCanvasContext */
  CanvasRenderingContext getCSSCanvasContext(String contextId, String name,
                                             int width, int height) {
    return LevelDom.wrapCanvasRenderingContext(_documentPtr.getCSSCanvasContext(contextId, name, width, height));
  }

  /** @domName queryCommandEnabled */
  bool queryCommandEnabled([String command = null]) {
    return _documentPtr.queryCommandEnabled(command);
  }

  /** @domName queryCommandIndeterm */
  bool queryCommandIndeterm([String command = null]) {
    return _documentPtr.queryCommandIndeterm(command);
  }

  /** @domName queryCommandState */
  bool queryCommandState([String command = null]) {
    return _documentPtr.queryCommandState(command);
  }

  /** @domName queryCommandSupported */
  bool queryCommandSupported([String command = null]) {
    return _documentPtr.queryCommandSupported(command);
  }

  /** @domName queryCommandValue */
  String queryCommandValue([String command = null]) {
    return _documentPtr.queryCommandValue(command);
  }

  /** @domName HTMLHtmlElement.manifest */
  String get manifest() => _ptr.manifest;

  /** @domName HTMLHtmlElement.manifest */
  void set manifest(String value) { _ptr.manifest = value; }

  DocumentEvents get on() {
    if (_on === null) {
      _on = new DocumentEventsImplementation._wrap(_ptr);
    }
    return _on;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class DOMApplicationCacheEventsImplementation extends EventsImplementation
    implements DOMApplicationCacheEvents {
  DOMApplicationCacheEventsImplementation._wrap(ptr) : super._wrap(ptr);

  EventListenerList get cached() => _get('cached');
  EventListenerList get checking() => _get('checking');
  EventListenerList get downloading() => _get('downloading');
  EventListenerList get error() => _get('error');
  EventListenerList get noUpdate() => _get('noupdate');
  EventListenerList get obsolete() => _get('obsolete');
  EventListenerList get progress() => _get('progress');
  EventListenerList get updateReady() => _get('updateready');
}

class DOMApplicationCacheWrappingImplementation extends EventTargetWrappingImplementation implements DOMApplicationCache {
  DOMApplicationCacheWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  int get status() => _ptr.status;

  void swapCache() {
    _ptr.swapCache();
  }

  void update() {
    _ptr.update();
  }

  DOMApplicationCacheEvents get on() {
    if (_on === null) {
      _on = new DOMApplicationCacheEventsImplementation._wrap(_ptr);
    }
    return _on;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class DOMWrapperBase {
  final _ptr;

  DOMWrapperBase._wrap(this._ptr) {
  	// We should never be creating duplicate wrappers.
  	assert(_ptr.dartObjectLocalStorage === null);
	_ptr.dartObjectLocalStorage = this;
  }
}

/** This function is provided for unittest purposes only. */
unwrapDomObject(DOMWrapperBase wrapper) {
  return wrapper._ptr;
}// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jacobr): use Lists.dart to remove some of the duplicated functionality.
class _ChildrenElementList implements ElementList {
  // Raw Element.
  final _element;
  final _childElements;

  _ChildrenElementList._wrap(var element)
    : _childElements = element.children,
      _element = element;

  List<Element> _toList() {
    final output = new List(_childElements.length);
    for (int i = 0, len = _childElements.length; i < len; i++) {
      output[i] = LevelDom.wrapElement(_childElements[i]);
    }
    return output;
  }

  Element get first() {
    return LevelDom.wrapElement(_element.firstElementChild);
  }

  void forEach(void f(Element element)) {
    for (var element in _childElements) {
      f(LevelDom.wrapElement(element));
    }
  }

  Collection<Element> filter(bool f(Element element)) {
    List<Element> output = new List<Element>();
    forEach((Element element) {
      if (f(element)) {
        output.add(element);
      }
    });
    return output;
  }

  bool every(bool f(Element element)) {
    for(Element element in this) {
      if (!f(element)) {
        return false;
      }
    };
    return true;
  }

  bool some(bool f(Element element)) {
    for(Element element in this) {
      if (f(element)) {
        return true;
      }
    };
    return false;
  }

  bool isEmpty() {
    return _element.firstElementChild !== null;
  }

  int get length() {
    return _childElements.length;
  }

  Element operator [](int index) {
    return LevelDom.wrapElement(_childElements[index]);
  }

  void operator []=(int index, Element value) {
    _element.replaceChild(LevelDom.unwrap(value), _childElements.item(index));
  }

   void set length(int newLength) {
     // TODO(jacobr): remove children when length is reduced.
     throw const UnsupportedOperationException('');
   }

  Element add(Element value) {
    _element.appendChild(LevelDom.unwrap(value));
    return value;
  }

  Element addLast(Element value) => add(value);

  Iterator<Element> iterator() => _toList().iterator();

  void addAll(Collection<Element> collection) {
    for (Element element in collection) {
      _element.appendChild(LevelDom.unwrap(element));
    }
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('TODO(jacobr): should we impl?');
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw 'Not impl yet. todo(jacobr)';
  }

  void setRange(int start, int length, List from, [int startFrom = 0]) {
    throw const NotImplementedException();
  }

  void removeRange(int start, int length) {
    throw const NotImplementedException();
  }

  void insertRange(int start, int length, [initialValue = null]) {
    throw const NotImplementedException();
  }

  List getRange(int start, int length) {
    throw const NotImplementedException();
  }

  int indexOf(Element element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Element element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  void clear() {
    // It is unclear if we want to keep non element nodes?
    _element.textContent = '';
  }

  Element removeLast() {
    final last_ = this.last();
    if (last_ != null) {
      _element.removeChild(LevelDom.unwrap(last_));
    }
    return last_;
  }

  Element last() {
    return LevelDom.wrapElement(_element.lastElementChild);
  }
}

class FrozenElementList implements ElementList {
  final _ptr;

  FrozenElementList._wrap(this._ptr);

  Element get first() {
    return this[0];
  }

  void forEach(void f(Element element)) {
    for (var element in _ptr) {
      f(LevelDom.wrapElement(element));
    }
  }

  Collection<Element> filter(bool f(Element element)) {
    throw 'Not impl yet. todo(jacobr)';
  }

  bool every(bool f(Element element)) {
    throw 'Not impl yet. todo(jacobr)';
  }

  bool some(bool f(Element element)) {
    throw 'Not impl yet. todo(jacobr)';
  }

  bool isEmpty() {
    return _ptr.length == 0;
  }

  int get length() {
    return _ptr.length;
  }

  Element operator [](int index) {
    return LevelDom.wrapElement(_ptr[index]);
  }

  void operator []=(int index, Element value) {
    throw const UnsupportedOperationException('');
  }

   void set length(int newLength) {
    throw const UnsupportedOperationException('');
   }

  void add(Element value) {
    throw const UnsupportedOperationException('');
  }


  void addLast(Element value) {
    throw const UnsupportedOperationException('');
  }

  Iterator<Element> iterator() => new FrozenElementListIterator(this);

  void addAll(Collection<Element> collection) {
    throw const UnsupportedOperationException('');
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('');
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw 'Not impl yet. todo(jacobr)';
  }

  void setRange(int start, int length, List from, [int startFrom = 0]) {
    throw const NotImplementedException();
  }

  void removeRange(int start, int length) {
    throw const NotImplementedException();
  }

  void insertRange(int start, int length, [initialValue = null]) {
    throw const NotImplementedException();
  }

  List getRange(int start, int length) {
    throw const NotImplementedException();
  }

  int indexOf(Element element, [int start = 0]) {
    throw 'Not impl yet. todo(jacobr)';
  }

  int lastIndexOf(Element element, [int start = null]) {
    throw 'Not impl yet. todo(jacobr)';
  }

  void clear() {
    throw 'Not impl yet. todo(jacobr)';
  }

  Element removeLast() {
    throw 'Not impl yet. todo(jacobr)';
  }

  Element last() {
    return this[length-1];
  }
}

class FrozenElementListIterator implements Iterator<Element> {
  final FrozenElementList _list;
  int _index = 0;

  FrozenElementListIterator(this._list);

  /**
   * Gets the next element in the iteration. Throws a
   * [NoMoreElementsException] if no element is left.
   */
  Element next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }

    return _list[_index++];
  }

  /**
   * Returns whether the [Iterator] has elements left.
   */
  bool hasNext() => _index < _list.length;
}

class ElementAttributeMap implements Map<String, String> {

  final _element;

  ElementAttributeMap._wrap(this._element);

  bool containsValue(String value) {
    final attributes = _element.attributes;
    for (int i = 0, len = attributes.length; i < len; i++) {
      if(value == attributes.item(i).value) {
        return true;
      }
    }
    return false;
  }

  bool containsKey(String key) {
    return _element.hasAttribute(key);
  }

  String operator [](String key) {
    return _element.getAttribute(key);
  }

  void operator []=(String key, String value) {
    _element.setAttribute(key, value);
  }

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) {
      this[key] = ifAbsent();
    }
  }

  String remove(String key) {
    _element.removeAttribute(key);
  }

  void clear() {
    final attributes = _element.attributes;
    for (int i = attributes.length - 1; i >= 0; i--) {
      _element.removeAttribute(attributes.item(i).name);
    }
  }

  void forEach(void f(String key, String value)) {
    final attributes = _element.attributes;
    for (int i = 0, len = attributes.length; i < len; i++) {
      final item = attributes.item(i);
      f(item.name, item.value);
    }
  }

  Collection<String> getKeys() {
    // TODO(jacobr): generate a lazy collection instead.
    final attributes = _element.attributes;
    final keys = new List<String>(attributes.length);
    for (int i = 0, len = attributes.length; i < len; i++) {
      keys[i] = attributes.item(i).name;
    }
    return keys;
  }

  Collection<String> getValues() {
    // TODO(jacobr): generate a lazy collection instead.
    final attributes = _element.attributes;
    final values = new List<String>(attributes.length);
    for (int i = 0, len = attributes.length; i < len; i++) {
      values[i] = attributes.item(i).value;
    }
    return values;
  }

  /**
   * The number of {key, value} pairs in the map.
   */
  int get length() {
    return _element.attributes.length;
  }

  /**
   * Returns true if there is no {key, value} pair in the map.
   */
  bool isEmpty() {
    return !_element.hasAttributes();
  }
}

class ElementEventsImplementation extends EventsImplementation implements ElementEvents {
  ElementEventsImplementation._wrap(_ptr) : super._wrap(_ptr);

  EventListenerList get abort() => _get("abort");
  EventListenerList get beforeCopy() => _get("beforecopy");
  EventListenerList get beforeCut() => _get("beforecut");
  EventListenerList get beforePaste() => _get("beforepaste");
  EventListenerList get blur() => _get("blur");
  EventListenerList get change() => _get("change");
  EventListenerList get click() => _get("click");
  EventListenerList get contextMenu() => _get("contextmenu");
  EventListenerList get copy() => _get("copy");
  EventListenerList get cut() => _get("cut");
  EventListenerList get dblClick() => _get("dblclick");
  EventListenerList get drag() => _get("drag");
  EventListenerList get dragEnd() => _get("dragend");
  EventListenerList get dragEnter() => _get("dragenter");
  EventListenerList get dragLeave() => _get("dragleave");
  EventListenerList get dragOver() => _get("dragover");
  EventListenerList get dragStart() => _get("dragstart");
  EventListenerList get drop() => _get("drop");
  EventListenerList get error() => _get("error");
  EventListenerList get focus() => _get("focus");
  EventListenerList get input() => _get("input");
  EventListenerList get invalid() => _get("invalid");
  EventListenerList get keyDown() => _get("keydown");
  EventListenerList get keyPress() => _get("keypress");
  EventListenerList get keyUp() => _get("keyup");
  EventListenerList get load() => _get("load");
  EventListenerList get mouseDown() => _get("mousedown");
  EventListenerList get mouseMove() => _get("mousemove");
  EventListenerList get mouseOut() => _get("mouseout");
  EventListenerList get mouseOver() => _get("mouseover");
  EventListenerList get mouseUp() => _get("mouseup");
  EventListenerList get mouseWheel() => _get("mousewheel");
  EventListenerList get paste() => _get("paste");
  EventListenerList get reset() => _get("reset");
  EventListenerList get scroll() => _get("scroll");
  EventListenerList get search() => _get("search");
  EventListenerList get select() => _get("select");
  EventListenerList get selectStart() => _get("selectstart");
  EventListenerList get submit() => _get("submit");
  EventListenerList get touchCancel() => _get("touchcancel");
  EventListenerList get touchEnd() => _get("touchend");
  EventListenerList get touchLeave() => _get("touchleave");
  EventListenerList get touchMove() => _get("touchmove");
  EventListenerList get touchStart() => _get("touchstart");
  EventListenerList get transitionEnd() => _get("webkitTransitionEnd");
  EventListenerList get fullscreenChange() => _get("webkitfullscreenchange");
}

class SimpleClientRect implements ClientRect {
  final num left;
  final num top;
  final num width;
  final num height;
  num get right() => left + width;
  num get bottom() => top + height;

  const SimpleClientRect(this.left, this.top, this.width, this.height);

  bool operator ==(ClientRect other) {
    return other !== null && left == other.left && top == other.top
        && width == other.width && height == other.height;
  }

  String toString() => "($left, $top, $width, $height)";
}

// TODO(jacobr): we cannot currently be lazy about calculating the client
// rects as we must perform all measurement queries at a safe point to avoid
// triggering unneeded layouts.
/**
 * All your element measurement needs in one place
 * @domName none
 */
class ElementRectWrappingImplementation implements ElementRect {
  final ClientRect client;
  final ClientRect offset;
  final ClientRect scroll;

  // TODO(jacobr): should we move these outside of ElementRect to avoid the
  // overhead of computing them every time even though they are rarely used.
  // This should be type dom.ClientRect but that fails on dartium. b/5522629
  final _boundingClientRect;
  // an exception due to a dartium bug.
  final _clientRects; // TODO(jacobr): should be dom.ClientRectList

  ElementRectWrappingImplementation(dom.HTMLElement element) :
    client = new SimpleClientRect(element.clientLeft,
                                  element.clientTop,
                                  element.clientWidth,
                                  element.clientHeight),
    offset = new SimpleClientRect(element.offsetLeft,
                                  element.offsetTop,
                                  element.offsetWidth,
                                  element.offsetHeight),
    scroll = new SimpleClientRect(element.scrollLeft,
                                  element.scrollTop,
                                  element.scrollWidth,
                                  element.scrollHeight),
    _boundingClientRect = element.getBoundingClientRect(),
    _clientRects = element.getClientRects();

  ClientRect get bounding() =>
      LevelDom.wrapClientRect(_boundingClientRect);

  List<ClientRect> get clientRects() {
    final out = new List(_clientRects.length);
    for (num i = 0; i < _clientRects.length; i++) {
      out[i] = LevelDom.wrapClientRect(_clientRects.item(i));
    }
    return out;
  }
}

/** @domName Element, HTMLElement */
class ElementWrappingImplementation extends NodeWrappingImplementation implements Element {

    static final _START_TAG_REGEXP = const RegExp('<(\\w+)');
    static final _CUSTOM_PARENT_TAG_MAP = const {
      'body' : 'html',
      'head' : 'html',
      'caption' : 'table',
      'td': 'tr',
      'colgroup': 'table',
      'col' : 'colgroup',
      'tr' : 'tbody',
      'tbody' : 'table',
      'tfoot' : 'table',
      'thead' : 'table',
      'track' : 'audio',
    };

  /** @domName Document.createElement */
  factory ElementWrappingImplementation.html(String html) {
    // TODO(jacobr): this method can be made more robust and performant.
    // 1) Cache the dummy parent elements required to use innerHTML rather than
    //    creating them every call.
    // 2) Verify that the html does not contain leading or trailing text nodes.
    // 3) Verify that the html does not contain both <head> and <body> tags.
    // 4) Detatch the created element from its dummy parent.
    String parentTag = 'div';
    String tag;
    final match = _START_TAG_REGEXP.firstMatch(html);
    if (match !== null) {
      tag = match.group(1).toLowerCase();
      if (_CUSTOM_PARENT_TAG_MAP.containsKey(tag)) {
        parentTag = _CUSTOM_PARENT_TAG_MAP[tag];
      }
    }
    // TODO(jacobr): make type dom.HTMLElement when dartium allows it.
    var temp = dom.document.createElement(parentTag);
    temp.innerHTML = html;

    if (temp.childElementCount == 1) {
      return LevelDom.wrapElement(temp.firstElementChild);
    } else if (parentTag == 'html' && temp.childElementCount == 2) {
      // Work around for edge case in WebKit and possibly other browsers where
      // both body and head elements are created even though the inner html
      // only contains a head or body element.
      return LevelDom.wrapElement(temp.children.item(tag == 'head' ? 0 : 1));
    } else {
      throw 'HTML had ${temp.childElementCount} top level elements but 1 expected';
    }
  }

  /** @domName Document.createElement */
  factory ElementWrappingImplementation.tag(String tag) {
    return LevelDom.wrapElement(dom.document.createElement(tag));
  }

  ElementWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  ElementAttributeMap _elementAttributeMap;
  ElementList _elements;
  _CssClassSet _cssClassSet;
  _DataAttributeMap _dataAttributes;

  /**
   * @domName Element.hasAttribute, Element.getAttribute, Element.setAttribute,
   *   Element.removeAttribute
   */
  Map<String, String> get attributes() {
    if (_elementAttributeMap === null) {
      _elementAttributeMap = new ElementAttributeMap._wrap(_ptr);
    }
    return _elementAttributeMap;
  }

  void set attributes(Map<String, String> value) {
    Map<String, String> attributes = this.attributes;
    attributes.clear();
    for (String key in value.getKeys()) {
      attributes[key] = value[key];
    }
  }

  void set elements(Collection<Element> value) {
    // Copy list first since we don't want liveness during iteration.
    List copy = new List.from(value);
    final elements = this.elements;
    elements.clear();
    elements.addAll(copy);
  }

  /**
   * @domName childElementCount, firstElementChild, lastElementChild,
   *   children, appendChild
   */
  ElementList get elements() {
    if (_elements == null) {
      _elements = new _ChildrenElementList._wrap(_ptr);
    }
    return _elements;
  }

  /** @domName className, classList */
  Set<String> get classes() {
    if (_cssClassSet === null) {
      _cssClassSet = new _CssClassSet(_ptr);
    }
    return _cssClassSet;
  }

  void set classes(Collection<String> value) {
    _CssClassSet classSet = classes;
    classSet.clear();
    classSet.addAll(value);
  }

  Map<String, String> get dataAttributes() {
    if (_dataAttributes === null) {
      _dataAttributes = new _DataAttributeMap(attributes);
    }
    return _dataAttributes;
  }

  void set dataAttributes(Map<String, String> value) {
    Map<String, String> dataAttributes = this.dataAttributes;
    dataAttributes.clear();
    for (String key in value.getKeys()) {
      dataAttributes[key] = value[key];
    }
  }

  String get contentEditable() => _ptr.contentEditable;

  void set contentEditable(String value) { _ptr.contentEditable = value; }

  String get dir() => _ptr.dir;

  void set dir(String value) { _ptr.dir = value; }

  bool get draggable() => _ptr.draggable;

  void set draggable(bool value) { _ptr.draggable = value; }

  Element get firstElementChild() => LevelDom.wrapElement(_ptr.firstElementChild);

  bool get hidden() => _ptr.hidden;

  void set hidden(bool value) { _ptr.hidden = value; }

  String get id() => _ptr.id;

  void set id(String value) { _ptr.id = value; }

  String get innerHTML() => _ptr.innerHTML;

  void set innerHTML(String value) { _ptr.innerHTML = value; }

  bool get isContentEditable() => _ptr.isContentEditable;

  String get lang() => _ptr.lang;

  void set lang(String value) { _ptr.lang = value; }

  Element get lastElementChild() => LevelDom.wrapElement(_ptr.lastElementChild);

  Element get nextElementSibling() => LevelDom.wrapElement(_ptr.nextElementSibling);

  Element get offsetParent() => LevelDom.wrapElement(_ptr.offsetParent);

  String get outerHTML() => _ptr.outerHTML;

  Element get previousElementSibling() => LevelDom.wrapElement(_ptr.previousElementSibling);

  bool get spellcheck() => _ptr.spellcheck;

  void set spellcheck(bool value) { _ptr.spellcheck = value; }

  CSSStyleDeclaration get style() => LevelDom.wrapCSSStyleDeclaration(_ptr.style);

  int get tabIndex() => _ptr.tabIndex;

  void set tabIndex(int value) { _ptr.tabIndex = value; }

  String get tagName() => _ptr.tagName;

  String get title() => _ptr.title;

  void set title(String value) { _ptr.title = value; }

  String get webkitdropzone() => _ptr.webkitdropzone;

  void set webkitdropzone(String value) { _ptr.webkitdropzone = value; }

  void blur() {
    _ptr.blur();
  }

  bool contains(Node element) {
    return _ptr.contains(LevelDom.unwrap(element));
  }

  void focus() {
    _ptr.focus();
  }

  Element insertAdjacentElement([String where = null, Element element = null]) {
    return LevelDom.wrapElement(_ptr.insertAdjacentElement(where, LevelDom.unwrap(element)));
  }

  void insertAdjacentHTML([String position_OR_where = null, String text = null]) {
    _ptr.insertAdjacentHTML(position_OR_where, text);
  }

  void insertAdjacentText([String where = null, String text = null]) {
    _ptr.insertAdjacentText(where, text);
  }

  /** @domName querySelector, Document.getElementById */
  Element query(String selectors) {
    // TODO(jacobr): scope fix.
    return LevelDom.wrapElement(_ptr.querySelector(selectors));
  }

  /**
   * @domName querySelectorAll, getElementsByClassName, getElementsByTagName,
   *   getElementsByTagNameNS
   */
  ElementList queryAll(String selectors) {
    // TODO(jacobr): scope fix.
    return new FrozenElementList._wrap(_ptr.querySelectorAll(selectors));
  }

  void scrollByLines([int lines = null]) {
    _ptr.scrollByLines(lines);
  }

  void scrollByPages([int pages = null]) {
    _ptr.scrollByPages(pages);
  }

  /** @domName scrollIntoView, scrollIntoViewIfNeeded */
  void scrollIntoView([bool centerIfNeeded = null]) {
    _ptr.scrollIntoViewIfNeeded(centerIfNeeded);
  }

  bool matchesSelector([String selectors = null]) {
    return _ptr.webkitMatchesSelector(selectors);
  }

  void set scrollLeft(int value) { _ptr.scrollLeft = value; }

  void set scrollTop(int value) { _ptr.scrollTop = value; }

  /**
   * @domName getClientRects, getBoundingClientRect, clientHeight, clientWidth,
   * clientTop, clientLeft, offsetHeight, offsetWidth, offsetTop, offsetLeft,
   * scrollHeight, scrollWidth, scrollTop, scrollLeft
   */
  Future<ElementRect> get rect() {
    return _createMeasurementFuture(
        () => new ElementRectWrappingImplementation(_ptr),
        new Completer<ElementRect>());
  }

  /** @domName Window.getComputedStyle */
  Future<CSSStyleDeclaration> get computedStyle() {
     // TODO(jacobr): last param should be null, see b/5045788
     return getComputedStyle('');
  }

  /** @domName Window.getComputedStyle */
  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement) {
    return _createMeasurementFuture(() =>
        LevelDom.wrapCSSStyleDeclaration(
            dom.window.getComputedStyle(_ptr, pseudoElement)),
        new Completer<CSSStyleDeclaration>());
  }

  ElementEvents get on() {
    if (_on === null) {
      _on = new ElementEventsImplementation._wrap(_ptr);
    }
    return _on;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class ErrorEventWrappingImplementation extends EventWrappingImplementation implements ErrorEvent {
  ErrorEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory ErrorEventWrappingImplementation(String type, String message,
      String filename, int lineNo, [bool canBubble = true,
      bool cancelable = true]) {
    final e = dom.document.createEvent("ErrorEvent");
    e.initErrorEvent(type, canBubble, cancelable, message, filename, lineNo);
    return LevelDom.wrapErrorEvent(e);
  }

  String get filename() => _ptr.filename;

  int get lineno() => _ptr.lineno;

  String get message() => _ptr.message;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class EventSourceEventsImplementation extends EventsImplementation implements EventSourceEvents {
  EventSourceEventsImplementation._wrap(_ptr) : super._wrap(_ptr);

  EventListenerList get error() => _get('error');
  EventListenerList get message() => _get('message');
  EventListenerList get open() => _get('open');
}

class EventSourceWrappingImplementation extends EventTargetWrappingImplementation implements EventSource {
  EventSourceWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  String get URL() => _ptr.URL;

  int get readyState() => _ptr.readyState;

  void close() {
    _ptr.close();
  }

  EventSourceEvents get on() {
    if (_on === null) {
      _on = new EventSourceEventsImplementation._wrap(_ptr);
    }
    return _on;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class EventsImplementation implements Events {
  /* Raw event target. */
  var _ptr;

  Map<String, EventListenerList> _listenerMap;

  EventsImplementation._wrap(this._ptr) {
    // TODO(sigmund): the key type (String) yields a warning in frog and the vm,
    // but it is currently necessary to compile with dartc.
    _listenerMap = <String, EventListenerList>{};
  }

  EventListenerList operator [](String type) {
    return _get(type.toLowerCase());
  }

  EventListenerList _get(String type) {
    return _listenerMap.putIfAbsent(type,
      () => new EventListenerListImplementation(_ptr, type));
  }
}

class _EventListenerWrapper {
  final EventListener raw;
  final Function wrapped;
  final bool useCapture;
  _EventListenerWrapper(this.raw, this.wrapped, this.useCapture);
}

class EventListenerListImplementation implements EventListenerList {
  final _ptr;
  final String _type;
  List<_EventListenerWrapper> _wrappers;

  EventListenerListImplementation(this._ptr, this._type) :
    // TODO(jacobr): switch to <_EventListenerWrapper>[] when the VM allow it.
    _wrappers = new List<_EventListenerWrapper>();

  EventListenerList add(EventListener listener, [bool useCapture = false]) {
    _add(listener, useCapture);
    return this;
  }

  EventListenerList remove(EventListener listener, [bool useCapture = false]) {
    _remove(listener, useCapture);
    return this;
  }

  bool dispatch(Event evt) {
    // TODO(jacobr): what is the correct behavior here. We could alternately
    // force the event to have the expected type.
    assert(evt.type == _type);
    return _ptr.dispatchEvent(LevelDom.unwrap(evt));
  }

  void _add(EventListener listener, bool useCapture) {
    _ptr.addEventListener(_type,
                          _findOrAddWrapper(listener, useCapture),
                          useCapture);
  }

  void _remove(EventListener listener, bool useCapture) {
    Function wrapper = _removeWrapper(listener, useCapture);
    if (wrapper !== null) {
      _ptr.removeEventListener(_type, wrapper, useCapture);
    }
  }

  Function _removeWrapper(EventListener listener, bool useCapture) {
    if (_wrappers === null) {
      return null;
    }
    for (int i = 0; i < _wrappers.length; i++) {
      _EventListenerWrapper wrapper = _wrappers[i];
      if (wrapper.raw === listener && wrapper.useCapture == useCapture) {
        // Order doesn't matter so we swap with the last element instead of
        // performing a more expensive remove from the middle of the list.
        if (i + 1 != _wrappers.length) {
          _wrappers[i] = _wrappers.removeLast();
        } else {
          _wrappers.removeLast();
        }
        return wrapper.wrapped;
      }
    }
    return null;
  }

  Function _findOrAddWrapper(EventListener listener, bool useCapture) {
    if (_wrappers === null) {
      _wrappers = <_EventListenerWrapper>[];
    } else {
      for (_EventListenerWrapper wrapper in _wrappers) {
        if (wrapper.raw === listener && wrapper.useCapture == useCapture) {
          return wrapper.wrapped;
        }
      }
    }
    final wrapped = (e) { listener(LevelDom.wrapEvent(e)); };
    _wrappers.add(new _EventListenerWrapper(listener, wrapped, useCapture));
    return wrapped;
  }
}

class EventTargetWrappingImplementation extends DOMWrapperBase implements EventTarget {
  Events _on;

  EventTargetWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  Events get on() {
    if (_on === null) {
      _on = new EventsImplementation._wrap(_ptr);
    }
    return _on;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class EventWrappingImplementation extends DOMWrapperBase implements Event {
  EventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory EventWrappingImplementation(String type, [bool canBubble = true,
      bool cancelable = true]) {
    final e = dom.document.createEvent("Event");
    e.initEvent(type, canBubble, cancelable);
    return LevelDom.wrapEvent(e);
  }

  bool get bubbles() => _ptr.bubbles;

  bool get cancelBubble() => _ptr.cancelBubble;

  void set cancelBubble(bool value) { _ptr.cancelBubble = value; }

  bool get cancelable() => _ptr.cancelable;

  EventTarget get currentTarget() => LevelDom.wrapEventTarget(_ptr.currentTarget);

  bool get defaultPrevented() => _ptr.defaultPrevented;

  int get eventPhase() => _ptr.eventPhase;

  bool get returnValue() => _ptr.returnValue;

  void set returnValue(bool value) { _ptr.returnValue = value; }

  EventTarget get srcElement() => LevelDom.wrapEventTarget(_ptr.srcElement);

  EventTarget get target() => LevelDom.wrapEventTarget(_ptr.target);

  int get timeStamp() => _ptr.timeStamp;

  String get type() => _ptr.type;

  void preventDefault() {
    _ptr.preventDefault();
    return;
  }

  void stopImmediatePropagation() {
    _ptr.stopImmediatePropagation();
    return;
  }

  void stopPropagation() {
    _ptr.stopPropagation();
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class HashChangeEventWrappingImplementation extends EventWrappingImplementation implements HashChangeEvent {
  HashChangeEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory HashChangeEventWrappingImplementation(String type, String oldURL,
      String newURL, [bool canBubble = true, bool cancelable = true]) {
    final e = dom.document.createEvent("HashChangeEvent");
    e.initHashChangeEvent(type, canBubble, cancelable, oldURL, newURL);
    return LevelDom.wrapHashChangeEvent(e);
  }

  String get newURL() => _ptr.newURL;

  String get oldURL() => _ptr.oldURL;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class KeyboardEventWrappingImplementation extends UIEventWrappingImplementation implements KeyboardEvent {
  KeyboardEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory KeyboardEventWrappingImplementation(String type, Window view,
      String keyIdentifier, int keyLocation, [bool canBubble = true,
      bool cancelable = true, bool ctrlKey = false, bool altKey = false,
      bool shiftKey = false, bool metaKey = false, bool altGraphKey = false]) {
    final e = dom.document.createEvent("KeyboardEvent");
    e.initKeyboardEvent(type, canBubble, cancelable, LevelDom.unwrap(view),
        keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey,
        altGraphKey);
    return LevelDom.wrapKeyboardEvent(e);
  }

  bool get altGraphKey() => _ptr.altGraphKey;

  bool get altKey() => _ptr.altKey;

  bool get ctrlKey() => _ptr.ctrlKey;

  String get keyIdentifier() => _ptr.keyIdentifier;

  int get keyLocation() => _ptr.keyLocation;

  bool get metaKey() => _ptr.metaKey;

  bool get shiftKey() => _ptr.shiftKey;

  bool getModifierState(String keyIdentifierArg) {
    return _ptr.getModifierState(keyIdentifierArg);
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef Object ComputeValue();

class _MeasurementRequest<T> {
  final ComputeValue computeValue;
  final Completer<T> completer;
  Object value;
  bool exception = false;
  _MeasurementRequest(this.computeValue, this.completer);
}

final _MEASUREMENT_MESSAGE = "DART-MEASURE";
List<_MeasurementRequest> _pendingRequests;
List<TimeoutHandler> _pendingMeasurementFrameCallbacks;
bool _nextMeasurementFrameScheduled = false;
bool _firstMeasurementRequest = true;

void _maybeScheduleMeasurementFrame() {
  if (_nextMeasurementFrameScheduled) return;

  _nextMeasurementFrameScheduled = true;
  // postMessage gives us a way to receive a callback after the current
  // event listener has unwound but before the browser has repainted.
  if (_firstMeasurementRequest) {
    // Messages from other windows do not cause a security risk as
    // all we care about is that _onCompleteMeasurementRequests is called
    // after the current event loop is unwound and calling the function is
    // a noop when zero requests are pending.
    window.on.message.add((e) => _completeMeasurementFutures());
    _firstMeasurementRequest = false;
  }

  // TODO(jacobr): other mechanisms such as setImmediate and
  // requestAnimationFrame may work better of platforms that support them.
  // The key is we need a way to execute code immediately after the current
  // event listener queue unwinds.
  window.postMessage(_MEASUREMENT_MESSAGE, "*");
}

/**
 * Registers a [callback] which is called after the next batch of measurements
 * completes. Even if no measurements completed, the callback is triggered
 * when they would have completed to avoid confusing bugs if it happened that
 * no measurements were actually requested.
 */
void _addMeasurementFrameCallback(TimeoutHandler callback) {
  if (_pendingMeasurementFrameCallbacks === null) {
    _pendingMeasurementFrameCallbacks = <TimeoutHandler>[];
    _maybeScheduleMeasurementFrame();
  }
  _pendingMeasurementFrameCallbacks.add(callback);
}

/**
 * Returns a [Future] whose value will be the result of evaluating
 * [computeValue] during the next safe measurement interval.
 * The next safe measurement interval is after the current event loop has
 * unwound but before the browser has rendered the page.
 * It is important that the [computeValue] function only queries the html
 * layout and html in any way.
 */
Future _createMeasurementFuture(ComputeValue computeValue,
                                Completer completer) {
  if (_pendingRequests === null) {
    _pendingRequests = <_MeasurementRequest>[];
    _maybeScheduleMeasurementFrame();
  }
  _pendingRequests.add(new _MeasurementRequest(computeValue, completer));
  return completer.future;
}

/**
 * Complete all pending measurement futures evaluating them in a single batch
 * so that the the browser is guaranteed to avoid multiple layouts.
 */
void _completeMeasurementFutures() {
  if (_nextMeasurementFrameScheduled == false) {
    // Ignore spurious call to this function.
    return;
  }

  _nextMeasurementFrameScheduled = false;
  // We must compute all new values before fulfilling the futures as
  // the onComplete callbacks for the futures could modify the DOM making
  // subsequent measurement calculations expensive to compute.
  if (_pendingRequests !== null) {
    for (_MeasurementRequest request in _pendingRequests) {
      try {
        request.value = request.computeValue();
      } catch(var e) {
        request.value = e;
        request.exception = true;
      }
    }
  }

  final completedRequests = _pendingRequests;
  final readyMeasurementFrameCallbacks = _pendingMeasurementFrameCallbacks;
  _pendingRequests = null;
  _pendingMeasurementFrameCallbacks = null;
  if (completedRequests !== null) {
    for (_MeasurementRequest request in completedRequests) {
      if (request.exception) {
        request.completer.completeException(request.value);
      } else {
        request.completer.complete(request.value);
      }
    }
  }

  if (readyMeasurementFrameCallbacks !== null) {
    for (TimeoutHandler handler in readyMeasurementFrameCallbacks) {
      // TODO(jacobr): wrap each call to a handler in a try-catch block.
      handler();
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class MessageEventWrappingImplementation extends EventWrappingImplementation implements MessageEvent {
  MessageEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory MessageEventWrappingImplementation(String type, String data,
      String origin, String lastEventId, Window source, MessagePort port,
      [bool canBubble = true, bool cancelable = true]) {
    final e = dom.document.createEvent("MessageEvent");
    e.initMessageEvent(type, canBubble, cancelable, data, origin, lastEventId,
        LevelDom.unwrap(source), LevelDom.unwrap(port));
    return LevelDom.wrapMessageEvent(e);
  }

  String get data() => _ptr.data;

  String get lastEventId() => _ptr.lastEventId;

  MessagePort get messagePort() => LevelDom.wrapMessagePort(_ptr.messagePort);

  String get origin() => _ptr.origin;

  Window get source() => LevelDom.wrapWindow(_ptr.source);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class MessagePortWrappingImplementation extends EventTargetWrappingImplementation implements MessagePort {
  MessagePortWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class MouseEventWrappingImplementation extends UIEventWrappingImplementation implements MouseEvent {
  MouseEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory MouseEventWrappingImplementation(String type, Window view, int detail,
      int screenX, int screenY, int clientX, int clientY, int button,
      [bool canBubble = true, bool cancelable = true, bool ctrlKey = false,
      bool altKey = false, bool shiftKey = false, bool metaKey = false,
      EventTarget relatedTarget = null]) {
    final e = dom.document.createEvent("MouseEvent");
    e.initMouseEvent(type, canBubble, cancelable, LevelDom.unwrap(view), detail,
        screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,
        button, LevelDom.unwrap(relatedTarget));
    return LevelDom.wrapMouseEvent(e);
  }

  bool get altKey() => _ptr.altKey;

  int get button() => _ptr.button;

  int get clientX() => _ptr.clientX;

  int get clientY() => _ptr.clientY;

  bool get ctrlKey() => _ptr.ctrlKey;

  Node get fromElement() => LevelDom.wrapNode(_ptr.fromElement);

  bool get metaKey() => _ptr.metaKey;

  int get offsetX() => _ptr.offsetX;

  int get offsetY() => _ptr.offsetY;

  EventTarget get relatedTarget() => LevelDom.wrapEventTarget(_ptr.relatedTarget);

  int get screenX() => _ptr.screenX;

  int get screenY() => _ptr.screenY;

  bool get shiftKey() => _ptr.shiftKey;

  Node get toElement() => LevelDom.wrapNode(_ptr.toElement);

  int get x() => _ptr.x;

  int get y() => _ptr.y;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class MutationEventWrappingImplementation extends EventWrappingImplementation implements MutationEvent {
  MutationEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory MutationEventWrappingImplementation(String type, Node relatedNode,
      String prevValue, String newValue, String attrName, int attrChange,
      [bool canBubble = true, bool cancelable = true]) {
    final e = dom.document.createEvent("MutationEvent");
    e.initMutationEvent(type, canBubble, cancelable,
        LevelDom.unwrap(relatedNode), prevValue, newValue, attrName,
        attrChange);
    return LevelDom.wrapMutationEvent(e);
  }

  int get attrChange() => _ptr.attrChange;

  String get attrName() => _ptr.attrName;

  String get newValue() => _ptr.newValue;

  String get prevValue() => _ptr.prevValue;

  Node get relatedNode() => LevelDom.wrapNode(_ptr.relatedNode);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _ChildrenNodeList implements NodeList {
  // Raw node.
  final _node;
  final _childNodes;

  _ChildrenNodeList._wrap(var node)
    : _childNodes = node.childNodes,
      _node = node;

  List<Node> _toList() {
    final output = new List(_childNodes.length);
    for (int i = 0, len = _childNodes.length; i < len; i++) {
      output[i] = LevelDom.wrapNode(_childNodes[i]);
    }
    return output;
  }

  Node get first() {
    return LevelDom.wrapNode(_node.firstChild);
  }

  void forEach(void f(Node element)) => _toList().forEach(f);

  Collection<Node> filter(bool f(Node element)) {
    List<Node> output = new List<Node>();
    forEach((Node element) {
      if (f(element)) {
        output.add(element);
      }
    });
    return output;
  }

  bool every(bool f(Node element)) {
    for(Node element in this) {
      if (!f(element)) {
        return false;
      }
    };
    return true;
  }

  bool some(bool f(Node element)) {
    for(Node element in this) {
      if (f(element)) {
        return true;
      }
    };
    return false;
  }

  /** @domName Node.hasChildNodes */
  bool isEmpty() {
    return !_node.hasChildNodes();
  }

  int get length() {
    return _childNodes.length;
  }

  Node operator [](int index) {
    return LevelDom.wrapNode(_childNodes[index]);
  }

  void operator []=(int index, Node value) {
    _childNodes[index] = LevelDom.unwrap(value);
  }

   void set length(int newLength) {
     throw new UnsupportedOperationException('');
   }

  /** @domName Node.appendChild */
  Node add(Node value) {
    _node.appendChild(LevelDom.unwrap(value));
    return value;
  }

  Node addLast(Node value) {
    _node.appendChild(LevelDom.unwrap(value));
    return value;
  }

  Iterator<Node> iterator() {
    return _toList().iterator();
  }

  void addAll(Collection<Node> collection) {
    for (Node node in collection) {
      _node.appendChild(LevelDom.unwrap(node));
    }
  }

  void sort(int compare(Node a, Node b)) {
    throw const UnsupportedOperationException('TODO(jacobr): should we impl?');
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw 'Not impl yet. todo(jacobr)';
  }

  void setRange(int start, int length, List from, [int startFrom = 0]) {
    throw const NotImplementedException();
  }

  void removeRange(int start, int length) {
    throw const NotImplementedException();
  }

  void insertRange(int start, int length, [initialValue = null]) {
    throw const NotImplementedException();
  }

  List getRange(int start, int length) {
    throw const NotImplementedException();
  }

  int indexOf(Node element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Node element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  void clear() {
    _node.textContent = '';
  }

  Node removeLast() {
    final last_ = this.last();
    if (last_ != null) {
      _node.removeChild(LevelDom.unwrap(last_));
    }
    return last_;
  }

  Node last() {
    return LevelDom.wrapNode(_node.lastChild);
  }
}

class NodeWrappingImplementation extends EventTargetWrappingImplementation implements Node {
  NodeList _nodes;

  NodeWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  void set nodes(Collection<Node> value) {
    // Copy list first since we don't want liveness during iteration.
    List copy = new List.from(value);
    nodes.clear();
    nodes.addAll(copy);
  }

  NodeList get nodes() {
    if (_nodes === null) {
      _nodes = new _ChildrenNodeList._wrap(_ptr);
    }
    return _nodes;
  }

  Node get nextNode() => LevelDom.wrapNode(_ptr.nextSibling);

  Document get document() => LevelDom.wrapDocument(_ptr.ownerDocument);

  Node get parent() => LevelDom.wrapNode(_ptr.parentNode);

  Node get previousNode() => LevelDom.wrapNode(_ptr.previousSibling);

  String get text() => _ptr.textContent;

  void set text(String value) { _ptr.textContent = value; }

  // New methods implemented.
  Node replaceWith(Node otherNode) {
    try {
      _ptr.parentNode.replaceChild(LevelDom.unwrap(otherNode), _ptr);
    } catch(var e) {
      // TODO(jacobr): what should we return on failure?
    }
    return this;
  }

  Node remove() {
    // TODO(jacobr): should we throw an exception if parent is already null?
    if (_ptr.parentNode !== null) {
      _ptr.parentNode.removeChild(_ptr);
    }
    return this;
  }

  /** @domName contains */
  bool contains(Node otherNode) {
    // TODO: Feature detect and use built in.
    while (otherNode != null && otherNode != this) {
      otherNode = otherNode.parent;
    }
    return otherNode == this;
  }

  // TODO(jacobr): remove when/if List supports a method similar to
  // insertBefore or we switch NodeList to implement LinkedList rather than
  // array.
  Node insertBefore(Node newChild, Node refChild) {
    return LevelDom.wrapNode(_ptr.insertBefore(
        LevelDom.unwrap(newChild), LevelDom.unwrap(refChild)));
  }

  Node clone(bool deep) {
    return LevelDom.wrapNode(_ptr.cloneNode(deep));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jacobr) add custom Events class.
class NotificationWrappingImplementation extends EventTargetWrappingImplementation implements Notification {
  NotificationWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get dir() { return _ptr.dir; }

  void set dir(String value) { _ptr.dir = value; }

  EventListener get onclick() { return LevelDom.wrapEventListener(_ptr.onclick); }

  void set onclick(EventListener value) { _ptr.onclick = LevelDom.unwrap(value); }

  EventListener get onclose() { return LevelDom.wrapEventListener(_ptr.onclose); }

  void set onclose(EventListener value) { _ptr.onclose = LevelDom.unwrap(value); }

  EventListener get ondisplay() { return LevelDom.wrapEventListener(_ptr.ondisplay); }

  void set ondisplay(EventListener value) { _ptr.ondisplay = LevelDom.unwrap(value); }

  EventListener get onerror() { return LevelDom.wrapEventListener(_ptr.onerror); }

  void set onerror(EventListener value) { _ptr.onerror = LevelDom.unwrap(value); }

  String get replaceId() { return _ptr.replaceId; }

  void set replaceId(String value) { _ptr.replaceId = value; }

  void cancel() {
    _ptr.cancel();
    return;
  }

  void show() {
    _ptr.show();
    return;
  }

  String get typeName() { return "Notification"; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class ObjectElementWrappingImplementation extends ElementWrappingImplementation implements ObjectElement {
  ObjectElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get align() { return _ptr.align; }

  void set align(String value) { _ptr.align = value; }

  String get archive() { return _ptr.archive; }

  void set archive(String value) { _ptr.archive = value; }

  String get border() { return _ptr.border; }

  void set border(String value) { _ptr.border = value; }

  String get code() { return _ptr.code; }

  void set code(String value) { _ptr.code = value; }

  String get codeBase() { return _ptr.codeBase; }

  void set codeBase(String value) { _ptr.codeBase = value; }

  String get codeType() { return _ptr.codeType; }

  void set codeType(String value) { _ptr.codeType = value; }

  Document get contentDocument() { return LevelDom.wrapDocument(_ptr.contentDocument); }

  String get data() { return _ptr.data; }

  void set data(String value) { _ptr.data = value; }

  bool get declare() { return _ptr.declare; }

  void set declare(bool value) { _ptr.declare = value; }

  FormElement get form() { return LevelDom.wrapFormElement(_ptr.form); }

  String get height() { return _ptr.height; }

  void set height(String value) { _ptr.height = value; }

  int get hspace() { return _ptr.hspace; }

  void set hspace(int value) { _ptr.hspace = value; }

  String get name() { return _ptr.name; }

  void set name(String value) { _ptr.name = value; }

  String get standby() { return _ptr.standby; }

  void set standby(String value) { _ptr.standby = value; }

  String get type() { return _ptr.type; }

  void set type(String value) { _ptr.type = value; }

  String get useMap() { return _ptr.useMap; }

  void set useMap(String value) { _ptr.useMap = value; }

  String get validationMessage() { return _ptr.validationMessage; }

  ValidityState get validity() { return LevelDom.wrapValidityState(_ptr.validity); }

  int get vspace() { return _ptr.vspace; }

  void set vspace(int value) { _ptr.vspace = value; }

  String get width() { return _ptr.width; }

  void set width(String value) { _ptr.width = value; }

  bool get willValidate() { return _ptr.willValidate; }

  bool checkValidity() {
    return _ptr.checkValidity();
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(error);
    return;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class OverflowEventWrappingImplementation extends EventWrappingImplementation implements OverflowEvent {
  OverflowEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  /** @domName OverflowEvent.initOverflowEvent */
  factory OverflowEventWrappingImplementation(int orient,
      bool horizontalOverflow, bool verticalOverflow) {
    final e = dom.document.createEvent("OverflowEvent");
    e.initOverflowEvent(orient, horizontalOverflow, verticalOverflow);
    return LevelDom.wrapOverflowEvent(e);
  }

  bool get horizontalOverflow() => _ptr.horizontalOverflow;

  int get orient() => _ptr.orient;

  bool get verticalOverflow() => _ptr.verticalOverflow;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class PageTransitionEventWrappingImplementation extends EventWrappingImplementation implements PageTransitionEvent {
  PageTransitionEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory PageTransitionEventWrappingImplementation(String type,
      [bool canBubble = true, bool cancelable = true,
      bool persisted = false]) {
    final e = dom.document.createEvent("PageTransitionEvent");
    e.initPageTransitionEvent(type, canBubble, cancelable, persisted);
    return LevelDom.wrapPageTransitionEvent(e);
  }

  bool get persisted() => _ptr.persisted;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class PopStateEventWrappingImplementation extends EventWrappingImplementation implements PopStateEvent {
  PopStateEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory PopStateEventWrappingImplementation(String type, Object state,
      [bool canBubble = true, bool cancelable = true]) {
    final e = dom.document.createEvent("PopStateEvent");
    e.initPopStateEvent(type, canBubble, cancelable, state);
    return LevelDom.wrapPopStateEvent(e);
  }

  String get state() => _ptr.state;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class ProgressEventWrappingImplementation extends EventWrappingImplementation implements ProgressEvent {
  ProgressEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory ProgressEventWrappingImplementation(String type, int loaded,
      [bool canBubble = true, bool cancelable = true,
      bool lengthComputable = false, int total = 0]) {
    final e = dom.document.createEvent("ProgressEvent");
    e.initProgressEvent(type, canBubble, cancelable, lengthComputable, loaded,
        total);
    return LevelDom.wrapProgressEvent(e);
  }

  bool get lengthComputable() => _ptr.lengthComputable;

  int get loaded() => _ptr.loaded;

  int get total() => _ptr.total;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class SharedWorkerWrappingImplementation extends AbstractWorkerWrappingImplementation implements SharedWorker {
  SharedWorkerWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  MessagePort get port() { return LevelDom.wrapMessagePort(_ptr.port); }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class StorageEventWrappingImplementation extends EventWrappingImplementation implements StorageEvent {
  StorageEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory StorageEventWrappingImplementation(String type, String key,
      String url, Storage storageArea, [bool canBubble = true,
      bool cancelable = true, String oldValue = null,
      String newValue = null]) {
    final e = dom.document.createEvent("StorageEvent");
    e.initStorageEvent(type, canBubble, cancelable, key, oldValue, newValue,
        url, LevelDom.unwrap(storageArea));
    return LevelDom.wrapStorageEvent(e);
  }

  String get key() => _ptr.key;

  String get newValue() => _ptr.newValue;

  String get oldValue() => _ptr.oldValue;

  Storage get storageArea() => LevelDom.wrapStorage(_ptr.storageArea);

  String get url() => _ptr.url;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGDocumentWrappingImplementation extends DocumentWrappingImplementation implements SVGDocument {
  SVGDocumentWrappingImplementation._wrap(dom.SVGDocument ptr) : super._wrap(ptr, ptr.rootElement);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class SVGElementWrappingImplementation extends ElementWrappingImplementation implements SVGElement {
  SVGElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  factory SVGElementWrappingImplementation.tag(String tag) =>
    LevelDom.wrapSVGElement(dom.document.createElementNS(
        "http://www.w3.org/2000/svg", tag));

  String get id() { return _ptr.id; }

  void set id(String value) { _ptr.id = value; }

  SVGSVGElement get ownerSVGElement() { return LevelDom.wrapSVGSVGElement(_ptr.ownerSVGElement); }

  SVGElement get viewportElement() { return LevelDom.wrapSVGElement(_ptr.viewportElement); }

  String get xmlbase() { return _ptr.xmlbase; }

  void set xmlbase(String value) { _ptr.xmlbase = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class SVGElementInstanceWrappingImplementation extends EventTargetWrappingImplementation implements SVGElementInstance {
  SVGElementInstanceWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  SVGElementInstanceList get childNodes() { return LevelDom.wrapSVGElementInstanceList(_ptr.childNodes); }

  SVGElement get correspondingElement() { return LevelDom.wrapSVGElement(_ptr.correspondingElement); }

  SVGUseElement get correspondingUseElement() { return LevelDom.wrapSVGUseElement(_ptr.correspondingUseElement); }

  SVGElementInstance get firstChild() { return LevelDom.wrapSVGElementInstance(_ptr.firstChild); }

  SVGElementInstance get lastChild() { return LevelDom.wrapSVGElementInstance(_ptr.lastChild); }

  SVGElementInstance get nextSibling() { return LevelDom.wrapSVGElementInstance(_ptr.nextSibling); }

  SVGElementInstance get parentNode() { return LevelDom.wrapSVGElementInstance(_ptr.parentNode); }

  SVGElementInstance get previousSibling() { return LevelDom.wrapSVGElementInstance(_ptr.previousSibling); }

}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class SVGSVGElementWrappingImplementation extends SVGElementWrappingImplementation implements SVGSVGElement {
  SVGSVGElementWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  factory SVGSVGElementWrappingImplementation() {
    var el = new SVGElement.tag("svg");
    // The SVG spec requires the version attribute to match the spec version
    el.attributes['version'] = 1.1;
    return el;
  }

  String get contentScriptType() { return _ptr.contentScriptType; }

  void set contentScriptType(String value) { _ptr.contentScriptType = value; }

  String get contentStyleType() { return _ptr.contentStyleType; }

  void set contentStyleType(String value) { _ptr.contentStyleType = value; }

  num get currentScale() { return _ptr.currentScale; }

  void set currentScale(num value) { _ptr.currentScale = value; }

  SVGPoint get currentTranslate() { return LevelDom.wrapSVGPoint(_ptr.currentTranslate); }

  SVGAnimatedLength get height() { return LevelDom.wrapSVGAnimatedLength(_ptr.height); }

  num get pixelUnitToMillimeterX() { return _ptr.pixelUnitToMillimeterX; }

  num get pixelUnitToMillimeterY() { return _ptr.pixelUnitToMillimeterY; }

  num get screenPixelToMillimeterX() { return _ptr.screenPixelToMillimeterX; }

  num get screenPixelToMillimeterY() { return _ptr.screenPixelToMillimeterY; }

  bool get useCurrentView() { return _ptr.useCurrentView; }

  void set useCurrentView(bool value) { _ptr.useCurrentView = value; }

  SVGRect get viewport() { return LevelDom.wrapSVGRect(_ptr.viewport); }

  SVGAnimatedLength get width() { return LevelDom.wrapSVGAnimatedLength(_ptr.width); }

  SVGAnimatedLength get x() { return LevelDom.wrapSVGAnimatedLength(_ptr.x); }

  SVGAnimatedLength get y() { return LevelDom.wrapSVGAnimatedLength(_ptr.y); }

  bool animationsPaused() {
    return _ptr.animationsPaused();
  }

  bool checkEnclosure(SVGElement element, SVGRect rect) {
    return _ptr.checkEnclosure(LevelDom.unwrap(element), LevelDom.unwrap(rect));
  }

  bool checkIntersection(SVGElement element, SVGRect rect) {
    return _ptr.checkIntersection(LevelDom.unwrap(element), LevelDom.unwrap(rect));
  }

  SVGAngle createSVGAngle() {
    return LevelDom.wrapSVGAngle(_ptr.createSVGAngle());
  }

  SVGLength createSVGLength() {
    return LevelDom.wrapSVGLength(_ptr.createSVGLength());
  }

  SVGMatrix createSVGMatrix() {
    return LevelDom.wrapSVGMatrix(_ptr.createSVGMatrix());
  }

  SVGNumber createSVGNumber() {
    return LevelDom.wrapSVGNumber(_ptr.createSVGNumber());
  }

  SVGPoint createSVGPoint() {
    return LevelDom.wrapSVGPoint(_ptr.createSVGPoint());
  }

  SVGRect createSVGRect() {
    return LevelDom.wrapSVGRect(_ptr.createSVGRect());
  }

  SVGTransform createSVGTransform() {
    return LevelDom.wrapSVGTransform(_ptr.createSVGTransform());
  }

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) {
    return LevelDom.wrapSVGTransform(_ptr.createSVGTransformFromMatrix(LevelDom.unwrap(matrix)));
  }

  void deselectAll() {
    _ptr.deselectAll();
    return;
  }

  void forceRedraw() {
    _ptr.forceRedraw();
    return;
  }

  num getCurrentTime() {
    return _ptr.getCurrentTime();
  }

  Element getElementById(String elementId) {
    return LevelDom.wrapElement(_ptr.getElementById(elementId));
  }

  ElementList getEnclosureList(SVGRect rect, SVGElement referenceElement) {
    return LevelDom.wrapElementList(_ptr.getEnclosureList(LevelDom.unwrap(rect), LevelDom.unwrap(referenceElement)));
  }

  ElementList getIntersectionList(SVGRect rect, SVGElement referenceElement) {
    return LevelDom.wrapElementList(_ptr.getIntersectionList(LevelDom.unwrap(rect), LevelDom.unwrap(referenceElement)));
  }

  void pauseAnimations() {
    _ptr.pauseAnimations();
    return;
  }

  void setCurrentTime(num seconds) {
    _ptr.setCurrentTime(seconds);
    return;
  }

  int suspendRedraw(int maxWaitMilliseconds) {
    return _ptr.suspendRedraw(maxWaitMilliseconds);
  }

  void unpauseAnimations() {
    _ptr.unpauseAnimations();
    return;
  }

  void unsuspendRedraw(int suspendHandleId) {
    _ptr.unsuspendRedraw(suspendHandleId);
    return;
  }

  void unsuspendRedrawAll() {
    _ptr.unsuspendRedrawAll();
    return;
  }

  // From SVGTests

  SVGStringList get requiredExtensions() { return LevelDom.wrapSVGStringList(_ptr.requiredExtensions); }

  SVGStringList get requiredFeatures() { return LevelDom.wrapSVGStringList(_ptr.requiredFeatures); }

  SVGStringList get systemLanguage() { return LevelDom.wrapSVGStringList(_ptr.systemLanguage); }

  bool hasExtension(String extension) {
    return _ptr.hasExtension(extension);
  }

  // From SVGLangSpace

  String get xmllang() { return _ptr.xmllang; }

  void set xmllang(String value) { _ptr.xmllang = value; }

  String get xmlspace() { return _ptr.xmlspace; }

  void set xmlspace(String value) { _ptr.xmlspace = value; }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() { return LevelDom.wrapSVGAnimatedBoolean(_ptr.externalResourcesRequired); }

  // From SVGStylable

  SVGAnimatedString get className() { return LevelDom.wrapSVGAnimatedString(_ptr.className); }

  CSSStyleDeclaration get style() { return LevelDom.wrapCSSStyleDeclaration(_ptr.style); }

  CSSValue getPresentationAttribute(String name) {
    return LevelDom.wrapCSSValue(_ptr.getPresentationAttribute(name));
  }

  // From SVGLocatable

  SVGElement get farthestViewportElement() { return LevelDom.wrapSVGElement(_ptr.farthestViewportElement); }

  SVGElement get nearestViewportElement() { return LevelDom.wrapSVGElement(_ptr.nearestViewportElement); }

  SVGRect getBBox() {
    return LevelDom.wrapSVGRect(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return LevelDom.wrapSVGMatrix(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return LevelDom.wrapSVGMatrix(_ptr.getTransformToElement(LevelDom.unwrap(element)));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() { return LevelDom.wrapSVGAnimatedPreserveAspectRatio(_ptr.preserveAspectRatio); }

  SVGAnimatedRect get viewBox() { return LevelDom.wrapSVGAnimatedRect(_ptr.viewBox); }

  // From SVGZoomAndPan

  int get zoomAndPan() { return _ptr.zoomAndPan; }

  void set zoomAndPan(int value) { _ptr.zoomAndPan = value; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class TextEventWrappingImplementation extends UIEventWrappingImplementation implements TextEvent {
  TextEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory TextEventWrappingImplementation(String type, Window view, String data,
      [bool canBubble = true, bool cancelable = true]) {
    final e = dom.document.createEvent("TextEvent");
    e.initTextEvent(type, canBubble, cancelable, LevelDom.unwrap(view), data);
    return LevelDom.wrapTextEvent(e);
  }

  String get data() => _ptr.data;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class TextWrappingImplementation extends CharacterDataWrappingImplementation implements Text {
  /** @domName Document.createTextNode */
  factory TextWrappingImplementation(String content) {
    return new TextWrappingImplementation._wrap(
        dom.document.createTextNode(content));
  }

  TextWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  String get wholeText() => _ptr.wholeText;

  Text replaceWholeText([String content = null]) {
    if (content === null) {
      return LevelDom.wrapText(_ptr.replaceWholeText());
    } else {
      return LevelDom.wrapText(_ptr.replaceWholeText(content));
    }
  }

  Text splitText([int offset = null]) {
    if (offset === null) {
      return LevelDom.wrapText(_ptr.splitText());
    } else {
      return LevelDom.wrapText(_ptr.splitText(offset));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class TouchEventWrappingImplementation extends UIEventWrappingImplementation implements TouchEvent {
  TouchEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory TouchEventWrappingImplementation(TouchList touches, TouchList targetTouches,
      TouchList changedTouches, String type, Window view, int screenX,
      int screenY, int clientX, int clientY, [bool ctrlKey = false,
      bool altKey = false, bool shiftKey = false, bool metaKey = false]) {
    final e = dom.document.createEvent("TouchEvent");
    e.initTouchEvent(LevelDom.unwrap(touches), LevelDom.unwrap(targetTouches),
        LevelDom.unwrap(changedTouches), type, LevelDom.unwrap(view), screenX,
        screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
    return LevelDom.wrapTouchEvent(e);
  }

  bool get altKey() => _ptr.altKey;

  TouchList get changedTouches() => LevelDom.wrapTouchList(_ptr.changedTouches);

  bool get ctrlKey() => _ptr.ctrlKey;

  bool get metaKey() => _ptr.metaKey;

  bool get shiftKey() => _ptr.shiftKey;

  TouchList get targetTouches() => LevelDom.wrapTouchList(_ptr.targetTouches);

  TouchList get touches() => LevelDom.wrapTouchList(_ptr.touches);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class TransitionEventWrappingImplementation extends EventWrappingImplementation implements TransitionEvent {
  static String _name;

  TransitionEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  static String get _eventName() {
    if (_name != null) return _name;

    try {
      dom.document.createEvent("WebKitTransitionEvent");
      _name = "WebKitTransitionEvent";
    } catch (var e) {
      _name = "TransitionEvent";
    }
    return _name;
  }

  factory TransitionEventWrappingImplementation(String type,
      String propertyName, double elapsedTime, [bool canBubble = true,
      bool cancelable = true]) {
    final e = dom.document.createEvent(_eventName);
    e.initWebKitTransitionEvent(type, canBubble, cancelable, propertyName,
        elapsedTime);
    return LevelDom.wrapTransitionEvent(e);
  }

  num get elapsedTime() => _ptr.elapsedTime;

  String get propertyName() => _ptr.propertyName;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class UIEventWrappingImplementation extends EventWrappingImplementation implements UIEvent {
  UIEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory UIEventWrappingImplementation(String type, Window view, int detail,
      [bool canBubble = true, bool cancelable = true]) {
    final e = dom.document.createEvent("UIEvent");
    e.initUIEvent(type, canBubble, cancelable, LevelDom.unwrap(view), detail);
    return LevelDom.wrapUIEvent(e);
  }

  int get charCode() => _ptr.charCode;

  int get detail() => _ptr.detail;

  int get keyCode() => _ptr.keyCode;

  int get layerX() => _ptr.layerX;

  int get layerY() => _ptr.layerY;

  int get pageX() => _ptr.pageX;

  int get pageY() => _ptr.pageY;

  Window get view() => LevelDom.wrapWindow(_ptr.view);

  int get which() => _ptr.which;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jacobr) add events.
class WebSocketWrappingImplementation extends EventTargetWrappingImplementation implements WebSocket {
  WebSocketWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  String get URL() { return _ptr.URL; }

  String get binaryType() { return _ptr.binaryType; }

  void set binaryType(String value) { _ptr.binaryType = value; }

  int get bufferedAmount() { return _ptr.bufferedAmount; }

  EventListener get onclose() { return LevelDom.wrapEventListener(_ptr.onclose); }

  void set onclose(EventListener value) { _ptr.onclose = LevelDom.unwrap(value); }

  EventListener get onerror() { return LevelDom.wrapEventListener(_ptr.onerror); }

  void set onerror(EventListener value) { _ptr.onerror = LevelDom.unwrap(value); }

  EventListener get onmessage() { return LevelDom.wrapEventListener(_ptr.onmessage); }

  void set onmessage(EventListener value) { _ptr.onmessage = LevelDom.unwrap(value); }

  EventListener get onopen() { return LevelDom.wrapEventListener(_ptr.onopen); }

  void set onopen(EventListener value) { _ptr.onopen = LevelDom.unwrap(value); }

  String get protocol() { return _ptr.protocol; }

  int get readyState() { return _ptr.readyState; }

  void close() {
    _ptr.close();
    return;
  }

  bool send(String data) {
    return _ptr.send(data);
  }

  String get typeName() { return "WebSocket"; }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class WheelEventWrappingImplementation extends UIEventWrappingImplementation implements WheelEvent {
  WheelEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory WheelEventWrappingImplementation(int deltaX, int deltaY, Window view,
      int screenX, int screenY, int clientX, int clientY, [bool ctrlKey = false,
      bool altKey = false, bool shiftKey = false, bool metaKey = false]) {
    final e = dom.document.createEvent("WheelEvent");
    e.initWebKitWheelEvent(deltaX, deltaY, LevelDom.unwrap(view), screenX, screenY,
        clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
    return LevelDom.wrapWheelEvent(e);
  }

  bool get altKey() => _ptr.altKey;

  int get clientX() => _ptr.clientX;

  int get clientY() => _ptr.clientY;

  bool get ctrlKey() => _ptr.ctrlKey;

  bool get metaKey() => _ptr.metaKey;

  int get offsetX() => _ptr.offsetX;

  int get offsetY() => _ptr.offsetY;

  int get screenX() => _ptr.screenX;

  int get screenY() => _ptr.screenY;

  bool get shiftKey() => _ptr.shiftKey;

  int get wheelDelta() => _ptr.wheelDelta;

  int get wheelDeltaX() => _ptr.wheelDeltaX;

  int get wheelDeltaY() => _ptr.wheelDeltaY;

  int get x() => _ptr.x;

  int get y() => _ptr.y;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jacobr): define a base class containing the overlap between
// this class and ElementEvents.
class WindowEventsImplementation extends EventsImplementation
      implements WindowEvents {
  WindowEventsImplementation._wrap(_ptr) : super._wrap(_ptr);

  EventListenerList get abort() => _get('abort');
  EventListenerList get beforeUnload() => _get('beforeunload');
  EventListenerList get blur() => _get('blur');
  EventListenerList get canPlay() => _get('canplay');
  EventListenerList get canPlayThrough() => _get('canplaythrough');
  EventListenerList get change() => _get('change');
  EventListenerList get click() => _get('click');
  EventListenerList get contextMenu() => _get('contextmenu');
  EventListenerList get dblClick() => _get('dblclick');
  EventListenerList get deviceMotion() => _get('devicemotion');
  EventListenerList get deviceOrientation() => _get('deviceorientation');
  EventListenerList get drag() => _get('drag');
  EventListenerList get dragEnd() => _get('dragend');
  EventListenerList get dragEnter() => _get('dragenter');
  EventListenerList get dragLeave() => _get('dragleave');
  EventListenerList get dragOver() => _get('dragover');
  EventListenerList get dragStart() => _get('dragstart');
  EventListenerList get drop() => _get('drop');
  EventListenerList get durationChange() => _get('durationchange');
  EventListenerList get emptied() => _get('emptied');
  EventListenerList get ended() => _get('ended');
  EventListenerList get error() => _get('error');
  EventListenerList get focus() => _get('focus');
  EventListenerList get hashChange() => _get('hashchange');
  EventListenerList get input() => _get('input');
  EventListenerList get invalid() => _get('invalid');
  EventListenerList get keyDown() => _get('keydown');
  EventListenerList get keyPress() => _get('keypress');
  EventListenerList get keyUp() => _get('keyup');
  EventListenerList get load() => _get('load');
  EventListenerList get loadedData() => _get('loadeddata');
  EventListenerList get loadedMetaData() => _get('loadedmetadata');
  EventListenerList get loadStart() => _get('loadstart');
  EventListenerList get message() => _get('message');
  EventListenerList get mouseDown() => _get('mousedown');
  EventListenerList get mouseMove() => _get('mousemove');
  EventListenerList get mouseOut() => _get('mouseout');
  EventListenerList get mouseOver() => _get('mouseover');
  EventListenerList get mouseUp() => _get('mouseup');
  EventListenerList get mouseWheel() => _get('mousewheel');
  EventListenerList get offline() => _get('offline');
  EventListenerList get online() => _get('online');
  EventListenerList get pageHide() => _get('pagehide');
  EventListenerList get pageShow() => _get('pageshow');
  EventListenerList get pause() => _get('pause');
  EventListenerList get play() => _get('play');
  EventListenerList get playing() => _get('playing');
  EventListenerList get popState() => _get('popstate');
  EventListenerList get progress() => _get('progress');
  EventListenerList get rateChange() => _get('ratechange');
  EventListenerList get reset() => _get('reset');
  EventListenerList get resize() => _get('resize');
  EventListenerList get scroll() => _get('scroll');
  EventListenerList get search() => _get('search');
  EventListenerList get seeked() => _get('seeked');
  EventListenerList get seeking() => _get('seeking');
  EventListenerList get select() => _get('select');
  EventListenerList get stalled() => _get('stalled');
  EventListenerList get storage() => _get('storage');
  EventListenerList get submit() => _get('submit');
  EventListenerList get suspend() => _get('suspend');
  EventListenerList get timeUpdate() => _get('timeupdate');
  EventListenerList get touchCancel() => _get('touchcancel');
  EventListenerList get touchEnd() => _get('touchend');
  EventListenerList get touchMove() => _get('touchmove');
  EventListenerList get touchStart() => _get('touchstart');
  EventListenerList get unLoad() => _get('unload');
  EventListenerList get volumeChange() => _get('volumechange');
  EventListenerList get waiting() => _get('waiting');
  EventListenerList get animationEnd() => _get('webkitAnimationEnd');
  EventListenerList get animationIteration() => _get('webkitAnimationIteration');
  EventListenerList get animationStart() => _get('webkitAnimationStart');
  EventListenerList get transitionEnd() => _get('webkitTransitionEnd');
  EventListenerList get contentLoaded() => _get('DOMContentLoaded');
}

/** @domName Window */
class WindowWrappingImplementation extends EventTargetWrappingImplementation implements Window {
  WindowWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  DOMApplicationCache get applicationCache() => LevelDom.wrapDOMApplicationCache(_ptr.applicationCache);

  Navigator get clientInformation() => LevelDom.wrapNavigator(_ptr.clientInformation);

  void set clientInformation(Navigator value) { _ptr.clientInformation = LevelDom.unwrap(value); }

  bool get closed() => _ptr.closed;

  Console get console() => LevelDom.wrapConsole(_ptr.console);

  void set console(Console value) { _ptr.console = LevelDom.unwrap(value); }

  Crypto get crypto() => LevelDom.wrapCrypto(_ptr.crypto);

  String get defaultStatus() => _ptr.defaultStatus;

  void set defaultStatus(String value) { _ptr.defaultStatus = value; }

  num get devicePixelRatio() => _ptr.devicePixelRatio;

  void set devicePixelRatio(num value) { _ptr.devicePixelRatio = value; }

  Document get document() => LevelDom.wrapDocument(_ptr.document);

  Event get event() => LevelDom.wrapEvent(_ptr.event);

  void set event(Event value) { _ptr.event = LevelDom.unwrap(value); }

  Element get frameElement() => LevelDom.wrapElement(_ptr.frameElement);

  Window get frames() => LevelDom.wrapWindow(_ptr.frames);

  void set frames(Window value) { _ptr.frames = LevelDom.unwrap(value); }

  History get history() => LevelDom.wrapHistory(_ptr.history);

  void set history(History value) { _ptr.history = LevelDom.unwrap(value); }

  int get innerHeight() => _ptr.innerHeight;

  void set innerHeight(int value) { _ptr.innerHeight = value; }

  int get innerWidth() => _ptr.innerWidth;

  void set innerWidth(int value) { _ptr.innerWidth = value; }

  int get length() => _ptr.length;

  void set length(int value) { _ptr.length = value; }

  Storage get localStorage() => LevelDom.wrapStorage(_ptr.localStorage);

  Location get location() => LevelDom.wrapLocation(_ptr.location);

  void set location(Location value) { _ptr.location = LevelDom.unwrap(value); }

  BarInfo get locationbar() => LevelDom.wrapBarInfo(_ptr.locationbar);

  void set locationbar(BarInfo value) { _ptr.locationbar = LevelDom.unwrap(value); }

  BarInfo get menubar() => LevelDom.wrapBarInfo(_ptr.menubar);

  void set menubar(BarInfo value) { _ptr.menubar = LevelDom.unwrap(value); }

  String get name() => _ptr.name;

  void set name(String value) { _ptr.name = value; }

  Navigator get navigator() => LevelDom.wrapNavigator(_ptr.navigator);

  void set navigator(Navigator value) { _ptr.navigator = LevelDom.unwrap(value); }

  bool get offscreenBuffering() => _ptr.offscreenBuffering;

  void set offscreenBuffering(bool value) { _ptr.offscreenBuffering = value; }

  EventListener get onabort() => LevelDom.wrapEventListener(_ptr.onabort);

  void set onabort(EventListener value) { _ptr.onabort = LevelDom.unwrap(value); }

  EventListener get onbeforeunload() => LevelDom.wrapEventListener(_ptr.onbeforeunload);

  void set onbeforeunload(EventListener value) { _ptr.onbeforeunload = LevelDom.unwrap(value); }

  EventListener get onblur() => LevelDom.wrapEventListener(_ptr.onblur);

  void set onblur(EventListener value) { _ptr.onblur = LevelDom.unwrap(value); }

  EventListener get oncanplay() => LevelDom.wrapEventListener(_ptr.oncanplay);

  void set oncanplay(EventListener value) { _ptr.oncanplay = LevelDom.unwrap(value); }

  EventListener get oncanplaythrough() => LevelDom.wrapEventListener(_ptr.oncanplaythrough);

  void set oncanplaythrough(EventListener value) { _ptr.oncanplaythrough = LevelDom.unwrap(value); }

  EventListener get onchange() => LevelDom.wrapEventListener(_ptr.onchange);

  void set onchange(EventListener value) { _ptr.onchange = LevelDom.unwrap(value); }

  EventListener get onclick() => LevelDom.wrapEventListener(_ptr.onclick);

  void set onclick(EventListener value) { _ptr.onclick = LevelDom.unwrap(value); }

  EventListener get oncontextmenu() => LevelDom.wrapEventListener(_ptr.oncontextmenu);

  void set oncontextmenu(EventListener value) { _ptr.oncontextmenu = LevelDom.unwrap(value); }

  EventListener get ondblclick() => LevelDom.wrapEventListener(_ptr.ondblclick);

  void set ondblclick(EventListener value) { _ptr.ondblclick = LevelDom.unwrap(value); }

  EventListener get ondevicemotion() => LevelDom.wrapEventListener(_ptr.ondevicemotion);

  void set ondevicemotion(EventListener value) { _ptr.ondevicemotion = LevelDom.unwrap(value); }

  EventListener get ondeviceorientation() => LevelDom.wrapEventListener(_ptr.ondeviceorientation);

  void set ondeviceorientation(EventListener value) { _ptr.ondeviceorientation = LevelDom.unwrap(value); }

  EventListener get ondrag() => LevelDom.wrapEventListener(_ptr.ondrag);

  void set ondrag(EventListener value) { _ptr.ondrag = LevelDom.unwrap(value); }

  EventListener get ondragend() => LevelDom.wrapEventListener(_ptr.ondragend);

  void set ondragend(EventListener value) { _ptr.ondragend = LevelDom.unwrap(value); }

  EventListener get ondragenter() => LevelDom.wrapEventListener(_ptr.ondragenter);

  void set ondragenter(EventListener value) { _ptr.ondragenter = LevelDom.unwrap(value); }

  EventListener get ondragleave() => LevelDom.wrapEventListener(_ptr.ondragleave);

  void set ondragleave(EventListener value) { _ptr.ondragleave = LevelDom.unwrap(value); }

  EventListener get ondragover() => LevelDom.wrapEventListener(_ptr.ondragover);

  void set ondragover(EventListener value) { _ptr.ondragover = LevelDom.unwrap(value); }

  EventListener get ondragstart() => LevelDom.wrapEventListener(_ptr.ondragstart);

  void set ondragstart(EventListener value) { _ptr.ondragstart = LevelDom.unwrap(value); }

  EventListener get ondrop() => LevelDom.wrapEventListener(_ptr.ondrop);

  void set ondrop(EventListener value) { _ptr.ondrop = LevelDom.unwrap(value); }

  EventListener get ondurationchange() => LevelDom.wrapEventListener(_ptr.ondurationchange);

  void set ondurationchange(EventListener value) { _ptr.ondurationchange = LevelDom.unwrap(value); }

  EventListener get onemptied() => LevelDom.wrapEventListener(_ptr.onemptied);

  void set onemptied(EventListener value) { _ptr.onemptied = LevelDom.unwrap(value); }

  EventListener get onended() => LevelDom.wrapEventListener(_ptr.onended);

  void set onended(EventListener value) { _ptr.onended = LevelDom.unwrap(value); }

  EventListener get onerror() => LevelDom.wrapEventListener(_ptr.onerror);

  void set onerror(EventListener value) { _ptr.onerror = LevelDom.unwrap(value); }

  EventListener get onfocus() => LevelDom.wrapEventListener(_ptr.onfocus);

  void set onfocus(EventListener value) { _ptr.onfocus = LevelDom.unwrap(value); }

  EventListener get onhashchange() => LevelDom.wrapEventListener(_ptr.onhashchange);

  void set onhashchange(EventListener value) { _ptr.onhashchange = LevelDom.unwrap(value); }

  EventListener get oninput() => LevelDom.wrapEventListener(_ptr.oninput);

  void set oninput(EventListener value) { _ptr.oninput = LevelDom.unwrap(value); }

  EventListener get oninvalid() => LevelDom.wrapEventListener(_ptr.oninvalid);

  void set oninvalid(EventListener value) { _ptr.oninvalid = LevelDom.unwrap(value); }

  EventListener get onkeydown() => LevelDom.wrapEventListener(_ptr.onkeydown);

  void set onkeydown(EventListener value) { _ptr.onkeydown = LevelDom.unwrap(value); }

  EventListener get onkeypress() => LevelDom.wrapEventListener(_ptr.onkeypress);

  void set onkeypress(EventListener value) { _ptr.onkeypress = LevelDom.unwrap(value); }

  EventListener get onkeyup() => LevelDom.wrapEventListener(_ptr.onkeyup);

  void set onkeyup(EventListener value) { _ptr.onkeyup = LevelDom.unwrap(value); }

  EventListener get onload() => LevelDom.wrapEventListener(_ptr.onload);

  void set onload(EventListener value) { _ptr.onload = LevelDom.unwrap(value); }

  EventListener get onloadeddata() => LevelDom.wrapEventListener(_ptr.onloadeddata);

  void set onloadeddata(EventListener value) { _ptr.onloadeddata = LevelDom.unwrap(value); }

  EventListener get onloadedmetadata() => LevelDom.wrapEventListener(_ptr.onloadedmetadata);

  void set onloadedmetadata(EventListener value) { _ptr.onloadedmetadata = LevelDom.unwrap(value); }

  EventListener get onloadstart() => LevelDom.wrapEventListener(_ptr.onloadstart);

  void set onloadstart(EventListener value) { _ptr.onloadstart = LevelDom.unwrap(value); }

  EventListener get onmessage() => LevelDom.wrapEventListener(_ptr.onmessage);

  void set onmessage(EventListener value) { _ptr.onmessage = LevelDom.unwrap(value); }

  EventListener get onmousedown() => LevelDom.wrapEventListener(_ptr.onmousedown);

  void set onmousedown(EventListener value) { _ptr.onmousedown = LevelDom.unwrap(value); }

  EventListener get onmousemove() => LevelDom.wrapEventListener(_ptr.onmousemove);

  void set onmousemove(EventListener value) { _ptr.onmousemove = LevelDom.unwrap(value); }

  EventListener get onmouseout() => LevelDom.wrapEventListener(_ptr.onmouseout);

  void set onmouseout(EventListener value) { _ptr.onmouseout = LevelDom.unwrap(value); }

  EventListener get onmouseover() => LevelDom.wrapEventListener(_ptr.onmouseover);

  void set onmouseover(EventListener value) { _ptr.onmouseover = LevelDom.unwrap(value); }

  EventListener get onmouseup() => LevelDom.wrapEventListener(_ptr.onmouseup);

  void set onmouseup(EventListener value) { _ptr.onmouseup = LevelDom.unwrap(value); }

  EventListener get onmousewheel() => LevelDom.wrapEventListener(_ptr.onmousewheel);

  void set onmousewheel(EventListener value) { _ptr.onmousewheel = LevelDom.unwrap(value); }

  EventListener get onoffline() => LevelDom.wrapEventListener(_ptr.onoffline);

  void set onoffline(EventListener value) { _ptr.onoffline = LevelDom.unwrap(value); }

  EventListener get ononline() => LevelDom.wrapEventListener(_ptr.ononline);

  void set ononline(EventListener value) { _ptr.ononline = LevelDom.unwrap(value); }

  EventListener get onpagehide() => LevelDom.wrapEventListener(_ptr.onpagehide);

  void set onpagehide(EventListener value) { _ptr.onpagehide = LevelDom.unwrap(value); }

  EventListener get onpageshow() => LevelDom.wrapEventListener(_ptr.onpageshow);

  void set onpageshow(EventListener value) { _ptr.onpageshow = LevelDom.unwrap(value); }

  EventListener get onpause() => LevelDom.wrapEventListener(_ptr.onpause);

  void set onpause(EventListener value) { _ptr.onpause = LevelDom.unwrap(value); }

  EventListener get onplay() => LevelDom.wrapEventListener(_ptr.onplay);

  void set onplay(EventListener value) { _ptr.onplay = LevelDom.unwrap(value); }

  EventListener get onplaying() => LevelDom.wrapEventListener(_ptr.onplaying);

  void set onplaying(EventListener value) { _ptr.onplaying = LevelDom.unwrap(value); }

  EventListener get onpopstate() => LevelDom.wrapEventListener(_ptr.onpopstate);

  void set onpopstate(EventListener value) { _ptr.onpopstate = LevelDom.unwrap(value); }

  EventListener get onprogress() => LevelDom.wrapEventListener(_ptr.onprogress);

  void set onprogress(EventListener value) { _ptr.onprogress = LevelDom.unwrap(value); }

  EventListener get onratechange() => LevelDom.wrapEventListener(_ptr.onratechange);

  void set onratechange(EventListener value) { _ptr.onratechange = LevelDom.unwrap(value); }

  EventListener get onreset() => LevelDom.wrapEventListener(_ptr.onreset);

  void set onreset(EventListener value) { _ptr.onreset = LevelDom.unwrap(value); }

  EventListener get onresize() => LevelDom.wrapEventListener(_ptr.onresize);

  void set onresize(EventListener value) { _ptr.onresize = LevelDom.unwrap(value); }

  EventListener get onscroll() => LevelDom.wrapEventListener(_ptr.onscroll);

  void set onscroll(EventListener value) { _ptr.onscroll = LevelDom.unwrap(value); }

  EventListener get onsearch() => LevelDom.wrapEventListener(_ptr.onsearch);

  void set onsearch(EventListener value) { _ptr.onsearch = LevelDom.unwrap(value); }

  EventListener get onseeked() => LevelDom.wrapEventListener(_ptr.onseeked);

  void set onseeked(EventListener value) { _ptr.onseeked = LevelDom.unwrap(value); }

  EventListener get onseeking() => LevelDom.wrapEventListener(_ptr.onseeking);

  void set onseeking(EventListener value) { _ptr.onseeking = LevelDom.unwrap(value); }

  EventListener get onselect() => LevelDom.wrapEventListener(_ptr.onselect);

  void set onselect(EventListener value) { _ptr.onselect = LevelDom.unwrap(value); }

  EventListener get onstalled() => LevelDom.wrapEventListener(_ptr.onstalled);

  void set onstalled(EventListener value) { _ptr.onstalled = LevelDom.unwrap(value); }

  EventListener get onstorage() => LevelDom.wrapEventListener(_ptr.onstorage);

  void set onstorage(EventListener value) { _ptr.onstorage = LevelDom.unwrap(value); }

  EventListener get onsubmit() => LevelDom.wrapEventListener(_ptr.onsubmit);

  void set onsubmit(EventListener value) { _ptr.onsubmit = LevelDom.unwrap(value); }

  EventListener get onsuspend() => LevelDom.wrapEventListener(_ptr.onsuspend);

  void set onsuspend(EventListener value) { _ptr.onsuspend = LevelDom.unwrap(value); }

  EventListener get ontimeupdate() => LevelDom.wrapEventListener(_ptr.ontimeupdate);

  void set ontimeupdate(EventListener value) { _ptr.ontimeupdate = LevelDom.unwrap(value); }

  EventListener get ontouchcancel() => LevelDom.wrapEventListener(_ptr.ontouchcancel);

  void set ontouchcancel(EventListener value) { _ptr.ontouchcancel = LevelDom.unwrap(value); }

  EventListener get ontouchend() => LevelDom.wrapEventListener(_ptr.ontouchend);

  void set ontouchend(EventListener value) { _ptr.ontouchend = LevelDom.unwrap(value); }

  EventListener get ontouchmove() => LevelDom.wrapEventListener(_ptr.ontouchmove);

  void set ontouchmove(EventListener value) { _ptr.ontouchmove = LevelDom.unwrap(value); }

  EventListener get ontouchstart() => LevelDom.wrapEventListener(_ptr.ontouchstart);

  void set ontouchstart(EventListener value) { _ptr.ontouchstart = LevelDom.unwrap(value); }

  EventListener get onunload() => LevelDom.wrapEventListener(_ptr.onunload);

  void set onunload(EventListener value) { _ptr.onunload = LevelDom.unwrap(value); }

  EventListener get onvolumechange() => LevelDom.wrapEventListener(_ptr.onvolumechange);

  void set onvolumechange(EventListener value) { _ptr.onvolumechange = LevelDom.unwrap(value); }

  EventListener get onwaiting() => LevelDom.wrapEventListener(_ptr.onwaiting);

  void set onwaiting(EventListener value) { _ptr.onwaiting = LevelDom.unwrap(value); }

  EventListener get onwebkitanimationend() => LevelDom.wrapEventListener(_ptr.onwebkitanimationend);

  void set onwebkitanimationend(EventListener value) { _ptr.onwebkitanimationend = LevelDom.unwrap(value); }

  EventListener get onwebkitanimationiteration() => LevelDom.wrapEventListener(_ptr.onwebkitanimationiteration);

  void set onwebkitanimationiteration(EventListener value) { _ptr.onwebkitanimationiteration = LevelDom.unwrap(value); }

  EventListener get onwebkitanimationstart() => LevelDom.wrapEventListener(_ptr.onwebkitanimationstart);

  void set onwebkitanimationstart(EventListener value) { _ptr.onwebkitanimationstart = LevelDom.unwrap(value); }

  EventListener get onwebkittransitionend() => LevelDom.wrapEventListener(_ptr.onwebkittransitionend);

  void set onwebkittransitionend(EventListener value) { _ptr.onwebkittransitionend = LevelDom.unwrap(value); }

  Window get opener() => LevelDom.wrapWindow(_ptr.opener);

  void set opener(Window value) { _ptr.opener = LevelDom.unwrap(value); }

  int get outerHeight() => _ptr.outerHeight;

  void set outerHeight(int value) { _ptr.outerHeight = value; }

  int get outerWidth() => _ptr.outerWidth;

  void set outerWidth(int value) { _ptr.outerWidth = value; }

  int get pageXOffset() => _ptr.pageXOffset;

  int get pageYOffset() => _ptr.pageYOffset;

  Window get parent() => LevelDom.wrapWindow(_ptr.parent);

  void set parent(Window value) { _ptr.parent = LevelDom.unwrap(value); }

  BarInfo get personalbar() => LevelDom.wrapBarInfo(_ptr.personalbar);

  void set personalbar(BarInfo value) { _ptr.personalbar = LevelDom.unwrap(value); }

  Screen get screen() => LevelDom.wrapScreen(_ptr.screen);

  void set screen(Screen value) { _ptr.screen = LevelDom.unwrap(value); }

  int get screenLeft() => _ptr.screenLeft;

  void set screenLeft(int value) { _ptr.screenLeft = value; }

  int get screenTop() => _ptr.screenTop;

  void set screenTop(int value) { _ptr.screenTop = value; }

  int get screenX() => _ptr.screenX;

  void set screenX(int value) { _ptr.screenX = value; }

  int get screenY() => _ptr.screenY;

  void set screenY(int value) { _ptr.screenY = value; }

  int get scrollX() => _ptr.scrollX;

  void set scrollX(int value) { _ptr.scrollX = value; }

  int get scrollY() => _ptr.scrollY;

  void set scrollY(int value) { _ptr.scrollY = value; }

  BarInfo get scrollbars() => LevelDom.wrapBarInfo(_ptr.scrollbars);

  void set scrollbars(BarInfo value) { _ptr.scrollbars = LevelDom.unwrap(value); }

  Window get self() => LevelDom.wrapWindow(_ptr.self);

  void set self(Window value) { _ptr.self = LevelDom.unwrap(value); }

  Storage get sessionStorage() => LevelDom.wrapStorage(_ptr.sessionStorage);

  String get status() => _ptr.status;

  void set status(String value) { _ptr.status = value; }

  BarInfo get statusbar() => LevelDom.wrapBarInfo(_ptr.statusbar);

  void set statusbar(BarInfo value) { _ptr.statusbar = LevelDom.unwrap(value); }

  StyleMedia get styleMedia() => LevelDom.wrapStyleMedia(_ptr.styleMedia);

  BarInfo get toolbar() => LevelDom.wrapBarInfo(_ptr.toolbar);

  void set toolbar(BarInfo value) { _ptr.toolbar = LevelDom.unwrap(value); }

  Window get top() => LevelDom.wrapWindow(_ptr.top);

  void set top(Window value) { _ptr.top = LevelDom.unwrap(value); }

  NotificationCenter get webkitNotifications() => LevelDom.wrapNotificationCenter(_ptr.webkitNotifications);

  void alert([String message = null]) {
    if (message === null) {
      _ptr.alert();
    } else {
      _ptr.alert(message);
    }
  }

  String atob([String string = null]) {
    if (string === null) {
      return _ptr.atob();
    } else {
      return _ptr.atob(string);
    }
  }

  void blur() {
    _ptr.blur();
  }

  String btoa([String string = null]) {
    if (string === null) {
      return _ptr.btoa();
    } else {
      return _ptr.btoa(string);
    }
  }

  void captureEvents() {
    _ptr.captureEvents();
  }

  void clearInterval([int handle = null]) {
    if (handle === null) {
      _ptr.clearInterval();
    } else {
      _ptr.clearInterval(handle);
    }
  }

  void clearTimeout([int handle = null]) {
    if (handle === null) {
      _ptr.clearTimeout();
    } else {
      _ptr.clearTimeout(handle);
    }
  }

  void close() {
    _ptr.close();
  }

  bool confirm([String message = null]) {
    if (message === null) {
      return _ptr.confirm();
    } else {
      return _ptr.confirm(message);
    }
  }

  FileReader createFileReader() =>
    LevelDom.wrapFileReader(_ptr.createFileReader());

  CSSMatrix createCSSMatrix([String cssValue = null]) {
    if (cssValue === null) {
      return LevelDom.wrapCSSMatrix(_ptr.createWebKitCSSMatrix());
    } else {
      return LevelDom.wrapCSSMatrix(_ptr.createWebKitCSSMatrix(cssValue));
    }
  }

  bool find([String string = null, bool caseSensitive = null, bool backwards = null, bool wrap = null, bool wholeWord = null, bool searchInFrames = null, bool showDialog = null]) {
    if (string === null) {
      if (caseSensitive === null) {
        if (backwards === null) {
          if (wrap === null) {
            if (wholeWord === null) {
              if (searchInFrames === null) {
                if (showDialog === null) {
                  return _ptr.find();
                }
              }
            }
          }
        }
      }
    } else {
      if (caseSensitive === null) {
        if (backwards === null) {
          if (wrap === null) {
            if (wholeWord === null) {
              if (searchInFrames === null) {
                if (showDialog === null) {
                  return _ptr.find(string);
                }
              }
            }
          }
        }
      } else {
        if (backwards === null) {
          if (wrap === null) {
            if (wholeWord === null) {
              if (searchInFrames === null) {
                if (showDialog === null) {
                  return _ptr.find(string, caseSensitive);
                }
              }
            }
          }
        } else {
          if (wrap === null) {
            if (wholeWord === null) {
              if (searchInFrames === null) {
                if (showDialog === null) {
                  return _ptr.find(string, caseSensitive, backwards);
                }
              }
            }
          } else {
            if (wholeWord === null) {
              if (searchInFrames === null) {
                if (showDialog === null) {
                  return _ptr.find(string, caseSensitive, backwards, wrap);
                }
              }
            } else {
              if (searchInFrames === null) {
                if (showDialog === null) {
                  return _ptr.find(string, caseSensitive, backwards, wrap, wholeWord);
                }
              } else {
                if (showDialog === null) {
                  return _ptr.find(string, caseSensitive, backwards, wrap, wholeWord, searchInFrames);
                } else {
                  return _ptr.find(string, caseSensitive, backwards, wrap, wholeWord, searchInFrames, showDialog);
                }
              }
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void focus() {
    _ptr.focus();
  }

  DOMSelection getSelection() =>
    LevelDom.wrapDOMSelection(_ptr.getSelection());

  MediaQueryList matchMedia(String query) {
    return LevelDom.wrapMediaQueryList(_ptr.matchMedia(query));
  }

  void moveBy(num x, num y) {
    _ptr.moveBy(x, y);
  }

  void moveTo(num x, num y) {
    _ptr.moveTo(x, y);
  }

  Window open(String url, String target, [String features = null]) {
    if (features === null) {
      return LevelDom.wrapWindow(_ptr.open(url, target));
    } else {
      return LevelDom.wrapWindow(_ptr.open(url, target, features));
    }
  }

  // TODO(jacobr): cleanup.
  void postMessage(String message, [var messagePort = null, var targetOrigin = null]) {
    if (targetOrigin === null) {
      if (messagePort === null) {
        _ptr.postMessage(message);
        return;
      } else {
        // messagePort is really the targetOrigin string.
        _ptr.postMessage(message, messagePort);
        return;
      }
    } else {
      _ptr.postMessage(message, LevelDom.unwrap(messagePort), targetOrigin);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void print() {
    _ptr.print();
  }

  String prompt([String message = null, String defaultValue = null]) {
    if (message === null) {
      if (defaultValue === null) {
        return _ptr.prompt();
      }
    } else {
      if (defaultValue === null) {
        return _ptr.prompt(message);
      } else {
        return _ptr.prompt(message, defaultValue);
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void releaseEvents() {
    _ptr.releaseEvents();
  }

  void resizeBy(num x, num y) {
    _ptr.resizeBy(x, y);
  }

  void resizeTo(num width, num height) {
    _ptr.resizeTo(width, height);
  }

  void scroll(int x, int y) {
    _ptr.scroll(x, y);
  }

  void scrollBy(int x, int y) {
    _ptr.scrollBy(x, y);
  }

  void scrollTo(int x, int y) {
    _ptr.scrollTo(x, y);
  }

  int setInterval(TimeoutHandler handler, int timeout) =>
    _ptr.setInterval(handler, timeout);

  int setTimeout(TimeoutHandler handler, int timeout) =>
    _ptr.setTimeout(handler, timeout);

  Object showModalDialog(String url, [Object dialogArgs = null, String featureArgs = null]) {
    if (dialogArgs === null) {
      if (featureArgs === null) {
        return _ptr.showModalDialog(url);
      }
    } else {
      if (featureArgs === null) {
        return _ptr.showModalDialog(url, LevelDom.unwrap(dialogArgs));
      } else {
        return _ptr.showModalDialog(url, LevelDom.unwrap(dialogArgs),
                                    featureArgs);
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void stop() {
    _ptr.stop();
  }

  void webkitCancelRequestAnimationFrame(int id) {
    _ptr.webkitCancelRequestAnimationFrame(id);
  }

  Point webkitConvertPointFromNodeToPage([Node node = null, Point p = null]) {
    if (node === null) {
      if (p === null) {
        return LevelDom.wrapPoint(_ptr.webkitConvertPointFromNodeToPage());
      }
    } else {
      if (p === null) {
        return LevelDom.wrapPoint(_ptr.webkitConvertPointFromNodeToPage(LevelDom.unwrap(node)));
      } else {
        return LevelDom.wrapPoint(_ptr.webkitConvertPointFromNodeToPage(LevelDom.unwrap(node), LevelDom.unwrap(p)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  Point webkitConvertPointFromPageToNode([Node node = null, Point p = null]) {
    if (node === null) {
      if (p === null) {
        return LevelDom.wrapPoint(_ptr.webkitConvertPointFromPageToNode());
      }
    } else {
      if (p === null) {
        return LevelDom.wrapPoint(_ptr.webkitConvertPointFromPageToNode(LevelDom.unwrap(node)));
      } else {
        return LevelDom.wrapPoint(_ptr.webkitConvertPointFromPageToNode(LevelDom.unwrap(node), LevelDom.unwrap(p)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback, [Element element = null]) {
    return _ptr.webkitRequestAnimationFrame(callback, LevelDom.unwrap(element));
  }

  void requestLayoutFrame(TimeoutHandler callback) {
    _addMeasurementFrameCallback(callback);
  }

  WindowEvents get on() {
    if (_on === null) {
      _on = new WindowEventsImplementation._wrap(_ptr);
    }
    return _on;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class WorkerEventsImplementation extends AbstractWorkerEventsImplementation
    implements WorkerEvents {
  WorkerEventsImplementation._wrap(_ptr) : super._wrap(_ptr);

  EventListenerList get message() => _get('message');
}

class WorkerWrappingImplementation extends EventTargetWrappingImplementation implements Worker {
  WorkerWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  void postMessage(String message, [MessagePort messagePort = null]) {
    if (messagePort === null) {
      _ptr.postMessage(message);
      return;
    } else {
      _ptr.postMessage(message, LevelDom.unwrap(messagePort));
      return;
    }
  }

  void terminate() {
    _ptr.terminate();
    return;
  }

  WorkerEvents get on() {
    if (_on === null) {
      _on = new WorkerEventsImplementation._wrap(_ptr);
    }
    return _on;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class XMLHttpRequestProgressEventWrappingImplementation extends ProgressEventWrappingImplementation implements XMLHttpRequestProgressEvent {
  XMLHttpRequestProgressEventWrappingImplementation._wrap(ptr) : super._wrap(ptr);

  factory XMLHttpRequestProgressEventWrappingImplementation(String type,
      int loaded, [bool canBubble = true, bool cancelable = true,
      bool lengthComputable = false, int total = 0]) {
    final e = dom.document.createEvent("XMLHttpRequestProgressEvent");
    e.initProgressEvent(type, canBubble, cancelable, lengthComputable, loaded,
        total);
    return LevelDom.wrapProgressEvent(e);
  }

  int get position() => _ptr.position;

  int get totalSize() => _ptr.totalSize;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class XMLHttpRequestUploadEventsImplementation extends EventsImplementation
    implements XMLHttpRequestUploadEvents {
  XMLHttpRequestUploadEventsImplementation._wrap(_ptr) : super._wrap(_ptr);

  EventListenerList get abort() => _get('abort');
  EventListenerList get error() => _get('error');
  EventListenerList get load() => _get('load');
  EventListenerList get loadStart() => _get('loadstart');
  EventListenerList get progress() => _get('progress');
}

class XMLHttpRequestUploadWrappingImplementation extends EventTargetWrappingImplementation implements XMLHttpRequestUpload {
  XMLHttpRequestUploadWrappingImplementation._wrap(ptr) : super._wrap(ptr) {}

  XMLHttpRequestUploadEvents get on() {
    if (_on === null) {
      _on = new XMLHttpRequestUploadEventsImplementation._wrap(_ptr);
    }
    return _on;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class XMLHttpRequestEventsImplementation extends EventsImplementation
    implements XMLHttpRequestEvents {
  XMLHttpRequestEventsImplementation._wrap(_ptr) : super._wrap(_ptr);

  EventListenerList get abort() => _get('abort');
  EventListenerList get error() => _get('error');
  EventListenerList get load() => _get('load');
  EventListenerList get loadStart() => _get('loadstart');
  EventListenerList get progress() => _get('progress');
  EventListenerList get readyStateChange() => _get('readystatechange');
}

class XMLHttpRequestWrappingImplementation extends EventTargetWrappingImplementation implements XMLHttpRequest {
  XMLHttpRequestWrappingImplementation._wrap(
      dom.XMLHttpRequest ptr) : super._wrap(ptr);

  factory XMLHttpRequestWrappingImplementation() {
    return new XMLHttpRequestWrappingImplementation._wrap(
        new dom.XMLHttpRequest());
  }

  factory XMLHttpRequestWrappingImplementation.getTEMPNAME(String url,
      onSuccess(XMLHttpRequest request)) {
    final request = new XMLHttpRequest();
    request.open('GET', url, true);

    // TODO(terry): Validate after client login added if necessary to forward
    //              cookies to server.
    request.withCredentials = true;

    // Status 0 is for local XHR request.
    request.on.readyStateChange.add((e) {
      if (request.readyState == XMLHttpRequest.DONE &&
          (request.status == 200 || request.status == 0)) {
        onSuccess(request);
      }
    });

    request.send();

    return request;
  }

  int get readyState() => _ptr.readyState;

  String get responseText() => _ptr.responseText;

  String get responseType() => _ptr.responseType;

  void set responseType(String value) { _ptr.responseType = value; }

  Document get responseXML() => LevelDom.wrapDocument(_ptr.responseXML);

  int get status() => _ptr.status;

  String get statusText() => _ptr.statusText;

  XMLHttpRequestUpload get upload() => LevelDom.wrapXMLHttpRequestUpload(_ptr.upload);

  bool get withCredentials() => _ptr.withCredentials;

  void set withCredentials(bool value) { _ptr.withCredentials = value; }

  void abort() {
    _ptr.abort();
    return;
  }

  String getAllResponseHeaders() {
    return _ptr.getAllResponseHeaders();
  }

  String getResponseHeader(String header) {
    return _ptr.getResponseHeader(header);
  }

  void open(String method, String url, bool async, [String user = null, String password = null]) {
    if (user === null) {
      if (password === null) {
        _ptr.open(method, url, async);
        return;
      }
    } else {
      if (password === null) {
        _ptr.open(method, url, async, user);
        return;
      } else {
        _ptr.open(method, url, async, user, password);
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void overrideMimeType(String mime) {
    _ptr.overrideMimeType(mime);
  }

  void send([var data = null]) {
    if (data === null) {
      _ptr.send();
      return;
    } else {
      if (data is Document) {
        _ptr.send(LevelDom.unwrapMaybePrimitive(data));
        return;
      } else {
        if (data is String) {
          _ptr.send(LevelDom.unwrapMaybePrimitive(data));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setRequestHeader(String header, String value) {
    _ptr.setRequestHeader(header, value);
  }

  XMLHttpRequestEvents get on() {
    if (_on === null) {
      _on = new XMLHttpRequestEventsImplementation._wrap(_ptr);
    }
    return _on;
  }
}

</script>
<script type="application//inert" id="src_bool_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

interface bool {
}

</script>
<script type="application//inert" id="src_collection_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The [Collection] interface is the public interface of all
 * collections.
 */
interface Collection<E> extends Iterable<E> {
  /**
   * Applies the function [f] to each element of this collection.
   */
  void forEach(void f(E element));

  /**
   * Returns a new collection with the elements of this collection
   * that satisfy the predicate [f].
   *
   * An element satisfies the predicate [f] if [:f(element):]
   * returns true.
   */
  Collection<E> filter(bool f(E element));

  /**
   * Returns true if every elements of this collection satisify the
   * predicate [f]. Returns false otherwise.
   */
  bool every(bool f(E element));

  /**
   * Returns true if one element of this collection satisfies the
   * predicate [f]. Returns false otherwise.
   */
  bool some(bool f(E element));

  /**
   * Returns true if there is no element in this collection.
   */
  bool isEmpty();

  /**
   * Returns the number of elements in this collection.
   */
  int get length();
}

</script>
<script type="application//inert" id="src_comparable_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

interface Comparable {
  int compareTo(Comparable other);
}

</script>
<script type="application//inert" id="src_date_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

/**
 * Date is the public interface to a point in time.
 */
interface Date extends Comparable default DateImplementation {
  // Weekday constants that are returned by [weekday] method:
  static final int MON = 0;
  static final int TUE = 1;
  static final int WED = 2;
  static final int THU = 3;
  static final int FRI = 4;
  static final int SAT = 5;
  static final int SUN = 6;
  static final int DAYS_IN_WEEK = 7;

  // Month constants that are returned by the [month] getter.
  static final int JAN = 1;
  static final int FEB = 2;
  static final int MAR = 3;
  static final int APR = 4;
  static final int MAY = 5;
  static final int JUN = 6;
  static final int JUL = 7;
  static final int AUG = 8;
  static final int SEP = 9;
  static final int OCT = 10;
  static final int NOV = 11;
  static final int DEC = 12;

  /**
   * Constructs a [Date] instance based on the individual parts, in the
   * local time-zone.
   */
  Date(int year,
       int month,
       int day,
       int hours,
       int minutes,
       int seconds,
       int milliseconds);

  /**
   * Constructs a [Date] instance based on the individual parts.
   * [timeZone] may not be [:null:].
   */
  Date.withTimeZone(int year,
                    int month,
                    int day,
                    int hours,
                    int minutes,
                    int seconds,
                    int milliseconds,
                    TimeZone timeZone);

  /**
   * Constructs a new [Date] instance with current date time value.
   * The [timeZone] of this instance is set to the local time-zone.
   */
  Date.now();

  /**
   * Constructs a new [Date] instance based on [formattedString].
   */
  Date.fromString(String formattedString);

  /**
   * Constructs a new [Date] instance with the given time zone. The given
   * [timeZone] must not be [:null:].
   *
   * This constructor is the only one that doesn't need to be computations and
   * which can therefore be [:const:].
   *
   * The constructed [Date] represents 1970-01-01T00:00:00Z + [value]ms in
   * the given [timeZone].
   */
  const Date.fromEpoch(int value, TimeZone timeZone);

  /**
   * Returns a new [Date] in the given [targetTimeZone] time zone. The
   * [value] of the new instance is equal to [:this.value:].
   *
   * This call is equivalent to
   *  [:new Date.fromEpoch(this.value, targetTimeZone):].
   */
  Date changeTimeZone(TimeZone targetTimeZone);

  /**
   * Returns the year.
   */
  int get year();

  /**
   * Returns the month in the year [1..12].
   */
  int get month();

  /**
   * Returns the day in the month [1..31].
   */
  int get day();

  /**
   * Returns the number of hours [0..23].
   */
  int get hours();

  /**
   * Returns the number of minutes [0...59].
   */
  int get minutes();

  /**
   * Returns the number of seconds [0...59].
   */
  int get seconds();

  /**
   * Returns the number of milliseconds [0...999].
   */
  int get milliseconds();

  /**
   * Returns the week day [MON..SUN]
   */
  int get weekday();

  /**
   * Returns milliseconds from 1970-01-01T00:00:00Z (UTC).
   *
   * Note that this value is independent of [timeZone].
   */
  final int value;

  /**
   * Returns the timeZone of this instance.
   */
  final TimeZone timeZone;

  /**
   * Returns true if this [Date] is set to local time.
   */
  bool isLocalTime();

  /**
   * Returns true if this [Date] is set to UTC time.
   * This is equivalent to [:this.timeZone.isUtc():].
   */
  bool isUtc();

  /**
   * Returns a human readable string for this instance.
   * The returned string is constructed for the [timeZone] of this instance.
   */
  String toString();

  /**
   * Returns a new [Date] with the [duration] added to this instance.
   */
  Date add(Duration duration);

  /**
   * Returns a new [Date] with the [duration] subtracted from this instance.
   */
  Date subtract(Duration duration);

  /**
   * Returns a [Duration] with the difference of [:this:] and [other].
   */
  Duration difference(Date other);
}

</script>
<script type="application//inert" id="src_double_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

interface double extends num {
  static final double NAN = 0.0 / 0.0;
  static final double INFINITY = 1.0 / 0.0;
  static final double NEGATIVE_INFINITY = -INFINITY;

  // Specialization of super-interface. Double is contagious. We can therefore
  // specialize more methods than in other num sub-interfaces.
  double remainder(num other);
  double operator +(num other);
  double operator -(num other);
  double operator *(num other);
  double operator %(num other);
  double operator /(num other);
  double operator ~/(num other);
  double operator negate();
  double abs();
  double round();
  double floor();
  double ceil();
  double truncate();
}

</script>
<script type="application//inert" id="src_duration_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

/**
 * A [Duration] represents a time span. A duration can be negative.
 */
interface Duration extends Comparable default DurationImplementation {
  /**
   * The duration is the sum of all individual parts. This means that individual
   * parts don't need to be less than the next-bigger unit. For example [hours]
   * is allowed to have a value greater than 23.
   *
   * All individual parts are allowed to be negative.
   * All arguments are by default 0.
   */
  const Duration([int days, int hours, int minutes, int seconds,
                  int milliseconds]);

 /**
   * Returns this [Duration] in days. Incomplete days are discarded.
   */
  final int inDays;

  /**
   * Returns this [Duration] in hours. Incomplete hours are discarded.
   * The returned value can be greater than 23.
   */
  final int inHours;

  /**
   * Returns this [Duration] in minutes. Incomplete minutes are discarded.
   * The returned value can be greater than 59.
   */
  final int inMinutes;

  /**
   * Returns this [Duration] in seconds. Incomplete seconds are discarded.
   * The returned value can be greater than 59.
   */
  final int inSeconds;

  /**
   * Returns this [Duration] in milliseconds.
   */
  final int inMilliseconds;

  static final int MILLISECONDS_PER_SECOND = 1000;
  static final int SECONDS_PER_MINUTE = 60;
  static final int MINUTES_PER_HOUR = 60;
  static final int HOURS_PER_DAY = 24;

  static final int MILLISECONDS_PER_MINUTE =
      MILLISECONDS_PER_SECOND * SECONDS_PER_MINUTE;
  static final int MILLISECONDS_PER_HOUR =
      MILLISECONDS_PER_MINUTE * MINUTES_PER_HOUR;
  static final int MILLISECONDS_PER_DAY =
      MILLISECONDS_PER_HOUR * HOURS_PER_DAY;

  static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
  static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;

  static final int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;
}

</script>
<script type="application//inert" id="src_exceptions_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Exceptions are thrown either by the VM or from Dart code.

/**
 * Interface implemented by all core library exceptions.
 */
interface Exception default ExceptionImplementation {
  const Exception([var msg]);
}


/**
 * Exception thrown because of an index outside of the valid range.
 */
class IndexOutOfRangeException implements Exception {
  const IndexOutOfRangeException(int this._index);
  String toString() => "IndexOutOfRangeException: $_index";
  final int _index;
}


/**
 * Exception thrown because of attempt to modify an immutable object.
 */
class IllegalAccessException implements Exception {
  const IllegalAccessException();
  String toString() => "Attempt to modify an immutable object";
}


/**
 * Exception thrown because of non-existing receiver's method.
 */
class NoSuchMethodException implements Exception {
  const NoSuchMethodException(Object this._receiver,
                              String this._functionName,
                              List this._arguments);

  String toString() {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < _arguments.length; i++) {
      if (i > 0) {
        sb.add(", ");
      }
      sb.add(_arguments[i]);
    }
    sb.add("]");
    return "NoSuchMethodException - receiver: '$_receiver' " +
           "function name: '$_functionName' arguments: [$sb]";
  }

  final Object _receiver;
  final String _functionName;
  final List _arguments;
}


class ClosureArgumentMismatchException implements Exception {
  const ClosureArgumentMismatchException();
  String toString() => "Closure argument mismatch";
}


class ObjectNotClosureException implements Exception {
  const ObjectNotClosureException();
  String toString() => "Object is not closure";
}


class IllegalArgumentException implements Exception {
  const IllegalArgumentException([args = ""]) : _args = args;
  String toString() => "Illegal argument(s): $_args";
  final String _args;
}


class OutOfMemoryException implements Exception {
  const OutOfMemoryException();
  String toString() => "Out of Memory";
}


class StackOverflowException implements Exception {
  const StackOverflowException();
  String toString() => "Stack Overflow";
}


class BadNumberFormatException implements Exception {
  const BadNumberFormatException(String this._s);
  String toString() => "BadNumberFormatException: '$_s'";
  final String _s;
}


class WrongArgumentCountException implements Exception {
  const WrongArgumentCountException();
  String toString() => "WrongArgumentCountException";
}


class NullPointerException implements Exception {
  const NullPointerException();
  String toString() => "NullPointerException";
}


class NoMoreElementsException implements Exception {
  const NoMoreElementsException();
  String toString() => "NoMoreElementsException";
}


class EmptyQueueException implements Exception {
  const EmptyQueueException();
  String toString() => "EmptyQueueException";
}


class UnsupportedOperationException implements Exception {
  const UnsupportedOperationException(String this._message);
  String toString() => "UnsupportedOperationException: $_message";
  final String _message;
}


class NotImplementedException implements Exception {
  const NotImplementedException();
  String toString() => "NotImplementedException";
}


class IllegalJSRegExpException implements Exception {
  const IllegalJSRegExpException(String this._pattern, String this._errmsg);
  String toString() => "IllegalJSRegExpException: '$_pattern' '$_errmsg'";
  final String _pattern;
  final String _errmsg;
}


class IntegerDivisionByZeroException implements Exception {
  const IntegerDivisionByZeroException();
  String toString() => "IntegerDivisionByZeroException";
}

</script>
<script type="application//inert" id="src_expect_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class Expect {

  /**
   * Checks whether the expected and actual values are equal (using [:==:]).
   */
  static void equals(var expected, var actual, [String reason = null]) {
    if (expected == actual) return;
    String msg = _getMessage(reason);
    _fail("Expect.equals(expected: <$expected>, actual: <$actual>$msg) fails.");
  }

  /**
   * Checks whether the actual value is a bool and its value is true.
   */
  static void isTrue(var actual, [String reason = null]) {
    if (actual === true) return;
    String msg = _getMessage(reason);
    _fail("Expect.isTrue($actual$msg) fails.");
  }

  /**
   * Checks whether the actual value is a bool and its value is false.
   */
  static void isFalse(var actual, [String reason = null]) {
    if (actual === false) return;
    String msg = _getMessage(reason);
    _fail("Expect.isFalse($actual$msg) fails.");
  }

  /**
   * Checks whether [actual] is null.
   */
  static void isNull(actual, [String reason = null]) {
    if (null === actual) return;
    String msg = _getMessage(reason);
    _fail("Expect.isNull(actual: <$actual>$msg) fails.");
  }

  /**
   * Checks whether [actual] is not null.
   */
  static void isNotNull(actual, [String reason = null]) {
    if (null !== actual) return;
    String msg = _getMessage(reason);
    _fail("Expect.isNotNull(actual: <$actual>$msg) fails.");
  }

  /**
   * Checks whether the expected and actual values are identical
   * (using [:===:]).
   */
  static void identical(var expected, var actual, [String reason = null]) {
    if (expected === actual) return;
    String msg = _getMessage(reason);
    _fail("Expect.identical(expected: <$expected>, actual: <$actual>$msg) " +
          "fails.");
  }

  // Unconditional failure.
  static void fail(String msg) {
    _fail("Expect.fail('$msg')");
  }

  /**
   * Failure if the difference between expected and actual is greater than the
   * given tolerance. If no tolerance is given, tolerance is assumed to be the
   * value 4 significant digits smaller than the value given for expected.
   */
  static void approxEquals(num expected,
                           num actual,
                           [num tolerance = null,
                            String reason = null]) {
    if (tolerance === null) {
      tolerance = (expected / Math.pow(10.0, 4.0)).abs();
    }
    // Note: use !( <= ) rather than > so we fail on NaNs
    if ((expected - actual).abs() <= tolerance) return;

    String msg = _getMessage(reason);
    _fail('Expect.approxEquals(expected:<$expected>, actual:<$actual>, ' +
          'tolerance:<$tolerance>$msg) fails');
  }

  static void notEquals(unexpected, actual, [String reason = null]) {
    if (unexpected != actual) return;
    String msg = _getMessage(reason);
    _fail("Expect.notEquals(unexpected: <$unexpected>, actual:<$actual>$msg) " +
          "fails.");
  }

  /**
   * Checks that all elements in [expected] and [actual] are equal [:==:].
   * This is different than the typical check for identity equality [:===:]
   * used by the standard list implementation.  It should also produce nicer
   * error messages than just calling [:Expect.equals(expected, actual):].
   */
  static void listEquals(List expected, List actual, [String reason = null]) {
    String msg = _getMessage(reason);
    int n = Math.min(expected.length, actual.length);
    for (int i = 0; i < n; i++) {
      if (expected[i] != actual[i]) {
        _fail('Expect.listEquals(at index $i, ' +
              'expected: <${expected[i]}>, actual: <${actual[i]}>$msg) fails');
      }
    }
    // We check on length at the end in order to provide better error
    // messages when an unexpected item is inserted in a list.
    if (expected.length != actual.length) {
      _fail('Expect.listEquals(list length, ' +
        'expected: <${expected.length}>, actual: <${actual.length}>$msg) ' +
        'fails');
    }
  }


  /**
   * Specialized equality test for strings. When the strings don't match,
   * this method shows where the mismatch starts and ends.
   */
  static void stringEquals(String expected,
                           String actual,
                           [String reason = null]) {
    String msg = _getMessage(reason);
    String defaultMessage =
        'Expect.stringEquals(expected: <$expected>", <$actual>$msg) fails';

    if (expected == actual) return;
    if ((expected === null) || (actual === null)) {
      _fail('$defaultMessage');
    }
    // scan from the left until we find a mismatch
    int left = 0;
    int eLen = expected.length;
    int aLen = actual.length;
    while (true) {
      if (left == eLen) {
        assert (left < aLen);
        String snippet = actual.substring(left, aLen);
        _fail('$defaultMessage\nDiff:\n...[  ]\n...[ $snippet ]');
        return;
      }
      if (left == aLen) {
        assert (left < eLen);
        String snippet = expected.substring(left, eLen);
        _fail('$defaultMessage\nDiff:\n...[  ]\n...[ $snippet ]');
        return;
      }
      if (expected[left] != actual[left]) {
        break;
      }
      left++;
    }

    // scan from the right until we find a mismatch
    int right = 0;
    while (true) {
      if (right == eLen) {
        assert (right < aLen);
        String snippet = actual.substring(0, aLen - right);
        _fail('$defaultMessage\nDiff:\n[  ]...\n[ $snippet ]...');
        return;
      }
      if (right == aLen) {
        assert (right < eLen);
        String snippet = expected.substring(0, eLen - right);
        _fail('$defaultMessage\nDiff:\n[  ]...\n[ $snippet ]...');
        return;
      }
      if (expected[eLen - right - 1] != actual[aLen - right - 1]) {
        break;
      }
      right++;
    }
    String eSnippet = expected.substring(left, eLen - right);
    String aSnippet = actual.substring(left, aLen - right);
    String diff = '\nDiff:\n...[ $eSnippet} ]...\n...[ $aSnippet ]...';
    _fail('$defaultMessage$diff');
  }

  /**
   * Checks that every element of [expected] is also in [actual], and that
   * every element of [actual] is also in [expected].
   */
  static void setEquals(Iterable expected,
                        Iterable actual,
                        [String reason = null]) {
    final missingSet = new Set.from(expected);
    missingSet.removeAll(actual);
    final extraSet = new Set.from(actual);
    extraSet.removeAll(expected);

    if (extraSet.isEmpty() && missingSet.isEmpty()) return;
    String msg = _getMessage(reason);

    StringBuffer sb = new StringBuffer("Expect.setEquals($msg) fails");
    // Report any missing items.
    if (!missingSet.isEmpty()) {
      sb.add('\nExpected collection does not contain: ');
    }

    for (final val in missingSet) {
      sb.add('$val ');
    }

    // Report any extra items.
    if (!extraSet.isEmpty()) {
      sb.add('\nExpected collection should not contain: ');
    }

    for (final val in extraSet) {
      sb.add('$val ');
    }
    _fail(sb.toString());
  }

  /**
   * Calls the function [f] and verifies that it throws an exception.
   * The optional [check] function can provide additional validation
   * that the correct exception is being thrown.  For example, to check
   * the type of the exception you could write this:
   *
   * [:
   *   Expect.throws(myThrowingFunction,
   *                 (e) { return e is MyException})
   * :]
   */
  static void throws(void f(),
                     [_CheckExceptionFn check = null,
                      String reason = null]) {
    try {
      f();
    } catch (var e) {
      if (check !== null) {
        Expect.isTrue(check(e));
      }
      return;
    }
    String msg = _getMessage(reason);
    _fail('Expect.throws($msg) fails');
  }

  static String _getMessage(String reason)
      => (reason === null) ? "" : ", '$reason'";

  static void _fail(String message) {
    throw new ExpectException(message);
  }
}

typedef bool _CheckExceptionFn(exception);

class ExpectException implements Exception {
  ExpectException(this.message);
  String toString() => message;
  String message;
}

</script>
<script type="application//inert" id="src_function_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

interface Function {
}

</script>
<script type="application//inert" id="src_future_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.


/**
 * A Future is used to obtain a value sometime in the
 * future.
 *
 * Receivers of a Future obtain the value by passing
 * a callback to the 'then' method of Future.
 *
 * For example:
 *
 *   Future<int> future = getFutureFromSomewhere();
 *   future.then((value) {
 *     print("I received the number " + value);
 *   });
 *
 */
interface Future<T> default FutureImpl<T> {

  /**
   * The value this future provided.  (If called when hasValue
   * is false, then throws an exception.)
   */
  T get value();

  /**
   * Exception that occurred (null if no exception occured).  (If called
   * before [isComplete] is true, then this exception property itself
   * throws a FutureNotCompleteException.)
   */
  Object get exception();

  /**
   * Whether the future is complete (either the value is available or there
   * was an exception).
   */
  bool get isComplete();

  /**
   * Whether the value is available (meaning isComplete is true, and there
   * was no exception).
   */
  bool get hasValue();

  /**
   * When this future is complete and has a value, then call
   * the onComplete callback function with the value.
   */
  void then(void onComplete(T value));

  /**
   * If this future gets an exception, then call onException.
   *
   * If onException returns true, then the exception is considered
   * handled.
   *
   * If onException does not return true (or handleException was never called),
   * then the exception is not considered handled.  In that case, if there were
   * any calls to [then] (meaning that there are onComplete callbacks waiting
   * for the value), then the exception will be thrown when it is set.
   *
   * (In most cases it should not be necessary to call handleException,
   * because the exception associated with this Future will propagate naturally
   * if the future's value is being consumed.  Only call handleException if you
   * need to do some special local exception handling related to this
   * particular Future's value.)
   */
  void handleException(bool onException(Object exception));
}


/**
 * A Completer is used to produce Future objects, and supply
 * a value to the Future object when the value becomes available.
 *
 * A service that provides values to callers, and wants to return Future objects
 * rather than returning the values immediately, can use a Completer as follows:
 *
 *   Completer completer = new Completer();
 *   Future future = completer.future;
 *
 *   // send [future] object back to client...
 *
 *   // later when value is available, call:
 *   completer.complete(value);
 *
 *   // alternatively, if the service cannot produce the value, it
 *   // can provide an exception:
 *   completer.completeException(exception);
 *
 */
interface Completer<T> default CompleterImpl<T> {

  /** Create a completer */
  Completer();

  Future get future();

  /**
   * Called when value is available.
   */
  void complete(T value);

  /**
   * Called if an exception occured while trying to produce value.
   */
  void completeException(Object exception);
}


/**
 * This class is for utility functions that operate on Futures (for
 * example, waiting for a collectin of Futures to complete).
 */
class Futures {

  /**
   * Returns a future which will complete once all the futures in a
   * list are complete.  (The value of the returned future will
   * be a list of all the values that were produced.)
   */
  static Future<List> wait(List<Future> futures) {
    Completer completer = new Completer<List>();
    int remaining = futures.length;
    List<Object> values = new List(futures.length);

    // As each future completes, put its value into the corresponding
    // position in the list of values.
    for (int i = 0; i < futures.length; i++) {
      // TODO(mattsh) - remove this after bug
      // http://code.google.com/p/dart/issues/detail?id=333 is fixed.
      int pos = i;
      futures[pos].then((Object value) {
        values[pos] = value;
        if (--remaining == 0) {
          completer.complete(values);
        }
      });
    }
    return completer.future;
  }
}


</script>
<script type="application//inert" id="src_hashable_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

interface Hashable {
  int hashCode();
}

</script>
<script type="application//inert" id="src_int_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

interface int extends num {
  // Bit-operations.
  int operator &(int other);
  int operator |(int other);
  int operator ^(int other);
  int operator ~();
  int operator <<(int shiftAmount);
  int operator >>(int shiftAmount);

  // Specializations of super-interface.
  int operator negate();
  int abs();
  int round();
  int floor();
  int ceil();
  int truncate();
}

</script>
<script type="application//inert" id="src_isolate_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

/**
 * [SendPort]s are created from [ReceivePort]s. Any message sent through
 * a [SendPort] is delivered to its respective [ReceivePort]. There might be
 * many [SendPort]s for the same [ReceivePort].
 *
 * [SendPort]s can be transmitted to other isolates.
 */
interface SendPort extends Hashable {

  /**
   * Sends an asynchronous [message] to this send port. The message is
   * copied to the receiving isolate. If the message contains any
   * receive ports, they are translated to the corresponding send port
   * before being transmitted. If specified, the [replyTo] port will be
   * provided to the receiver to facilitate exchanging sequences of
   * messages.
   */
  void send(var message, [SendPort replyTo]);

  /**
   * Creates a new single-shot receive port, sends a message to this
   * send port with replyTo set to the opened port, and returns the
   * receive port.
   */
  ReceivePort call(var message);

  /**
   * Tests whether [other] is a [SendPort] pointing to the same
   * [ReceivePort] as this one.
   */
   bool operator==(var other);

  /**
   * Returns an immutable hash code for this send port that is
   * consistent with the == operator.
   */
  int hashCode();

}


/**
 * [ReceivePort]s, together with [SendPort]s, are the only means of
 * communication between isolates. [ReceivePort]s have a [:toSendPort:] method
 * which returns a [SendPort]. Any message that is sent through this [SendPort]
 * is delivered to the [ReceivePort] it has been created from. There, they are
 * dispatched to the callback that has been registered on the receive port.
 *
 * A [ReceivePort] may have many [SendPort]s.
 */
interface ReceivePort default ReceivePortFactory {

  /**
   * Opens a long-lived port for receiving messages. The returned port
   * must be explicitly closed through [ReceivePort.close].
   */
  ReceivePort();

  /**
   * Opens a single-shot reply port. Once a message has been received
   * on this port, it is automatically closed -- obviously without
   * throwing the message away before it can be processed. This
   * constructor is used indirectly through [SendPort.call].
   */
  ReceivePort.singleShot();

  /**
   * Sets up a callback function for receiving pending or future
   * messages on this receive port.
   */
  void receive(void callback(var message, SendPort replyTo));

  /**
   * Closes this receive port immediately. Pending messages will not
   * be processed and it is impossible to re-open the port. Single-shot
   * reply ports, such as those created through [SendPort.call], are
   * automatically closed when the reply has been received. Multiple
   * invocations of [close] are allowed but ignored.
   */
  void close();

  /**
   * Creates a new send port that sends to this receive port. It is legal to
   * create several [SendPort]s from the same [ReceivePort].
   */
  SendPort toSendPort();

}

/**
 * The [Isolate] class serves two purposes: (1) as template for spawning a new
 * isolate, and (2) as entry-point for the newly spawned isolate.
 *
 * New isolates are spawned by sub-classing [Isolate] and then invoking
 * [:spawn:] on the instance. This will spawn a new isolate, which creates a
 * new instance of the class, initializes the instance's [port] field
 * and invokes the instance method [main].
 *
 * The new instance is created by invoking the default constructor of the
 * class that served as template for spawning the new isolate. This means, that
 * sub-classes must have a default constructor (i.e. no-argument constructor).
 *
 * Isolates may be "heavy" or "light". Heavy isolates live in their own thread,
 * whereas "light" isolates live in the same thread as the isolate which spawned
 * them.
 */
class Isolate {

  /**
   * Redirects to [Isolate.light].
   */
  Isolate() : this.light();

  /**
   * Creates a new isolate-template for a light isolate.
   */
  Isolate.light() : _isLight = true;

  /**
   * Creates a new isolate-template for a heavy isolate.
   */
  Isolate.heavy() : _isLight = false;

  /**
   * Spawns a new isolate, using this instance as template.
   *
   * The new isolate lives in a new thread (for heavy templates)
   * or in the same thread as the current isolate (for light templates), if
   * possible.
   *
   * During the initialization of the new isolate a [ReceivePort] is created
   * inside the new isolate and stored in the read-only field [port].
   *  A corresponding [SendPort] is sent to the isolate that invoked [spawn].
   * Since spawning an isolate is an asynchronous operation this method returns
   * a [Future] of this [SendPort].
   *
   * A common pattern to instantiate new isolates is to enqueue the instructions
   * using [Future.then].
   * [:myIsolate.spawn().then((SendPort port) { port.send('hi there'); });:]
   */
  Future<SendPort> spawn() {
    return IsolateNatives.spawn(this, _isLight);
  }

  // The private run method is invoked with the receive port. Before
  // main is invoked we store the port in a field so it can be
  // accessed from subclasses of Isolate.
  void _run(ReceivePort port) {
    _port = port;
    main();
  }

  /**
   * When [Isolate]s are used as entry-points, the [port] field contains a
   * [ReceivePort]. The isolate that initiated the spawn holds a corresponding
   * [SendPort].
   *
   * Note that isolates should generally close their [ReceivePort]s when they
   * are done, including this port.
   */
  ReceivePort get port() {
    return _port;
  }

  /**
   * When isolates are created, an instance of the template's class is
   * instantiated in the new isolate. After the [port] has been set up, this
   * [main] method is invoked on the instance.
   */
  abstract void main();

  final bool _isLight;
  ReceivePort _port;
}

</script>
<script type="application//inert" id="src_iterable_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The [Iterable] interface allows to get an [Iterator] out of an
 * [Iterable] object.
 *
 * This interface is used by the for-in construct to iterate over an
 * [Iterable] object.
 * The for-in construct takes an [Iterable] object at the right-hand
 * side, and calls its [iterator] method to get an [Iterator] on it.
 *
 * A user-defined class that implements the [Iterable] interface can
 * be used as the right-hand side of a for-in construct.
 */
interface Iterable<E> {
  /**
   * Returns an [Iterator] that iterates over this [Iterable] object.
   */
  Iterator<E> iterator();
}

</script>
<script type="application//inert" id="src_iterator_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The [Iterator] class provides methods to iterate over an object. It
 * is transparently used by the for-in construct to test for the end
 * of the iteration, and to get the elements.
 */
interface Iterator<E> {
  /**
   * Gets the next element in the iteration. Throws a
   * [NoMoreElementsException] if no element is left.
   */
  E next();

  /**
   * Returns whether the [Iterator] has elements left.
   */
  bool hasNext();
}

</script>
<script type="application//inert" id="src_list_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * A [List] is an indexable collection with a length. It can be of
 * fixed size or extendable.
 */
interface List<E> extends Collection<E> default ListFactory<E> {

  /**
   * Creates a list of the given [length].
   */
  List([int length]);

  /**
   * Creates a list with the elements of [other]. The order in
   * the list will be the order provided by the iterator of [other].
   */
  List.from(Iterable<E> other);

  /**
   * Returns the element at the given [index] in the list or throws
   * an [IndexOutOfRangeException] if [index] is out of bounds.
   */
  E operator [](int index);

  /**
   * Sets the entry at the given [index] in the list to [value].
   * Throws an [IndexOutOfRangeException] if [index] is out of bounds.
   */
  void operator []=(int index, E value);

  /**
   * Changes the length of the list. If [newLength] is greater than
   * the current [length], entries are initialized to [:null:]. Throws
   * an [UnsupportedOperationException] if the list is not extendable.
   */
  void set length(int newLength);

  /**
   * Adds [value] at the end of the list, extending the length by
   * one. Throws an [UnsupportedOperationException] if the list is not
   * extendable.
   */
  void add(E value);

  /**
   * Adds [value] at the end of the list, extending the length by
   * one. Throws an [UnsupportedOperationException] if the list is not
   * extendable.
   */
  void addLast(E value);

  /**
   * Appends all elements of the [collection] to the end of list.
   * Extends the length of the list by the length of [collection].
   * Throws an [UnsupportedOperationException] if the list is not
   * extendable.
   */
  void addAll(Collection<E> collection);

  /**
   * Sorts the list according to the order specified by the comparator.
   * The order specified by the comparator must be reflexive,
   * anti-symmetric, and transitive.
   *
   * The comparator function [compare] must take two arguments [a] and [b]
   * and return
   *
   *   an integer strictly less than 0 if a < b,
   *   0 if a = b, and
   *   an integer strictly greater than 0 if a > b.
   */
  void sort(int compare(E a, E b));

  /**
   * Returns the first index of [element] in this list. Searches this
   * list from index [start] to the length of the list. Returns
   * -1 if [element] is not found.
   */
  int indexOf(E element, [int start]);

  /**
   * Returns the last index of [element] in this list. Searches this
   * list from index [start] (inclusive) to 0. Returns -1 if
   * [element] is not found.
   */
  int lastIndexOf(E element, [int start]);

  /**
   * Removes all elements in the list. The length of the list
   * becomes zero. Throws an [UnsupportedOperationException] if
   * the list is not extendable.
   */
  void clear();

  /**
   * Pops and returns the last element of the list.
   * Throws a [UnsupportedOperationException] if the length of the
   * list cannot be changed.
   */
  E removeLast();

  /**
   * Returns the last element of the list, or throws an out of bounds
   * exception if the list is empty.
   */
  E last();

  /**
   * Returns a sub list copy of this list, from [start] to
   * [:start + length:].
   * Returns an empty list if [length] is 0.
   * Throws an [IllegalArgumentException] if [length] is negative.
   * Throws an [IndexOutOfRangeException] if [start] or
   * [:start + length:] are out of range.
   */
  List<E> getRange(int start, int length);

  /**
   * Copies [length] elements of the [from] array, starting
   * from [startFrom], into [:this:], starting at [start].
   * Throws an [UnsupportedOperationException] if the list is
   * not extendable.
   * If [length] is 0, this method does not do anything.
   * Throws an [IllegalArgumentException] if [length] is negative.
   * Throws an [IndexOutOfRangeException] if [start] or
   * [:start + length:] are out of range for [:this:], or if
   * [startFrom] is out of range for [from].
   */
  void setRange(int start, int length, List<E> from, [int startFrom]);

  /**
   * Removes the range in the list starting from [start] to
   * [:start + length:].
   * Throws an [UnsupportedOperationException] if the list is
   * not extendable.
   * If [length] is 0, this method does not do anything.
   * Throws an [IllegalArgumentException] if [length] is negative.
   * Throws an [IndexOutOfRangeException] if [start] or
   * [:start + length:] are out of range.
   */
  void removeRange(int start, int length);

  /**
   * Inserts a new range in the list, starting from [start] to
   * [:start + length:]. The entries are filled with [initialValue].
   * Throws an [UnsupportedOperationException] if the list is
   * not extendable.
   * If [length] is 0, this method does not do anything.
   * If [start] is the length of the array, this method inserts the
   * range at the end of the array.
   * Throws an [IllegalArgumentException] if [length] is negative.
   * Throws an [IndexOutOfRangeException] if [start] or
   * [:start + length:] are out of range.
   */
  void insertRange(int start, int length, [E initialValue]);
}

</script>
<script type="application//inert" id="src_map_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * A [Map] is an associative container, mapping a key to a value.
 * Null values are supported.
 */
interface Map<K, V> default HashMapImplementation<K extends Hashable, V> {
  /**
   * Creates a map with the default implementation.
   */
  Map();

  /**
   * Creates a [Map] that contains all key value pairs of [other].
   */
  Map.from(Map<K, V> other);


  /**
   * Returns whether this map contains the given [value].
   */
  bool containsValue(V value);

  /**
   * Returns whether this map contains the given [key].
   */
  bool containsKey(K key);

  /**
   * Returns the value for the given [key] or null if [key] is not
   * in the map. Because null values are supported, one should either
   * use containsKey to distinguish between an absent key and a null
   * value, or use the [putIfAbsent] method.
   */
  V operator [](K key);

  /**
   * Associates the [key] with the given [value].
   */
  void operator []=(K key, V value);

  /**
   * If [key] is not associated to a value, calls [ifAbsent] and
   * updates the map by mapping [key] to the value returned by
   * [ifAbsent]. Returns the value in the map.
   */
  V putIfAbsent(K key, V ifAbsent());

  /**
   * Removes the association for the given [key]. Returns the value for
   * [key] in the map or null if [key] is not in the map. Note that values
   * can be null and a returned null value does not always imply that the
   * key is absent.
   */
  V remove(K key);

  /**
   * Removes all pairs from the map.
   */
  void clear();

  /**
   * Applies [f] to each {key, value} pair of the map.
   */
  void forEach(void f(K key, V value));

  /**
   * Returns a collection containing all the keys in the map.
   */
  Collection<K> getKeys();

  /**
   * Returns a collection containing all the values in the map.
   */
  Collection<V> getValues();

  /**
   * The number of {key, value} pairs in the map.
   */
  int get length();

  /**
   * Returns true if there is no {key, value} pair in the map.
   */
  bool isEmpty();
}

/**
 * Hash map version of the [Map] interface. A [HashMap] does not
 * provide any guarantees on the order of keys and values in [getKeys]
 * and [getValues].
 */
interface HashMap<K extends Hashable, V> extends Map<K, V>
    default HashMapImplementation<K extends Hashable, V> {
  /**
   * Creates a map with the default implementation.
   */
  HashMap();

  /**
   * Creates a [HashMap] that contains all key value pairs of [other].
   */
  HashMap.from(Map<K, V> other);
}

/**
 * Hash map version of the [Map] interface that preserves insertion
 * order.
 */
interface LinkedHashMap<K extends Hashable, V> extends HashMap<K, V>
    default LinkedHashMapImplementation<K extends Hashable, V> {
  /**
   * Creates a map with the default implementation.
   */
  LinkedHashMap();

  /**
   * Creates a [LinkedHashMap] that contains all key value pairs of [other].
   */
  LinkedHashMap.from(Map<K, V> other);
}

</script>
<script type="application//inert" id="src_pattern_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

interface Pattern {
  Iterable<Match> allMatches(String str);
}

</script>
<script type="application//inert" id="src_queue_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * A [Queue] is a collection that can be manipulated at both ends. One
 * can iterate over the elements of a queue through [forEach] or with
 * an [Iterator].
 */
interface Queue<E> extends Collection<E> default DoubleLinkedQueue<E> {

  /**
   * Creates a queue.
   */
  Queue();

  /**
   * Creates a queue with the elements of [other]. The order in
   * the queue will be the order provided by the iterator of [other].
   */
  Queue.from(Iterable<E> other);

  /**
   * Removes and returns the first element of this queue. Throws an
   * [EmptyQueueException] exception if this queue is empty.
   */
  E removeFirst();

  /**
   * Removes and returns the last element of the queue. Throws an
   * [EmptyQueueException] exception if this queue is empty.
   */
  E removeLast();

  /**
   * Adds [value] at the beginning of the queue.
   */
  void addFirst(E value);

  /**
   * Adds [value] at the end of the queue.
   */
  void addLast(E value);

  /**
   * Adds [value] at the end of the queue.
   */
  void add(E value);

  /**
   * Adds all elements of [collection] at the end of the queue. The
   * length of the queue is extended by the length of [collection].
   */
  void addAll(Collection<E> collection);

  /**
   * Returns the first element of the queue. Throws an
   * [EmptyQueueException] exception if this queue is empty.
   */
  E first();

  /**
   * Returns the last element of the queue. Throws an
   * [EmptyQueueException] exception if this queue is empty.
   */
  E last();

  /**
   * Removes all elements in the queue. The size of the queue becomes zero.
   */
  void clear();
}

</script>
<script type="application//inert" id="src_regexp_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * [Match] contains methods to manipulate a regular expression match.
 *
 * Iterables of [Match] objects are returned from [RegExp] matching methods.
 *
 * The following example finds all matches of a [RegExp] in a [String]
 * and iterates through the returned iterable of [Match] objects.
 *
 * [:
 *    RegExp exp = const RegExp(@"(\w+)");
 *    String str = "Parse my string";
 *    Iterable<Match> matches = exp.allMatches(str);
 *    for (Match m in matches) {
 *      String match = m.group(0);
 *      print(match);
 *    };
 * :]
 *
 * The output of the example is:
 *
 * [:
 *    Parse
 *    my
 *    string
 * :]
 */
interface Match {
  /**
   * Returns the index in the string where the match starts.
   */
  int start();

  /**
   * Returns the index in the string after the last character of the
   * match.
   */
  int end();

  /**
   * Returns the string matched by the given [group]. If [group] is 0,
   * returns the match of the regular expression.
   */
  String group(int group);
  String operator [](int group);

  /**
   * Returns the strings matched by [groups]. The order in the
   * returned string follows the order in [groups].
   */
  List<String> groups(List<int> groups);

  /**
   * Returns the number of groups in the regular expression.
   */
  int groupCount();

  /**
   * The string on which this matcher was computed.
   */
  final String str;

  /**
   * The pattern to search for in [str].
   */
  final Pattern pattern;
}


/**
 * [RegExp] represents regular expressions.
 *
 * [firstMatch] is the main implementation method that applies a regular
 * expression to a string and returns the first [Match]. All
 * other methods in [RegExp] can build on it.
 *
 * Use [allMatches] to look for all matches of a regular expression in
 * a string.
 *
 * The following example finds all matches of a regular expression in
 * a string.
 *
 * [:
 *    RegExp exp = const RegExp(@"(\w+)");
 *    String str = "Parse my string";
 *    Iterable<Match> matches = exp.allMatches(str);
 * :]
 */
interface RegExp extends Pattern default JSSyntaxRegExp {

  /**
   * Constructs a regular expression. The default implementation of a
   * [RegExp] sets [multiLine] and [ignoreCase] to false.
   */
  const RegExp(String pattern, [bool multiLine, bool ignoreCase]);

  /**
   * Searches for the first match of the regular expression
   * in the string [str]. Returns [:null:] if there is no match.
   */
  Match firstMatch(String str);

  /**
   * Returns an iterable on the  matches of the regular
   * expression in [str].
   */
  Iterable<Match> allMatches(String str);

  /**
   * Returns whether the regular expression has a match in the string [str].
   */
  bool hasMatch(String str);

  /**
   * Searches for the first match of the regular expression
   * in the string [str] and returns the matched string.
   */
  String stringMatch(String str);

  /**
   * The pattern of this regular expression.
   */
  final String pattern;

  /**
   * Whether this regular expression matches multiple lines.
   */
  final bool multiLine;

  /**
   * Whether this regular expression is case insensitive.
   */
  final bool ignoreCase;
}

</script>
<script type="application//inert" id="src_set_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * This class is the public interface of a set. A set is a collection
 * without duplicates.
 */
interface Set<E> extends Collection<E>
    default HashSetImplementation<E extends Hashable> {
  Set();

  /**
   * Creates a [Set] that contains all elements of [other].
   */
  Set.from(Iterable<E> other);

  /**
   * Returns true if [value] is in the set.
   */
  bool contains(E value);

  /**
   * Adds [value] into the set. The method has no effect if
   * [value] was already in the set.
   */
  void add(E value);

  /**
   * Removes [value] from the set. Returns true if [value] was
   * in the set. Returns false otherwise. The method has no effect
   * if [value] value was not in the set.
   */
  bool remove(E value);

  /**
   * Adds all the elements of the given collection to the set.
   */
  void addAll(Collection<E> collection);

  /**
   * Removes all the elements of the given collection from the set.
   */
  void removeAll(Collection<E> collection);

  /**
   * Returns true if [collection] contains all the elements of this
   * collection.
   */
  bool isSubsetOf(Collection<E> collection);

  /**
   * Returns true if this collection contains all the elements of
   * [collection].
   */
  bool containsAll(Collection<E> collection);

  /**
   * Returns a new set which is the intersection between this set and
   * the given collection.
   */
  Set<E> intersection(Collection<E> other);

  /**
   * Removes all elements in the set.
   */
  void clear();

}

interface HashSet<E extends Hashable> extends Set<E>
    default HashSetImplementation<E extends Hashable> {
  HashSet();

  /**
   * Creates a [Set] that contains all elements of [other].
   */
  HashSet.from(Iterable<E> other);
}

</script>
<script type="application//inert" id="src_stopwatch_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * A simple [Stopwatch] interface to measure elapsed time.
 */
interface Stopwatch default StopwatchImplementation {

  /**
   * Creates a [Stopwatch] in stopped state with a zero elapsed count.
   */
  Stopwatch();

  /**
   * Creates a [Stopwatch] in started state with a zero elapsed count.
   */
  Stopwatch.start();

  /**
   * Starts the [Stopwatch]. The [elapsed] count is increasing monotonically.
   * If the [Stopwatch] has been stopped, then calling start again restarts it
   * without resetting the [elapsed] count.
   * If the [Stopwatch] is currently running, then calling start does nothing.
   */
  void start();

  /**
   * Stops the [Stopwatch]. The [elapsed] count stops increasing.
   * If the [Stopwatch] is currently not running, then calling stop does
   * nothing.
   */
  void stop();

  /**
   * Resets the [elapsed] count to zero. This method does not stop or start
   * the [Stopwatch].
   */
  void reset();

  /**
   * Returns the elapsed number of clock ticks since calling [start] while the
   * [Stopwatch] is running.
   * Returns the elapsed number of clock ticks between calling [start] and
   * calling [stop].
   * Returns 0 if the [Stopwatch] has never been started.
   * The elapsed number of clock ticks increases by [frequency] every second.
   */
  int elapsed();

  /**
   * Returns the [elapsed] counter converted to microseconds.
   */
  int elapsedInUs();

  /**
   * Returns the [elapsed] counter converted to milliseconds.
   */
  int elapsedInMs();

  /**
   * Returns the frequency of the elapsed counter in Hz.
   */
  int frequency();

}

</script>
<script type="application//inert" id="src_string_buffer_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The StringBuffer class is useful for concatenating strings
 * efficiently. Only on a call to [toString] are the strings
 * concatenated to a single String.
 */
interface StringBuffer default StringBufferImpl {
  /**
   * Creates the string buffer with an initial content.
   */
  StringBuffer([Object content]);

  /**
   * Returns the length of the buffer.
   */
  int get length();

  /**
   * Returns whether the buffer is empty.
   */
  bool isEmpty();

  /**
   * Adds [obj] to the buffer. Returns [:this:].
   */
  StringBuffer add(Object obj);

  /**
   * Adds all items in [objects] to the buffer. Returns [:this:].
   */
  StringBuffer addAll(Collection<Object> objects);

  /**
   * Clears the string buffer. Returns [:this:].
   */
  StringBuffer clear();

  /**
   * Returns the contents of buffer as a concatenated string.
   */
  String toString();
}

</script>
<script type="application//inert" id="src_string_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The String class represents character strings. Strings are
 * immutable. A string is represented by a list of 32-bit Unicode
 * scalar character codes accessible through the [charCodeAt] or the
 * [charCodes] method.
 */
interface String extends Comparable, Hashable, Pattern default Strings {
  /**
   * Allocates a new String for the specified [charCodes].
   */
  String.fromCharCodes(List<int> charCodes);

  /**
   * Gets the character (as [String]) at the given [index].
   */
  String operator [](int index);

  /**
   * Gets the scalar character code at the given [index].
   */
  int charCodeAt(int index);

  /**
   * The length of the string.
   */
  int get length();

  /**
   * Returns whether the two strings are equal. This method compares
   * each individual scalar character codes of the strings.
   */
  bool operator ==(String other);

  /**
   * Returns whether this string ends with [other].
   */
  bool endsWith(String other);

  /**
   * Returns whether this string starts with [other].
   */
  bool startsWith(String other);

  /**
   * Returns the first location of [other] in this string starting at
   * [start] (inclusive).
   * Returns -1 if [other] could not be found.
   */
  int indexOf(String other, [int start]);

  /**
   * Returns the last location of [other] in this string, searching
   * backward starting at [start] (inclusive).
   * Returns -1 if [other] could not be found.
   */
  int lastIndexOf(String other, [int start]);

  /**
   * Returns whether this string is empty.
   */
  bool isEmpty();

  /**
   * Creates a new string by concatenating this string with [other].
   */
  String concat(String other);

  /**
   * Converts [other] to a string and creates a new string by
   * concatenating this string with the converted [other].
   */
  String operator +(Object other);

  /**
   * Returns a substring of this string in the given range.
   * [startIndex] is inclusive and [endIndex] is exclusive.
   */
  String substring(int startIndex, [int endIndex]);

  /**
   * Returns a new string where leading and trailing whitespaces of
   * this string have been removed, or returns this string if it does
   * not have leading and trailing whitespaces.
   */
  String trim();

  /**
   * Returns whether this string contains [other] starting
   * at [startIndex] (inclusive).
   */
  bool contains(Pattern other, [int startIndex]);

  /**
   * Returns a new string where the first occurence of [from] in this string
   * is replaced with [to].
   */
  String replaceFirst(Pattern from, String to);

  /**
   * Returns a new string where all occurences of [from] in this string
   * are replaced with [to].
   */
  String replaceAll(Pattern from, String to);

  /**
   * Splits the string around matches of [pattern]. Returns
   * a list of substrings.
   */
  List<String> split(Pattern pattern);

  /**
   * Returns a list of the characters of this string.
   */
  List<String> splitChars();

  /**
   * Returns a list of the scalar character codes of this string.
   */
  List<int> charCodes();

  /**
   * If this string is not already all lower case, returns a new string
   * where all characters  are made lower case. Returns [:this:] otherwise.
   */
  String toLowerCase();

  /**
   * If this string is not already all uper case, returns a new string
   * where all characters are made upper case. Returns [:this:] otherwise.
   */
  String toUpperCase();
}

</script>
<script type="application//inert" id="src_strings_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class Strings {

  /**
   * Factory implementation of String.fromCharCodes:
   * Allocates a new String for the specified [charCodes].
   */
  factory String.fromCharCodes(List<int> charCodes) {
    return StringBase.createFromCharCodes(charCodes);
  }

  /**
   * Joins all the given strings to create a new string.
   */
  static String join(List<String> strings, String separator) {
    return StringBase.join(strings, separator);
  }

  /**
   * Concatenates all the given strings to create a new string.
   */
  static String concatAll(List<String> strings) {
    return StringBase.concatAll(strings);
  }
}

</script>
<script type="application//inert" id="src_time_zone_dart">
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart core library.

/**
 * [TimeZone]s represent locations (for example Europe/Paris).
 */
interface TimeZone default TimeZoneImplementation {
  const TimeZone.utc();
  TimeZone.local();
  bool get isUtc();
}

</script>
</head></html>
