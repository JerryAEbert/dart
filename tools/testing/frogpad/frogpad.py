#!/usr/bin/python

# Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
# for details. All rights reserved. Use of this source code is governed by a
# BSD-style license that can be found in the LICENSE file.
#

"""
Frogpad is used to compile .dart files to javascript.

This is accomplished by first creating an html file (usually called
<something>.frogpad.html) that can be used to execute the frog compiler in
a web browser (or DumpRenderTree).

The generated frogpad.html contains:

  1. all the dart files that compose a dart program
  2. all the dart files of dart:core and other standard dart libraries
  3. frogpad.dart (compiled to javascript)

The contents of each dart file is placed in a separate <script> tag.

When the html page is loaded by a browser, the frog compiler is invoked
and the dart program is compiled to javascript.  The generated javascript is
placed in a <pre> element with id "output".

When the html page is passed to DumpRenderTree, the dumped output will
have the generated javascript.
"""

import logging
import optparse
import os.path
import re
import subprocess
import sys


class FileNotFoundException(Exception):
  def __init__(self, file_name):
    self._name = file_name

  def __str__(self):
    return self._name


class CommandFailedException(Exception):
  def __init__(self, message):
    self._message = message

  def GetMessage(self):
    return self._message


# This file is produced by compiling frogpad.dart to javascript.  To do this
# we run frogc.dart on the dart vm.
#
# Note, we use ".frogc.js" as the extension (instead of simply ".js"),
# because this file is generated by frogc and not by frogpad.
#
# (For testing, it's useful to be able to distinguish files that are generated
# by frogc from files that are generated by frogpad.)
#
FROGPAD_JS = "frogpad.dart.frogc.js"

# Template for the html page we're going to generate.
HTML = """<html>
<head>
  <style type="text/css">
    textarea {
      width: 100%;
      height: 200px;
    }
    .label {
      margin-top: 5px;
    }
    pre {
      border: 2px solid black;
    }
  </style>
  {{script_tags}}
  <script type="text/javascript">
    if (window.layoutTestController) {
      layoutTestController.dumpAsText();
    }
  </script>
</head>
<body>
  <h1>Frogpad</h1>
  <div class="label">Input:</div>
  <textarea id="input"></textarea>
  <div class="label">Compiler Messages:</div>
  <pre id="warnings"></pre>
  <div class="label">Timing:</div>
  <pre id="timing"></pre>
  <div class="label">Output:</div>
  <pre id="output"></pre>
  <script type="text/javascript">
    {{FROGPAD_JS}}
  </script>
</body>
</html>
"""

# This finds everything after the word "Output:" in the html page.
# (Note, because the javascript we're fishing out spans multiple lines
# we need to use the DOTALL switch here.)
OUTPUT_JAVASCRIPT_REGEX = re.compile(".*\nOutput:(.*)#EOF", re.DOTALL)

# We use "application/inert" here to make the browser ignore the
# these script tags.  (frogpad.dart will fish out the contents as needed.)
#
SCRIPT_TAG = """<script type="application/inert" id="{{id}}">
{{contents}}
</script>
"""

# Regex that finds #import, #source and #native directives in .dart files.
#   match.group(1) = "import", "source" or "native"
#   match.group(2) = url of file being imported
DIRECTIVE_RE = re.compile(r"^#(import|source|native)\([\"']([^\"']*)[\"']")

# id of script tag that holds name of the top dart file to be compiled,
# (This file name passed will be passed to the frog compiler by frogpad.dart.)
MAIN_ID = "main_id"

DART_LIBRARIES = {
    "core": "lib/corelib.dart",
    "coreimpl": "lib/corelib_impl.dart",
    "dom": "../client/dom/frog/dom_frog.dart",
    "html": "../client/html/frog/html_frog.dart",
    "json": "../lib/json/json_frog.dart"
}


class Pad(object):
  """
  Accumulates all source files that are needed to compile a dart program,
  and places them in <script> tags on an html page.
  """

  def __init__(self, argv):
    parser = optparse.OptionParser(usage=
      "%prog [options] file_to_compile.dart"
    )
    parser.add_option("-r", "--rebuild",  action="store_true",
        help="forces rebuild of the frogpad javascript")
    parser.add_option("-o", "--out",
        help="name of javascript output file")
    parser.add_option("-v", "--verbose", action="store_true",
        help="more verbose logging")
    (options, args) = parser.parse_args(argv)

    log_level = logging.INFO
    if options.verbose:
      log_level = logging.DEBUG
    logging.basicConfig(level=log_level)

    if len(args) < 2:
      parser.print_help()
      sys.exit(1)

    self.main_file = os.path.abspath(args[1])

    # directory of this script
    self.frogpad_dir = os.path.abspath(os.path.dirname(argv[0]))

    # root of dart source repo
    self.dart_dir = os.path.dirname(os.path.dirname(os.path.dirname(
        self.frogpad_dir)))

    # directory of frog compiler source code
    self.frog_dir = os.path.join(self.dart_dir, "frog")

    logging.debug("dartdir_dir: '%s'" % self.dart_dir)
    logging.debug("frog_dir: '%s'" % self.frog_dir)
    logging.debug("frogpad_dir: '%s'" % self.frogpad_dir)

    # name of frogpad_js file
    self.frogpad_js = os.path.join(self.frogpad_dir, FROGPAD_JS)

    if options.out:
      # user has specified an output file
      self.js_file = os.path.abspath(options.out)
    else:
      # user didn't specify an output file, so base the name on the
      # input file
      self.js_file = self.main_file + ".frogpad.js"

    logging.debug("js_file: '%s" % self.js_file)

    # this is the html file that we pass to DumpRenderTree
    self.html_file = self.js_file + ".frogpad.html"
    logging.debug("html_file: '%s'" % self.html_file)

    # map from file name to File object (contains entries for all corelib
    # and all other dart files needed to compile main_file)
    self.name_to_file = {}

    # map from script tag id to File object
    self.id_to_file = {}

    if not os.path.exists(self.frogpad_js):
      options.rebuild = True

    if options.rebuild:
      self.build_frogpad_js()

    self.load_libraries()
    self.load_file(self.main_file)

    html = self.generate_html()
    write_file(self.html_file, html)

    js = self.generate_js()
    write_file(self.js_file, js)

    line_count = len(js.splitlines())
    logging.info("generated '%s' (%d lines)", self.js_file, line_count)

  def build_frogpad_js(self):
    dart_vm = os.path.join(self.dart_dir, "out/Release_ia32/dart")
    check_exists(dart_vm)

    frogc_dart = os.path.join(self.frog_dir, "frogc.dart")
    frogpad_dart = os.path.join(self.frogpad_dir, "frogpad.dart")
    check_exists(frogc_dart)
    check_exists(frogpad_dart)

    args = []
    args.append(dart_vm)

    # command line arguments for the dart vm

    # We leave out --enable_type_checks here for speed.
    #    args.append("--enable_type_checks")

    args.append("--enable_asserts")

    # The dart program we're going to run on the dart vm.
    args.append(frogc_dart)

    # Command line arguments for frogc.dart
    args.append("--libdir=%s/lib" % self.frog_dir)
    args.append("--compile-only")
    args.append("--enable_type_checks")
    args.append("--enable_asserts")
    args.append("--out=%s" % self.frogpad_js)

    # The dart program that we want frogc.dart to compile.
    args.append(frogpad_dart)
    logging.info("generating '%s'" % self.frogpad_js)

    run_command(args)
    check_exists(self.frogpad_js)

  def generate_html(self):
    tags = []
    for f in self.id_to_file.values():
      tags.append(self._create_tag(f.id, f.contents))
    tags.append(self._create_tag(MAIN_ID, self.main_file))
    html = HTML.replace("{{script_tags}}", "".join(tags))
    html = html.replace("{{FROGPAD_JS}}", read_file(self.frogpad_js))
    return html

  def generate_js(self):
    drt = os.path.join(self.dart_dir, "client/tests/drt/DumpRenderTree")
    check_exists(drt)
    args = []
    args.append(drt)
    args.append(self.html_file)

    stdout = run_command(args)
    match = OUTPUT_JAVASCRIPT_REGEX.match(stdout)
    if not match:
      raise Exception("can't find regex in DumpRenderTree output")
    return match.group(1)

  @staticmethod
  def _create_tag(id, contents):
    s = SCRIPT_TAG
    s = s.replace("{{id}}", id)
    # TODO(mattsh) - need to html escape here
    s = s.replace("{{contents}}", contents)
    return s

  def dart_library(self, name):
    path = DART_LIBRARIES[name]
    if not path:
      raise Exception("unrecognized 'dart:%s'", name)
    return os.path.join(self.frog_dir, path)

  def load_libraries(self):
    for name in DART_LIBRARIES:
      self.load_file(self.dart_library(name))

  def load_file(self, name):
    name = os.path.abspath(name)
    if name in self.name_to_file:
      return
    f = File(self, name)
    self.name_to_file[f.name] = f
    if f.id in self.id_to_file:
      raise Exception("ambiguous id '%s'" % f.id)
    self.id_to_file[f.id] = f
    f.directives()

class File(object):
  def __init__(self, pad, name):
    self.pad = pad
    self.name = name
    self.id = self._make_id()
    check_exists(name)
    with open(self.name, "r") as f:
      self.contents = f.read()

  def _make_id(self):
    """
    Generates an id (based on the file name) for the <script> tag that will
    hold the contents of this file.
    """
    (dirname, name) = os.path.split(self.name)
    dirname = os.path.basename(dirname)
    name = name.replace(".", "_")
    return dirname + "_" + name

  def directives(self):
    """Load files referenced by #source, #import and #native directives."""
    lines = self.contents.split("\n")
    self.line_number = 0
    for line in lines:
      self.line_number += 1
      self._directive(line)

  def _directive(self, line):
    match = DIRECTIVE_RE.match(line)
    if not match:
      return
    url = match.group(2)
    if url.startswith("dart:"):
      path = self.pad.dart_library(url[len("dart:"):])
    else:
      path = os.path.join(os.path.dirname(self.name), url)
    self.pad.load_file(path)

def read_file(file_name):
  check_exists(file_name)
  with open(file_name, "r") as input:
    contents = input.read()
  logging.debug("read_file '%s' (%d bytes)" % (file_name, len(contents)))
  return contents

def write_file(file_name, contents):
  with open(file_name, "w") as output:
    output.write(contents)

  check_exists(file_name)
  logging.debug("write_file '%s' (%d bytes)" % (file_name, len(contents)))


def check_exists(file_name):
  if not os.path.exists(file_name):
    raise FileNotFoundException(file_name)


def format_command(args):
  return ' '.join(args)


def run_command(args):
  """
  Args:
    command: comamnd with arguments to exec
  Returns:
    all output that this command sent to stdout
  """

  command = format_command(args)
  logging.debug("RUNNING " + command)
  child = subprocess.Popen(args,
      stdout=subprocess.PIPE,
      stderr=subprocess.PIPE,
      close_fds=True)
  (stdout, stderr) = child.communicate()
  for line in stderr.splitlines():
    logging.info(level, '%s: %s', args[0], line)
  exitcode = child.wait()
  if exitcode:
    msg = "FAILURE (exit_code=%d): '%s'" % (exit_code, command)
    logging.error(msg)
    raise CommandFailedException(msg)
  logging.debug("SUCCEEDED (%d bytes)" % len(stdout))
  return stdout


def main(argv):
  Pad(argv)

if __name__ == "__main__":
  sys.exit(main(sys.argv))
